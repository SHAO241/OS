# Lab5 系统调用调试实验报告

## 一、实验目的

通过双重GDB调试方案，观察系统调用从用户态触发到内核态处理再返回用户态的完整流程，重点观察QEMU如何处理`ecall`和`sret`指令。

## 二、调试方案

### 2.1 双重GDB调试架构（AI）

- **终端1**：运行QEMU（`make debug`）
- **终端2**：调试ucore内核（`make gdb`）
- **终端3**：调试QEMU进程（`gdb -p <pid>`）

### 2.2 关键观测点(AI)

1. **ecall指令**：用户态触发系统调用的入口（`0x800102`）
2. **helper_ecall**：QEMU处理ecall的函数
3. **syscall**：内核的系统调用处理函数
4. **sret指令**：内核返回用户态的出口
5. **helper_sret**：QEMU处理sret的函数

## 三、实际操作过程

### 3.1 启动调试环境

```bash
# 终端1：启动QEMU
cd ~/Desktop/lab5
make debug
# 终端会"卡住"，这是正常的，QEMU在等待GDB连接

# 终端2：连接GDB到ucore
cd ~/Desktop/lab5
make gdb
```

### 3.2 加载用户程序符号表

**问题**：直接设置用户程序断点会失败
```
(gdb) break user/libs/syscall.c:18
No source file named user/libs/syscall.c.
Breakpoint pending.
```

**原因**：用户程序的调试信息在单独的`.out`文件中，需要手动加载。

**解决**：
```bash
(gdb) add-symbol-file obj/__user_exit.out
Reading symbols from obj/__user_exit.out...
(gdb) break user/libs/syscall.c:18
Breakpoint 1 at 0x8000f8: file user/libs/syscall.c, line 19.
```

### 3.3 定位ecall指令

```bash
# 停在syscall函数后，查看汇编代码
(gdb) x/20i $pc
   0x800102 <syscall+46>:  ecall      # 这就是ecall指令
   0x800106 <syscall+50>:  sd     a0,28(sp)
   ...

# 在ecall指令处设置断点
(gdb) break *0x800102
Breakpoint 2 at 0x800102
(gdb) continue
```

### 3.4 尝试调试QEMU

**问题**：系统QEMU没有调试符号
```
(No debugging symbols found in /usr/local/bin/qemu-system-riscv64)
(gdb) break helper_ecall
Function "helper_ecall" not defined.
Breakpoint pending.
```

**原因**：系统安装的QEMU是release版本，没有调试符号。

**尝试的解决方案**：
1. 使用`info functions helper_ecall`查找函数地址 ， 未找到
2. 使用`objdump`查找符号 ， 未找到
3. 使用pending断点 ， 无法触发

**结论**：需要重新编译带调试符号的QEMU才能深入调试QEMU层面。

### 3.5 观察ecall执行效果

虽然无法在QEMU的GDB中观察，但可以通过ucore的GDB确认ecall被处理：

```bash
# 停在ecall指令处
(gdb) x/5i $pc
=> 0x800102: ecall

# 单步执行
(gdb) si

# 直接跳转到内核态
0xffffffffc0200e0c in __alltraps () at kern/trap/trapentry.S:123
```

**观察结果**：
- ecall指令执行后，立即跳转到内核的中断处理入口`__alltraps`
- 说明QEMU正确处理了ecall，触发了异常，切换到内核态

### 3.6 跟踪内核系统调用处理

```bash
# 设置内核的系统调用处理函数断点
(gdb) break syscall
Breakpoint 3 at 0xffffffffc0205180: file kern/syscall/syscall.c, line 83.

(gdb) continue
Breakpoint 3, syscall () at kern/syscall/syscall.c:83

# 查看系统调用参数
(gdb) p/x current->tf->gpr.a0  # 系统调用号
(gdb) p/x current->tf->gpr.a1  # 第一个参数
```

### 3.7 跟踪sret返回

```bash
# 找到sret指令位置
(gdb) disassemble __trapret
   0xffffffffc0204f80 <+32>:  sret

# 设置断点
(gdb) break *0xffffffffc0204f80
(gdb) continue
# 会停在sret指令处
```

## 四、关键发现

### 4.1 ecall指令处理流程

1. **用户态**：执行`ecall`指令（`0x800102`）
2. **QEMU处理**：QEMU检测到ecall，触发异常（虽然无法直接观察）
3. **内核态**：跳转到`__alltraps`（`0xffffffffc0200e0c`）
4. **异常处理**：保存现场，调用`trap`函数
5. **系统调用分发**：`trap_dispatch` → `syscall`

### 4.2 系统调用参数传递

- 系统调用号：`a0`寄存器（`current->tf->gpr.a0`）
- 参数1-5：`a1-a5`寄存器（`current->tf->gpr.a1`等）
- 返回值：通过`a0`寄存器返回（`current->tf->gpr.a0`）

### 4.3 特权级切换

- **U mode → S mode**：通过`ecall`指令，QEMU设置异常原因，跳转到内核
- **S mode → U mode**：通过`sret`指令，QEMU恢复用户态上下文

## 五、遇到的问题及解决

### 问题1：无法在用户程序设置断点

**现象**：`No source file named user/libs/syscall.c`

**原因**：用户程序符号表未加载

**解决**：先执行`add-symbol-file obj/__user_exit.out`

### 问题2：Remote connection closed

**现象**：GDB连接断开

**原因**：QEMU进程退出或未正常启动

**解决**：重新启动QEMU（`make debug`），重新连接GDB

### 问题3：QEMU没有调试符号

**现象**：`No debugging symbols found`

**原因**：系统QEMU是release版本

**解决**：需要重新编译带调试符号的QEMU（`--enable-debug`），本次实验未完成此步骤

### 问题4：ecall指令执行过快

**现象**：单步执行时直接跳过了ecall，进入内核态

**原因**：没有在ecall指令处设置断点

**解决**：使用`break *0x800102`直接在ecall指令处设置断点

## 六、实验总结

### 6.1 完成的工作

1. 成功加载用户程序符号表
2. 定位并观察ecall指令
3. 跟踪ecall执行后的内核态跳转
4. 观察系统调用的参数传递和处理
5. 跟踪到sret指令返回用户态

### 6.2 未完成的工作

神奇的QEMU：
    我编译了N+1遍，他还是告诉我没有调试记号，没办法添加断点，况且也找不到调用ecall的函数在哪里，所幸我们还是追踪到了大部分的流程，基本完成了实验，但是。。。。
    **理论上**如果QEMU是stripped版本 -→ 没有调试符号，无法加载
    如果QEMU有分离的.debug文件 → 可以尝试加载
    **事实上**有分离的文件，而且不是stripped版本，而且也没重新加载成功
和大模型对线：
    结论：QEMU是not stripped但没有符号 → 可能是编译时没加-g



### 6.3 关键收获

1. **理解了系统调用的完整流程**：从用户态ecall → QEMU处理 → 内核态处理 → sret返回
2. **掌握了双重GDB调试方法**：虽然QEMU层面调试受限，但ucore层面调试成功
3. **理解了符号表加载的重要性**：用户程序需要手动加载符号表
4. **认识到调试符号的重要性**：要深入调试底层代码，必须有调试符号

### 6.4 改进建议

1. **重新编译QEMU**：使用`--enable-debug`选项编译，获得完整的调试能力
2. **使用脚本自动化**：编写脚本自动加载符号表、设置断点
3. **记录关键地址**：将ecall、sret等关键指令地址记录下来，方便后续调试

## 七、调试命令速查

### 终端1：启动QEMU
```bash
make debug
```

### 终端2：调试ucore
```bash
make gdb
add-symbol-file obj/__user_exit.out
break user/libs/syscall.c:18
break *0x800102  # ecall指令
break syscall    # 内核系统调用处理
break *0xffffffffc0204f80  # sret指令
```

### 终端3：调试QEMU（需要重新编译）
```bash
pgrep -f qemu-system-riscv64
sudo gdb qemu-system-riscv64 -p <PID>
handle SIGPIPE nostop noprint
break helper_ecall
break helper_sret
```

## 八、参考资料

1. RISC-V Privileged Architecture Specification
2. QEMU官方文档
3. ucore实验指导书
4. GDB用户手册

---

**实验完成时间**：2077年7月7日  
**实验者**：吕影焜
