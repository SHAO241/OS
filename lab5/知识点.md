#### 如何第一次进入到用户进程？

需要在**内核态**触发一个异常，从而借助异常处理机制的返回流程进行上下文的切换。

---

#### Lab4 与 Lab5 中 `init_main` 函数的对比

##### Lab4 中的 `init_main`（内核线程示例）

```c
// kern/process/proc.c (lab4)
static int init_main(void *arg) {
    cprintf("this initproc, pid = %d, name = \"%s\"\n", current->pid, get_proc_name(current));
    cprintf("To U: \"%s\".\n", (const char *)arg);
    cprintf("To U: \"en.., Bye, Bye. :)\"\n");
    return 0;
}
```

**特点**：
- 这是一个纯粹的**内核线程**
- 只是简单地打印一些信息后就返回
- 没有创建用户进程的功能
- 用于演示内核线程的创建和运行机制

##### Lab5 中的 `init_main`（用户进程管理）


**特点**：
- 充当**所有用户进程的祖先进程**（类似 Linux 的 init 进程）
- 调用 `kernel_thread(user_main, NULL, 0)` 创建 `user_main` 内核线程
- 使用 `do_wait(0, NULL)` 循环等待回收所有子进程
- 进行内存泄漏检查（通过断言验证进程关系和数量）

##### `init_main` 代码详细解读

```c
static int init_main(void *arg)
{
    // 1. 记录当前内存状态（用于后续内存泄漏检查）
    size_t nr_free_pages_store = nr_free_pages();      // 记录空闲页面数
    size_t kernel_allocated_store = kallocated();       // 记录内核已分配内存

    // 2. 创建 user_main 内核线程（将来会变成用户进程）
    int pid = kernel_thread(user_main, NULL, 0);
    if (pid <= 0) {
        panic("create user_main failed.\n");
    }

    // 3. 循环等待并回收所有子进程
    // do_wait(0, NULL): pid=0 表示等待任意子进程，NULL 表示不需要获取退出码
    while (do_wait(0, NULL) == 0) {
        schedule();  // 让出 CPU，等待子进程运行和退出
    }
    // 当 do_wait 返回非 0（-E_BAD_PROC）时，说明没有子进程了

    cprintf("all user-mode processes have quit.\n");
    
    // 4. 内存泄漏检查：验证所有子进程都已回收
    assert(initproc->cptr == NULL && initproc->yptr == NULL && initproc->optr == NULL);
    // cptr/yptr/optr 都为 NULL 说明没有子进程、兄弟进程了
    
    assert(nr_process == 2);  // 只剩 idleproc(pid=0) 和 initproc(pid=1)
    assert(list_next(&proc_list) == &(initproc->list_link));
    assert(list_prev(&proc_list) == &(initproc->list_link));
    // 进程链表中只有 initproc 一个进程（idleproc 不在链表中）

    cprintf("init check memory pass.\n");
    return 0;
}
```

**`init_main` 的三大职责**：
1. **创建用户进程**：调用 `kernel_thread(user_main, ...)` 创建执行用户程序的线程
2. **回收子进程**：循环调用 `do_wait` 回收所有僵尸子进程的资源
3. **完整性检查**：验证所有子进程都已退出，内存都已回收

---

#### `user_main` 函数详细分析

```c
// user_main - kernel thread used to exec a user program
static int
user_main(void *arg)
{
#ifdef TEST
    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);
#else
    KERNEL_EXECVE(exit);
#endif
    panic("user_main execve failed.\n");
}
```

##### 执行流程

```
user_main() 被创建为内核线程
      |
      v
调用 KERNEL_EXECVE(exit)
      |
      v
KERNEL_EXECVE 宏展开，调用 kernel_execve("exit", binary, size)
      |
      v
kernel_execve 通过 ebreak 触发断点异常
      |
      v
异常处理程序调用 do_execve() -> load_icode()
      |
      v
load_icode 加载 ELF 程序，设置用户态 trapframe
      |
      v
异常返回时通过 sret 进入用户态执行 exit 程序
      |
      v
【注意】如果成功，代码流程永远不会返回到 user_main
        因为进程已经变成了用户进程，执行用户代码去了
      |
      v
panic() 只有在 kernel_execve 失败时才会执行
```

**为什么 `user_main` 是内核线程却能执行用户程序？**

`user_main` 一开始确实是内核线程（运行在内核态），但通过 `kernel_execve` → `do_execve` → `load_icode` 这条调用链：
1. 创建新的用户地址空间（mm_struct）
2. 加载用户程序的 ELF 文件到内存
3. 设置 trapframe 使得异常返回时进入用户态
4. 当 `sret` 指令执行后，进程就从内核态"变身"为用户态进程了

---

#### `kernel_execve` 函数详细分析

##### 为什么需要 `kernel_execve`？

**问题**：`user_main` 是内核线程，运行在内核态。如何让它"变成"用户进程？

**解决方案**：利用**异常返回机制**。在内核态触发一个异常，然后在异常处理中加载用户程序并设置好 trapframe，当异常返回（`sret`）时就会进入用户态。

##### 代码逐行解析

```c
static int
kernel_execve(const char *name, unsigned char *binary, size_t size)
{
    int64_t ret = 0, len = strlen(name);
    
    // 使用内联汇编触发断点异常
    asm volatile(
        "li a0, %1\n"      // a0 = SYS_exec (系统调用号，值为 4)
        "lw a1, %2\n"      // a1 = name (程序名字符串地址)
        "lw a2, %3\n"      // a2 = len (程序名长度)
        "lw a3, %4\n"      // a3 = binary (程序二进制数据地址)
        "lw a4, %5\n"      // a4 = size (程序大小)
        "li a7, 10\n"      // a7 = 10 (特殊标记，表示这是内核态的 execve 调用)
        "ebreak\n"         // 触发断点异常（CAUSE_BREAKPOINT）
        "sw a0, %0\n"      // 异常返回后，保存返回值到 ret
        : "=m"(ret)
        : "i"(SYS_exec), "m"(name), "m"(len), "m"(binary), "m"(size)
        : "memory");
    cprintf("ret = %d\n", ret);
    return ret;
}
```

##### 为什么用 `ebreak` 而不是 `ecall`？

- **`ecall`**：用户态程序调用系统调用时使用，会产生 `CAUSE_USER_ECALL` 异常
- **`ebreak`**：产生断点异常 `CAUSE_BREAKPOINT`，可以在任何特权级使用

因为 `user_main` 运行在**内核态（S-mode）**，如果使用 `ecall` 会产生 `CAUSE_SUPERVISOR_ECALL`，处理方式不同。使用 `ebreak` + `a7=10` 的组合可以明确标识这是"内核态发起的 exec 系统调用"。

##### 异常处理程序中的处理（trap.c）

```c
case CAUSE_BREAKPOINT:
    cprintf("Breakpoint\n");
    if (tf->gpr.a7 == 10)  // 检查是否是 kernel_execve 发起的
    {
        tf->epc += 4;      // 跳过 ebreak 指令（4字节）
        syscall();         // 调用 syscall()，它会根据 a0 调用 do_execve
        kernel_execve_ret(tf, current->kstack + KSTACKSIZE);
        // kernel_execve_ret 设置新的内核栈，准备返回用户态
    }
    break;
```

##### 完整调用链

```
kernel_execve()
    |
    +-- ebreak 指令触发断点异常
    |
    v
trap() -> exception_handler()
    |
    +-- case CAUSE_BREAKPOINT:
    |       if (tf->gpr.a7 == 10)
    |
    v
syscall()
    |
    +-- case SYS_exec:
    |       do_execve(name, len, binary, size)
    |
    v
do_execve()
    |
    +-- 释放旧的内存空间（如果有）
    +-- load_icode(binary, size)
    |
    v
load_icode()
    |
    +-- (1) 创建新的 mm_struct
    +-- (2) 创建新的页目录表
    +-- (3) 解析 ELF，加载代码段、数据段、BSS段
    +-- (4) 创建用户栈
    +-- (5) 设置 current->mm 和 current->pgdir
    +-- (6) 设置 trapframe:
    |         tf->gpr.sp = USTACKTOP (用户栈顶)
    |         tf->epc = elf->e_entry (程序入口点)
    |         tf->status = 用户态状态（清除 SPP 位）
    |
    v
kernel_execve_ret(tf, kstacktop)
    |
    +-- 切换到正确的内核栈
    |
    v
sret 指令执行
    |
    +-- 根据 trapframe 恢复寄存器
    +-- 根据 tf->status（SPP=0）返回到用户态
    +-- 根据 tf->epc 跳转到程序入口执行
    |
    v
用户程序开始在用户态运行！
```

---

#### `syscall()` 函数详解

##### 系统调用号定义（unistd.h）

```c
// libs/unistd.h
/* syscall number */
#define SYS_exit            1
#define SYS_fork            2
#define SYS_wait            3
#define SYS_exec            4   // kernel_execve 使用这个
#define SYS_clone           5
#define SYS_yield           10
#define SYS_sleep           11
#define SYS_kill            12
#define SYS_gettime         17
#define SYS_getpid          18
#define SYS_putc            30
#define SYS_pgdir           31
```

##### 系统调用处理函数表

```c
// 各个系统调用的处理函数
static int sys_exit(uint64_t arg[])  { return do_exit((int)arg[0]); }
static int sys_fork(uint64_t arg[])  { return do_fork(0, tf->gpr.sp, tf); }
static int sys_wait(uint64_t arg[])  { return do_wait((int)arg[0], (int *)arg[1]); }
static int sys_exec(uint64_t arg[])  { 
    return do_execve((const char *)arg[0], (size_t)arg[1], 
                     (unsigned char *)arg[2], (size_t)arg[3]); 
}
static int sys_yield(uint64_t arg[]) { return do_yield(); }
static int sys_kill(uint64_t arg[])  { return do_kill((int)arg[0]); }
static int sys_getpid(uint64_t arg[]){ return current->pid; }
static int sys_putc(uint64_t arg[])  { cputchar((int)arg[0]); return 0; }

// 系统调用函数指针数组（用系统调用号作为下标）
static int (*syscalls[])(uint64_t arg[]) = {
    [SYS_exit]    sys_exit,
    [SYS_fork]    sys_fork,
    [SYS_wait]    sys_wait,
    [SYS_exec]    sys_exec,    // syscalls[4] = sys_exec
    [SYS_yield]   sys_yield,
    [SYS_kill]    sys_kill,
    [SYS_getpid]  sys_getpid,
    [SYS_putc]    sys_putc,
    [SYS_pgdir]   sys_pgdir,
};
```

##### `syscall()` 函数源码详解

```c
void syscall(void) 
{
    // 1. 获取当前进程的 trapframe
    struct trapframe *tf = current->tf;
    uint64_t arg[5];
    
    // 2. 从 a0 寄存器获取系统调用号
    // 在 kernel_execve 中: li a0, SYS_exec (即 a0 = 4)
    int num = tf->gpr.a0;
    
    // 3. 检查系统调用号是否有效
    if (num >= 0 && num < NUM_SYSCALLS) {
        if (syscalls[num] != NULL) {
            // 4. 从寄存器 a1-a5 获取系统调用参数
            // kernel_execve 中设置了:
            //   a1 = name (程序名)
            //   a2 = len (名字长度)
            //   a3 = binary (程序二进制地址)
            //   a4 = size (程序大小)
            arg[0] = tf->gpr.a1;
            arg[1] = tf->gpr.a2;
            arg[2] = tf->gpr.a3;
            arg[3] = tf->gpr.a4;
            arg[4] = tf->gpr.a5;
            
            // 5. 调用对应的系统调用处理函数
            // syscalls[4] = sys_exec
            // sys_exec 会调用 do_execve(name, len, binary, size)
            tf->gpr.a0 = syscalls[num](arg);
            // 返回值存入 a0，供调用者使用
            return;
        }
    }
    
    // 6. 未定义的系统调用，panic
    print_trapframe(tf);
    panic("undefined syscall %d, pid = %d, name = %s.\n",
            num, current->pid, current->name);
}
```

##### `kernel_execve` 与 `syscall` 的参数传递

```c
// kernel_execve 中的内联汇编
asm volatile(
    "li a0, %1\n"      // a0 = SYS_exec = 4 (系统调用号)
    "lw a1, %2\n"      // a1 = name
    "lw a2, %3\n"      // a2 = len
    "lw a3, %4\n"      // a3 = binary
    "lw a4, %5\n"      // a4 = size
    "li a7, 10\n"      // a7 = 10 (标记这是 kernel_execve)
    "ebreak\n"         // 触发断点异常
    ...
);
```

**参数传递流程**：
```
kernel_execve 设置寄存器:
    a0 = 4 (SYS_exec)
    a1 = name
    a2 = len  
    a3 = binary
    a4 = size
    a7 = 10
        |
        v (ebreak 触发异常，寄存器保存到 trapframe)
        
trapframe 中:
    tf->gpr.a0 = 4
    tf->gpr.a1 = name
    tf->gpr.a2 = len
    tf->gpr.a3 = binary
    tf->gpr.a4 = size
    tf->gpr.a7 = 10
        |
        v (syscall 从 trapframe 读取)
        
syscall() 中:
    num = tf->gpr.a0 = 4
    arg[0] = tf->gpr.a1 = name
    arg[1] = tf->gpr.a2 = len
    arg[2] = tf->gpr.a3 = binary
    arg[3] = tf->gpr.a4 = size
        |
        v (调用 syscalls[4] = sys_exec)
        
sys_exec(arg):
    do_execve(arg[0], arg[1], arg[2], arg[3])
    即 do_execve(name, len, binary, size)
```

##### 用户态系统调用 vs 内核态系统调用

| 方面 | 用户态系统调用 | 内核态系统调用 (kernel_execve) |
|------|----------------|-------------------------------|
| 触发方式 | `ecall` 指令 | `ebreak` 指令 |
| 异常类型 | `CAUSE_USER_ECALL` | `CAUSE_BREAKPOINT` |
| 识别标记 | 无需特殊标记 | `a7 = 10` |
| 调用位置 | 用户程序 | 内核线程 (`user_main`) |
| 目的 | 用户程序请求内核服务 | 内核线程加载用户程序 |

##### 系统调用完整流程图

```
【用户态系统调用】                 【内核态 kernel_execve】
用户程序调用 syscall()             kernel_execve() 
    |                                   |
    v                                   v
设置 a0=调用号, a1-a5=参数        设置 a0=SYS_exec, a1-a4=参数, a7=10
    |                                   |
    v                                   v
ecall 指令                         ebreak 指令
    |                                   |
    v                                   v
CAUSE_USER_ECALL                   CAUSE_BREAKPOINT
    |                                   |
    v                                   v
exception_handler                  exception_handler
    |                                   |
    v                                   v
tf->epc += 4                       if (a7 == 10): tf->epc += 4
    |                                   |
    v                                   v
syscall()                          syscall()
    |                                   |
    v                                   v
根据 a0 调用对应处理函数           syscalls[4] = sys_exec
    |                                   |
    v                                   v
返回用户态继续执行                  do_execve -> load_icode
                                        |
                                        v
                                   kernel_execve_ret
                                        |
                                        v
                                   sret 进入用户态
```

---

#### `do_execve` 函数详解

##### 函数功能

`do_execve` 负责**替换当前进程的地址空间**，用新的用户程序替代原有内容。这是 `exec` 系统调用的核心实现。

##### 源码详解

```c
// do_execve - call exit_mmap(mm)&put_pgdir(mm) to reclaim memory space of current process
//           - call load_icode to setup new memory space accroding binary prog.
int do_execve(const char *name, size_t len, unsigned char *binary, size_t size)
{
    struct mm_struct *mm = current->mm;
    
    // 1. 验证程序名指针的有效性
    // 检查 name 指向的内存是否在用户空间且可读
    if (!user_mem_check(mm, (uintptr_t)name, len, 0))
    {
        return -E_INVAL;
    }
    
    // 2. 限制程序名长度
    if (len > PROC_NAME_LEN)
    {
        len = PROC_NAME_LEN;
    }

    // 3. 将程序名复制到内核空间的局部变量
    // 因为稍后会释放用户空间，name 指针会失效
    char local_name[PROC_NAME_LEN + 1];
    memset(local_name, 0, sizeof(local_name));
    memcpy(local_name, name, len);

    // 4. 释放当前进程的用户空间（如果有）
    if (mm != NULL)
    {
        cputs("mm != NULL");
        
        // 4.1 切换到内核页目录表
        // 因为要释放当前进程的页目录表，必须先切换出去
        lsatp(boot_pgdir_pa);
        
        // 4.2 减少 mm 的引用计数
        // 如果计数变为 0，说明没有其他进程共享这个 mm，可以释放
        if (mm_count_dec(mm) == 0)
        {
            exit_mmap(mm);   // 释放所有 VMA 对应的物理页
            put_pgdir(mm);   // 释放页目录表
            mm_destroy(mm);  // 释放 mm_struct 结构体
        }
        current->mm = NULL;
    }
    
    // 5. 加载新的用户程序
    int ret;
    if ((ret = load_icode(binary, size)) != 0)
    {
        goto execve_exit;  // 加载失败，退出进程
    }
    
    // 6. 设置进程名
    set_proc_name(current, local_name);
    return 0;

execve_exit:
    // 加载失败，终止进程
    do_exit(ret);
    panic("already exit: %e.\n", ret);  // 不应该执行到这里
}
```

##### 执行流程图

```
do_execve(name, len, binary, size)
    |
    v
验证 name 指针有效性
    |
    v
复制 name 到 local_name（内核空间）
    |
    v
current->mm != NULL?  ----No----> 跳到 load_icode
    |
   Yes
    |
    v
lsatp(boot_pgdir_pa)  // 切换到内核页目录
    |
    v
mm_count_dec(mm) == 0?  ----No----> 只是解除关联
    |
   Yes（没有其他进程共享）
    |
    v
exit_mmap(mm)    // 释放物理页
put_pgdir(mm)    // 释放页目录表
mm_destroy(mm)   // 释放 mm_struct
    |
    v
current->mm = NULL
    |
    v
load_icode(binary, size)  // 加载新程序
    |
    +--失败--> do_exit(ret) 退出进程
    |
   成功
    |
    v
set_proc_name(current, local_name)
    |
    v
return 0
```

##### 关键操作说明

**为什么要先切换到内核页目录表？**

```c
lsatp(boot_pgdir_pa);
```

因为接下来要释放当前进程的页目录表（`put_pgdir`），如果 CPU 还在使用这个页目录表，释放后会导致崩溃。所以必须先切换到一个安全的页目录表（内核页目录表）。

**为什么要复制 name 到局部变量？**

```c
char local_name[PROC_NAME_LEN + 1];
memcpy(local_name, name, len);
```

`name` 指针指向用户空间，当调用 `exit_mmap` 释放用户空间后，`name` 指向的内存就失效了。所以必须在释放前将其复制到内核栈上。

**mm_count 引用计数的作用**

```c
if (mm_count_dec(mm) == 0)
{
    // 释放 mm 相关资源
}
```

多个进程可能共享同一个 `mm_struct`（通过 `CLONE_VM` 标志创建的线程）。只有当引用计数降为 0 时，才能真正释放这些资源。

##### `do_execve` 与 `load_icode` 的分工

| 函数 | 职责 |
|------|------|
| `do_execve` | 释放旧的地址空间，调用 `load_icode`，设置进程名 |
| `load_icode` | 创建新的 mm_struct、页目录表，解析 ELF，加载代码/数据，创建用户栈，设置 trapframe |

##### 对于 `kernel_execve` 调用的特殊情况

当 `kernel_execve` → `syscall` → `do_execve` 时：

```c
if (mm != NULL)  // 对于 user_main 内核线程，mm 是 NULL
{
    // 这段代码不会执行
}
```

因为 `user_main` 是**内核线程**，它的 `mm` 字段为 `NULL`（内核线程没有独立的用户地址空间）。所以 `do_execve` 会直接调用 `load_icode` 创建全新的用户地址空间。

---

#### `kernel_execve_ret` 函数详解

##### 为什么需要 `kernel_execve_ret`？

在 `kernel_execve` 触发断点异常时，异常处理使用的是**当时的内核栈**。但经过 `load_icode` 后：
- 进程的地址空间已经**完全改变**了（新的页目录表、新的用户空间）
- 原来的内核栈位置可能已经不正确了
- `trapframe` 的位置需要调整到新进程的内核栈顶

**`kernel_execve_ret` 的作用**：将 `trapframe` 复制到正确的内核栈位置，然后从那里返回用户态。

##### 调用位置（trap.c）

```c
case CAUSE_BREAKPOINT:
    cprintf("Breakpoint\n");
    if (tf->gpr.a7 == 10)  // 是 kernel_execve 发起的
    {
        tf->epc += 4;      // 跳过 ebreak 指令
        syscall();         // 调用 do_execve -> load_icode
        kernel_execve_ret(tf, current->kstack + KSTACKSIZE);
        // 参数：tf = 当前 trapframe
        //       current->kstack + KSTACKSIZE = 内核栈顶
    }
    break;
```

##### 汇编源码详解（trapentry.S）

```asm
    .global kernel_execve_ret
kernel_execve_ret:
    // 参数：a0 = tf (原 trapframe 地址)
    //       a1 = kstacktop (内核栈顶地址)
    
    // 1. 计算新 trapframe 的位置
    // trapframe 结构体大小 = 36 * REGBYTES (36个寄存器，每个8字节)
    addi a1, a1, -36*REGBYTES
    // 现在 a1 指向新 trapframe 的起始位置（内核栈顶 - trapframe大小）

    // 2. 将原 trapframe 的内容复制到新位置
    // 从 a0 (原tf) 复制到 a1 (新tf)
    // 使用 s1 作为临时寄存器，逐个字段复制
    LOAD s1, 35*REGBYTES(a0)    // 加载原 tf 的第35个字段
    STORE s1, 35*REGBYTES(a1)   // 存储到新 tf 的第35个字段
    LOAD s1, 34*REGBYTES(a0)
    STORE s1, 34*REGBYTES(a1)
    // ... 复制所有 36 个字段 (0-35) ...
    LOAD s1, 1*REGBYTES(a0)
    STORE s1, 1*REGBYTES(a1)
    LOAD s1, 0*REGBYTES(a0)
    STORE s1, 0*REGBYTES(a1)

    // 3. 将 sp 设置为新 trapframe 的地址
    move sp, a1
    
    // 4. 跳转到 __trapret，从新的 trapframe 返回
    j __trapret
```

##### `__trapret` 的作用

```asm
__trapret:
    RESTORE_ALL    // 从 trapframe 恢复所有寄存器
    sret           // 返回到用户态（根据 sstatus.SPP 和 sepc）
```

##### 内存布局变化图解

**调用 `kernel_execve_ret` 之前**：
```
原内核栈（可能已经不在正确位置）:
+------------------+ <- 某个位置
|   原 trapframe   |
|   (36 * 8 字节)  |
+------------------+ <- tf (a0)
|      ...         |
+------------------+

当前进程的新内核栈（load_icode 后）:
+------------------+ <- current->kstack + KSTACKSIZE (栈顶)
|    (空的)        |
+------------------+ <- current->kstack (栈底)
```

**调用 `kernel_execve_ret` 之后**：
```
当前进程的新内核栈:
+------------------+ <- current->kstack + KSTACKSIZE (栈顶)
|   新 trapframe   |  <-- 从原 tf 复制过来
|   (36 * 8 字节)  |
+------------------+ <- sp = a1 (新 trapframe 起始地址)
|    (未使用)      |
+------------------+ <- current->kstack (栈底)
```

##### 为什么要复制 trapframe？

1. **原 trapframe 位置不对**：`kernel_execve` 是从 `user_main` 内核线程调用的，使用的是 `user_main` 被创建时分配的栈空间。但 `load_icode` 可能改变了进程的内核栈。


2. **确保 sret 能正确返回**：`sret` 指令执行后会根据 trapframe 中的 `epc`、`status`、`sp` 等恢复状态。trapframe 必须在正确的内核栈位置，才能保证后续的中断/异常处理正确。

3. **新进程的内核栈顶**：`current->kstack + KSTACKSIZE` 是内核栈的最高地址，trapframe 应该放在栈顶位置（栈是向下增长的）。

##### 完整流程总结

```
kernel_execve() 触发 ebreak
    |
    v
trap() 保存 trapframe 到当前栈
    |
    v
exception_handler() -> syscall() -> do_execve() -> load_icode()
    |                                              |
    |                                    设置了新的 mm、pgdir
    |                                    修改了 tf->epc、tf->sp、tf->status
    v
kernel_execve_ret(tf, current->kstack + KSTACKSIZE)
    |
    +-- 计算新栈位置: a1 = kstacktop - 36*REGBYTES
    |
    +-- 复制 trapframe: 从 tf(a0) 复制到新位置(a1)
    |
    +-- 设置 sp = a1
    |
    +-- j __trapret
            |
            v
        RESTORE_ALL (恢复所有寄存器)
            |
            v
        sret (返回用户态)
            |
            v
        用户程序从 tf->epc (程序入口) 开始执行
        使用 tf->gpr.sp (USTACKTOP) 作为用户栈
```


#### 进程创建流程总结

```
proc_init()
    |
    +--> idleproc (pid=0, 第一个内核线程，空闲进程)
    |
    +--> kernel_thread(init_main, ...) 创建 initproc (pid=1)
              |
              +--> init_main()
                        |
                        +--> kernel_thread(user_main, ...) 创建 user_main 线程 (pid=2)
                        |           |
                        |           +--> user_main()
                        |                    |
                        |                    +--> KERNEL_EXECVE(exit)
                        |                            |
                        |                            +--> kernel_execve()
                        |                                    |
                        |                                    +--> ebreak 触发异常
                        |                                            |
                        |                                            +--> do_execve()
                        |                                                    |
                        |                                                    +--> load_icode() 加载用户程序
                        |                                                            |
                        |                                                            +--> 设置 trapframe
                        |                                                                    |
                        |                                                                    +--> sret 返回用户态
                        |
                        +--> do_wait() 循环等待子进程退出
                        |
                        +--> 所有子进程退出后，进行内存检查
```

---

#### Lab4 到 Lab5 的核心变化

| 方面 | Lab4 | Lab5 |
|------|------|------|
| `init_main` 功能 | 简单打印信息 | 创建用户进程，等待回收 |
| 进程类型 | 仅内核线程 | 支持用户进程 |
| 新增函数 | 无 | `user_main`, `kernel_execve`, `do_execve`, `load_icode` |
| 系统调用 | 无 | `SYS_exec`, `SYS_exit`, `SYS_wait` 等 |
| 进程关系 | 简单链表 | 父子兄弟关系（`cptr`, `optr`, `yptr`） |

---

#### `do_wait` 的作用

```c
while (do_wait(0, NULL) == 0)
{
    schedule();
}
```

- `do_wait(0, NULL)` 等待任意子进程（pid=0 表示任意子进程）退出
- 当子进程变为 `PROC_ZOMBIE` 状态时，`do_wait` 回收其资源
- 循环直到没有子进程可回收（返回 `-E_BAD_PROC`）
- 类似于 Linux 中 init 进程回收孤儿进程的机制

##### `do_wait` 源码详解

```c
// do_wait - wait one OR any children with PROC_ZOMBIE state, and free memory space of kernel stack
//         - proc struct of this child.
// NOTE: only after do_wait function, all resources of the child proces are free.
int do_wait(int pid, int *code_store)
{
    struct mm_struct *mm = current->mm;
    
    // 1. 验证 code_store 指针的有效性（如果不为NULL）
    if (code_store != NULL)
    {
        // 检查用户空间地址是否可写
        if (!user_mem_check(mm, (uintptr_t)code_store, sizeof(int), 1))
        {
            return -E_INVAL;
        }
    }

    struct proc_struct *proc;
    bool intr_flag, haskid;
    
repeat:  // 循环标签，用于重复等待
    haskid = 0;  // 标记是否有子进程
    
    // 2. 根据 pid 参数决定等待哪个子进程
    if (pid != 0)
    {
        // pid != 0: 等待指定 pid 的子进程
        proc = find_proc(pid);
        if (proc != NULL && proc->parent == current)
        {
            haskid = 1;  // 找到了指定的子进程
            if (proc->state == PROC_ZOMBIE)
            {
                goto found;  // 子进程已退出，跳转到回收代码
            }
        }
    }
    else
    {
        // pid == 0: 等待任意子进程
        // 遍历当前进程的所有子进程（通过 cptr 和 optr 链表）
        proc = current->cptr;  // cptr 指向第一个子进程
        for (; proc != NULL; proc = proc->optr)  // optr 指向下一个兄弟进程
        {
            haskid = 1;  // 有子进程存在
            if (proc->state == PROC_ZOMBIE)
            {
                goto found;  // 找到一个已退出的子进程
            }
        }
    }
    
    // 3. 如果有子进程但都没退出，则睡眠等待
    if (haskid)
    {
        current->state = PROC_SLEEPING;      // 当前进程进入睡眠状态
        current->wait_state = WT_CHILD;      // 设置等待原因为"等待子进程"
        schedule();                           // 调度其他进程运行
        
        // 被唤醒后检查是否需要退出
        if (current->flags & PF_EXITING)
        {
            do_exit(-E_KILLED);  // 如果被标记为退出，则退出
        }
        goto repeat;  // 重新检查子进程状态
    }
    
    // 4. 没有子进程，返回错误
    return -E_BAD_PROC;

found:
    // 5. 找到了 ZOMBIE 状态的子进程，回收其资源
    
    // 安全检查：不能回收 idleproc 或 initproc
    if (proc == idleproc || proc == initproc)
    {
        panic("wait idleproc or initproc.\n");
    }
    
    // 如果调用者需要获取子进程的退出码
    if (code_store != NULL)
    {
        *code_store = proc->exit_code;
    }
    
    // 关中断，保证原子操作
    local_intr_save(intr_flag);
    {
        unhash_proc(proc);    // 从 hash 表中移除
        remove_links(proc);   // 从进程链表和父子关系中移除
    }
    local_intr_restore(intr_flag);
    
    // 释放子进程的内核栈
    put_kstack(proc);
    // 释放 proc_struct 结构体
    kfree(proc);
    
    return 0;  // 成功回收
}
```

##### `do_wait` 流程图

```
do_wait(pid, code_store)
    |
    v
验证 code_store 地址有效性
    |
    v
+---> [repeat] 开始/重新查找
|         |
|         v
|    pid != 0 ?
|    /        \
|   Yes        No
|   |          |
|   v          v
| find_proc(pid)   遍历 current->cptr 链表
|   |          |
|   v          v
| 是当前进程的子进程?   找到任意子进程?
|   |          |
|   v          v
| proc->state == ZOMBIE?  proc->state == ZOMBIE?
|   |          |
|   +----+-----+
|        |
|        v
|   有子进程但未退出 (haskid=1, 未找到ZOMBIE)
|        |
|        v
|   current->state = SLEEPING
|   current->wait_state = WT_CHILD
|   schedule() 让出CPU
|        |
|        v
|   被唤醒后（子进程调用 do_exit 时会唤醒父进程）
|        |
|        v
|   检查 PF_EXITING 标志
|        |
+--------+ goto repeat
         
找到 ZOMBIE 子进程 (goto found)
    |
    v
获取退出码（如果需要）
    |
    v
关中断 -> unhash_proc -> remove_links -> 开中断
    |
    v
put_kstack() 释放内核栈
    |
    v
kfree(proc) 释放进程控制块
    |
    v
return 0 成功
```

##### 进程关系指针说明

| 指针 | 含义 | 用途 |
|------|------|------|
| `cptr` | child pointer | 指向**第一个子进程** |
| `optr` | older sibling pointer | 指向**兄进程**（较早创建的兄弟） |
| `yptr` | younger sibling pointer | 指向**弟进程**（较晚创建的兄弟） |
| `parent` | parent pointer | 指向**父进程** |

**遍历所有子进程的方式**：
```c
// 从 cptr 开始，沿着 optr 遍历
for (proc = current->cptr; proc != NULL; proc = proc->optr) {
    // proc 依次为第一个子进程、第二个子进程...
}
```

##### `do_wait` 与 `do_exit` 的配合

1. **子进程退出时**（`do_exit`）：
   - 设置 `state = PROC_ZOMBIE`
   - 调用 `wakeup_proc(parent)` 唤醒等待的父进程

2. **父进程等待时**（`do_wait`）：
   - 如果没有 ZOMBIE 子进程，进入 `PROC_SLEEPING` 状态
   - 被唤醒后重新检查子进程状态
   - 找到 ZOMBIE 子进程后回收其资源

---


#### `KERNEL_EXECVE` 系列宏详解

##### 宏定义代码

```c
#define __KERNEL_EXECVE(name, binary, size) ({           \
    cprintf("kernel_execve: pid = %d, name = \"%s\".\n", \
            current->pid, name);                         \
    kernel_execve(name, binary, (size_t)(size));         \
})

#define KERNEL_EXECVE(x) ({                                    \
    extern unsigned char _binary_obj___user_##x##_out_start[], \
        _binary_obj___user_##x##_out_size[];                   \
    __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,    \
                    _binary_obj___user_##x##_out_size);        \
})

#define __KERNEL_EXECVE2(x, xstart, xsize) ({   \
    extern unsigned char xstart[], xsize[];     \
    __KERNEL_EXECVE(#x, xstart, (size_t)xsize); \
})

#define KERNEL_EXECVE2(x, xstart, xsize) __KERNEL_EXECVE2(x, xstart, xsize)
```

##### `KERNEL_EXECVE(x)` 宏解析

**作用**：加载并执行名为 `x` 的用户程序

**宏展开过程**（以 `KERNEL_EXECVE(exit)` 为例）：

```c
KERNEL_EXECVE(exit)
// 展开为：
{
    extern unsigned char _binary_obj___user_exit_out_start[];  // 用户程序的起始地址
    extern unsigned char _binary_obj___user_exit_out_size[];   // 用户程序的大小
    __KERNEL_EXECVE("exit", _binary_obj___user_exit_out_start, 
                    _binary_obj___user_exit_out_size);
}
// 最终展开为：
{
    cprintf("kernel_execve: pid = %d, name = \"exit\".\n", current->pid, "exit");
    kernel_execve("exit", _binary_obj___user_exit_out_start, 
                  (size_t)(_binary_obj___user_exit_out_size));
}
```

**关键技巧**：
- `##` 是**token 粘贴运算符**，将 `x` 与其他字符串拼接
- `#x` 是**字符串化运算符**，将 `x` 转换为字符串 `"x"`
- `_binary_obj___user_##x##_out_start` 和 `_binary_obj___user_##x##_out_size` 是**链接器自动生成的符号**

##### 链接器符号的来源

当用户程序（如 `user/exit.c`）编译后，通过 `objcopy` 工具或链接脚本将其嵌入到内核中。链接器会自动创建以下符号：

| 符号名 | 含义 |
|--------|------|
| `_binary_obj___user_exit_out_start` | 用户程序二进制数据的**起始地址** |
| `_binary_obj___user_exit_out_size` | 用户程序二进制数据的**大小**（以指针形式表示） |
| `_binary_obj___user_exit_out_end` | 用户程序二进制数据的**结束地址** |

##### `KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE)` 解析

**用途**：用于测试时指定**自定义的用户程序符号**

**使用场景**：
```c
static int user_main(void *arg)
{
#ifdef TEST
    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);  // 测试模式：运行指定的测试程序
#else
    KERNEL_EXECVE(exit);                        // 默认模式：运行 exit 程序
#endif
    panic("user_main execve failed.\n");
}
```

**宏展开**（假设 `TEST=hello`, `TESTSTART=_binary_obj___user_hello_out_start`, `TESTSIZE=_binary_obj___user_hello_out_size`）：

```c
KERNEL_EXECVE2(hello, _binary_obj___user_hello_out_start, _binary_obj___user_hello_out_size)
// 展开为：
{
    extern unsigned char _binary_obj___user_hello_out_start[];
    extern unsigned char _binary_obj___user_hello_out_size[];
    __KERNEL_EXECVE("hello", _binary_obj___user_hello_out_start, 
                    (size_t)_binary_obj___user_hello_out_size);
}
```

##### 两个宏的区别

| 宏 | 参数 | 用途 |
|----|------|------|
| `KERNEL_EXECVE(x)` | 只需程序名 | 自动拼接符号名，适合固定命名规则的程序 |
| `KERNEL_EXECVE2(x, start, size)` | 程序名 + 起始地址符号 + 大小符号 | 可自定义符号名，适合测试或特殊情况 |

##### 编译时如何定义 TEST

在 `Makefile` 中通过 `-D` 选项传递：

```makefile
# 运行 hello 测试程序
make run TEST=hello
# 编译时会加入：-DTEST=hello -DTESTSTART=_binary_obj___user_hello_out_start -DTESTSIZE=_binary_obj___user_hello_out_size
```

这样 `user_main` 就会执行指定的测试程序而不是默认的 `exit` 程序。

---

#### 用户程序与用户态系统调用

##### 用户程序的存放与加载

用户程序源码存放在 `user/` 目录下，编译时被嵌入到内核镜像中。当 `KERNEL_EXECVE(exit)` 执行时，就是加载 `user/exit.c` 编译后的二进制程序。

##### 用户程序示例：`exit.c`

```c
// user/exit.c
#include <stdio.h>
#include <ulib.h>

int magic = -0x10384;

int main(void) {
    int pid, code;
    cprintf("I am the parent. Forking the child...\n");
    
    // fork() 创建子进程
    if ((pid = fork()) == 0) {
        // 子进程执行这里
        cprintf("I am the child.\n");
        yield();  // 主动让出 CPU
        yield();
        yield();
        yield();
        yield();
        yield();
        yield();
        exit(magic);  // 子进程退出，返回 magic 作为退出码
    }
    else {
        // 父进程执行这里
        cprintf("I am parent, fork a child pid %d\n", pid);
    }
    
    assert(pid > 0);
    cprintf("I am the parent, waiting now..\n");

    // 等待子进程退出，并获取退出码
    assert(waitpid(pid, &code) == 0 && code == magic);
    // 再次等待应该失败（子进程已经被回收）
    assert(waitpid(pid, &code) != 0 && wait() != 0);
    
    cprintf("waitpid %d ok.\n", pid);
    cprintf("exit pass.\n");
    return 0;
}
```

##### `fork()` 的返回值详解

`fork()` 系统调用会**创建一个子进程**，子进程是父进程的副本（复制地址空间）。关键点在于：**`fork()` 调用一次，返回两次**。

| 返回值 | 含义 | 执行位置 |
|--------|------|----------|
| `0` | 当前是**子进程** | 子进程中 |
| `> 0` | 当前是**父进程**，返回值是子进程的 PID | 父进程中 |
| `< 0` | 创建失败 | 父进程中 |

```c
pid = fork();
// 这行代码之后，存在两个进程在并行执行！
// 父进程：pid = 子进程的 PID（比如 3）
// 子进程：pid = 0
```

##### `if` 和 `else` 分支的含义

```c
if ((pid = fork()) == 0) {
    // 【子进程执行这里】
    // 因为子进程中 fork() 返回 0
    cprintf("I am the child.\n");
    // ...
    exit(magic);
}
else {
    // 【父进程执行这里】
    // 因为父进程中 fork() 返回子进程的 PID（> 0）
    cprintf("I am parent, fork a child pid %d\n", pid);
}
```

**执行流程**：
```
fork() 之前：只有父进程（PID=2）

fork() 之后：
┌─────────────────────────────────────────────────────────┐
│                      父进程 (PID=2)                      │
│  pid = fork() 返回 3（子进程的PID）                       │
│  if (pid == 0) --> false                                │
│  else { cprintf("I am parent..."); }  ← 执行这里         │
│  继续执行 assert(pid > 0); ...                           │
│  waitpid(pid, &code) 等待子进程退出                      │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                      子进程 (PID=3)                      │
│  pid = fork() 返回 0                                     │
│  if (pid == 0) --> true  ← 执行这里                      │
│  { cprintf("I am the child."); yield(); exit(magic); }  │
│  子进程调用 exit() 后终止，不会执行 else 和后面的代码       │
└─────────────────────────────────────────────────────────┘
```

##### 为什么要使用 `yield()`？

```c
if ((pid = fork()) == 0) {
    cprintf("I am the child.\n");
    yield();  // 主动让出 CPU
    yield();
    yield();
    yield();
    yield();
    yield();
    yield();
    exit(magic);
}
```

**`yield()` 的作用**：主动让出 CPU，让调度器选择其他进程运行。

**为什么子进程要连续调用 7 次 `yield()`？**

1. **测试调度器**：验证 `yield` 系统调用和进程调度是否正常工作

2. **模拟真实场景**：真实程序中，子进程可能需要做一些工作后再退出。这里用 `yield()` 模拟"做一些事情"

3. **给父进程运行机会**：
   - `fork()` 后，父子进程的执行顺序是不确定的
   - 子进程调用 `yield()` 可以让父进程有机会先执行到 `waitpid()`
   - 这样当子进程 `exit()` 时，父进程已经在等待了

4. **测试进程状态转换**：
   ```
   子进程: RUNNABLE → (yield) → RUNNABLE → ... → (exit) → ZOMBIE
   父进程: RUNNABLE → (waitpid) → SLEEPING → (被唤醒) → RUNNABLE
   ```

**如果没有 `yield()` 会怎样？**

程序仍然能正确运行，但执行顺序可能不同：
- 子进程可能立即执行 `exit()`，变成 ZOMBIE
- 父进程之后执行 `waitpid()`，立即回收子进程
- 或者父进程先执行 `waitpid()`，进入 SLEEPING 等待子进程

**这个程序测试了**：
- `fork()` - 创建子进程
- `yield()` - 主动让出 CPU
- `exit()` - 进程退出
- `wait()` / `waitpid()` - 等待子进程退出

##### 用户库函数封装：`ulib.c`

用户程序不能直接调用内核函数，必须通过**系统调用**。`user/libs/ulib.c` 提供了对系统调用的封装：

```c
// user/libs/ulib.c
#include <defs.h>
#include <syscall.h>
#include <stdio.h>
#include <ulib.h>

void exit(int error_code) {
    sys_exit(error_code);
    // 执行完 sys_exit 后，进程就结束了，不应该执行到这里
    // 如果执行到这里说明 exit 失败了
    cprintf("BUG: exit failed.\n"); 
    while (1);  // 死循环，防止继续执行
}

int fork(void) { 
    return sys_fork(); 
}

int wait(void) { 
    return sys_wait(0, NULL);  // 等待任意子进程
}

int waitpid(int pid, int *store) { 
    return sys_wait(pid, store);  // 等待指定子进程
}

void yield(void) { 
    sys_yield();  // 主动让出 CPU
}

int kill(int pid) { 
    return sys_kill(pid); 
}

int getpid(void) { 
    return sys_getpid(); 
}
```

**封装层次**：
```
用户程序调用          用户库函数           系统调用封装          内核处理
fork()        -->    fork()        -->   sys_fork()    -->   do_fork()
exit(code)    -->    exit(code)    -->   sys_exit()    -->   do_exit()
wait()        -->    wait()        -->   sys_wait()    -->   do_wait()
yield()       -->    yield()       -->   sys_yield()   -->   do_yield()
```

##### 系统调用的底层实现：`syscall.c`

```c
// user/libs/syscall.c
#include <defs.h>
#include <unistd.h>
#include <stdarg.h>
#include <syscall.h>

#define MAX_ARGS 5

// 通用系统调用函数
static inline int syscall(int64_t num, ...) {
    va_list ap;
    va_start(ap, num);
    uint64_t a[MAX_ARGS];
    int i, ret;
    
    // 获取可变参数
    for (i = 0; i < MAX_ARGS; i++) {
        a[i] = va_arg(ap, uint64_t);
    }
    va_end(ap);

    // 使用 ecall 指令触发系统调用
    asm volatile (
        "ld a0, %1\n"      // a0 = num (系统调用号)
        "ld a1, %2\n"      // a1 = 第1个参数
        "ld a2, %3\n"      // a2 = 第2个参数
        "ld a3, %4\n"      // a3 = 第3个参数
        "ld a4, %5\n"      // a4 = 第4个参数
        "ld a5, %6\n"      // a5 = 第5个参数
        "ecall\n"          // 触发系统调用（从 U-mode 进入 S-mode）
        "sd a0, %0"        // 保存返回值
        : "=m" (ret)
        : "m"(num), "m"(a[0]), "m"(a[1]), "m"(a[2]), "m"(a[3]), "m"(a[4])
        : "memory"
    );
    return ret;
}

// 各个系统调用的封装
int sys_exit(int64_t error_code) {
    return syscall(SYS_exit, error_code);
}

int sys_fork(void) {
    return syscall(SYS_fork);
}

int sys_wait(int64_t pid, int *store) {
    return syscall(SYS_wait, pid, store);
}

int sys_yield(void) {
    return syscall(SYS_yield);
}

int sys_kill(int64_t pid) {
    return syscall(SYS_kill, pid);
}

int sys_getpid(void) {
    return syscall(SYS_getpid);
}

int sys_putc(int64_t c) {
    return syscall(SYS_putc, c);  // 打印单个字符
}
```

##### 用户态 `ecall` vs 内核态 `ebreak`

| 方面 | 用户态系统调用 | 内核态 kernel_execve |
|------|----------------|---------------------|
| 指令 | `ecall` | `ebreak` |
| 异常类型 | `CAUSE_USER_ECALL` | `CAUSE_BREAKPOINT` |
| 调用者 | 用户程序（U-mode） | 内核线程（S-mode） |
| 系统调用号位置 | `a0` 寄存器 | `a0` 寄存器 |
| 识别标记 | 无需额外标记 | `a7 = 10` |

##### 用户态 `cprintf` 的实现

用户程序中的 `cprintf` 不能直接调用 SBI 接口（那是 M-mode 的），必须通过系统调用：

```c
// user/libs/stdio.c
#include <defs.h>
#include <stdio.h>
#include <syscall.h>

// 打印单个字符，通过系统调用
static void cputch(int c, int *cnt) {
    sys_putc(c);  // 系统调用：SYS_putc
    (*cnt)++;
}

// 格式化输出
int vcprintf(const char *fmt, va_list ap) {
    int cnt = 0;
    vprintfmt((void*)cputch, &cnt, fmt, ap);
    // 复用内核的 vprintfmt，但传入用户态的 cputch
    return cnt;
}

int cprintf(const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    int cnt = vcprintf(fmt, ap);
    va_end(ap);
    return cnt;
}
```

**打印字符的调用链**：
```
用户程序: cprintf("hello")
    |
    v
user/libs/stdio.c: vcprintf() -> vprintfmt() -> cputch()
    |
    v
user/libs/syscall.c: sys_putc(c)
    |
    v
ecall 指令（U-mode -> S-mode）
    |
    v
kern/trap/trap.c: exception_handler() -> syscall()
    |
    v
kern/syscall/syscall.c: sys_putc() -> cputchar(c)
    |
    v
kern/driver/console.c: cons_putc()
    |
    v
SBI 接口（S-mode -> M-mode）: sbi_console_putchar()
```

##### 完整的系统调用流程图

```
+------------------+     ecall      +------------------+
|   用户程序        | ------------> |   内核           |
|   (U-mode)       |               |   (S-mode)       |
+------------------+               +------------------+
|                  |               |                  |
| fork()           |               | trap()           |
|   |              |               |   |              |
|   v              |               |   v              |
| sys_fork()       |               | exception_handler|
|   |              |               |   |              |
|   v              |               |   v              |
| syscall(SYS_fork)|               | syscall()        |
|   |              |               |   |              |
|   v              |               |   v              |
| ecall ==========>|===============|=> sys_fork()     |
|                  |               |   |              |
|                  |               |   v              |
|                  |               | do_fork()        |
|                  |     sret      |   |              |
| 返回值 <=========|===============|<= 返回 pid       |
+------------------+               +------------------+
```

##### 用户程序与内核的隔离

| 层面 | 用户程序 | 内核 |
|------|----------|------|
| 特权级 | U-mode | S-mode |
| 地址空间 | 用户地址空间（低地址） | 内核地址空间（高地址） |
| 内存访问 | 只能访问用户空间 | 可以访问所有空间 |
| 系统服务 | 必须通过系统调用 | 直接调用内核函数 |
| SBI 接口 | 不能直接调用 | 可以调用 |

---

#### 用户进程的双栈机制与中断处理

##### 为什么用户进程需要两个栈？

| 栈类型 | 位置 | 用途 |
|--------|------|------|
| **用户栈** | 用户地址空间（USTACKTOP 附近） | 用户程序运行时使用 |
| **内核栈** | 内核地址空间（proc->kstack） | 处理系统调用/中断/异常时使用 |

**原因**：
1. **安全隔离**：用户不能直接操作内核数据，内核栈在内核地址空间
2. **权限分离**：用户态无法访问内核栈，防止恶意程序破坏内核
3. **稳定性**：即使用户栈溢出，内核栈仍然可用，能正常处理异常

##### `sscratch` 寄存器的巧妙运用

RISC-V 的 `sscratch` 寄存器在用户态和内核态切换时起关键作用：

| 状态 | `sscratch` 的值 | `sp` 的值 |
|------|-----------------|-----------|
| 在用户态运行 | 内核栈顶地址 | 用户栈指针 |
| 在内核态运行 | 0 | 内核栈指针 |

**设计思路**：
- 用户态时，`sscratch` 保存内核栈地址，方便中断时快速切换
- 内核态时，`sscratch` 为 0，用于区分中断来源

##### `trapentry.S` 的 `SAVE_ALL` 宏详解

```asm
.macro SAVE_ALL
    # 1. 交换 sp 和 sscratch
    csrrw sp, sscratch, sp
    
    # 交换后的情况：
    # - 如果之前是用户态：sp = 内核栈顶，sscratch = 用户栈指针
    # - 如果之前是内核态：sp = 0，sscratch = 内核栈指针（原来的sp）
    
    # 2. 判断之前是用户态还是内核态
    bnez sp, _save_context  # sp != 0，说明之前是用户态，直接保存上下文
    
_restore_kernel_sp:
    # sp == 0，说明之前是内核态
    # 需要从 sscratch 取回内核栈指针
    csrr sp, sscratch

_save_context:
    # 3. 在内核栈上分配 trapframe 空间
    addi sp, sp, -36 * REGBYTES
    
    # 4. 保存所有通用寄存器 x0-x31
    STORE x0, 0*REGBYTES(sp)
    STORE x1, 1*REGBYTES(sp)
    # ... 保存 x3-x31 ...
    
    # 5. 处理用户栈指针
    # 把 sscratch 的值（用户栈指针或0）取出到 s0
    # 同时把 sscratch 清零（标记现在是内核态）
    csrrw s0, sscratch, x0
    
    # 6. 保存 CSR 寄存器
    csrr s1, sstatus
    csrr s2, sepc
    csrr s3, stval
    csrr s4, scause
    
    # 7. 保存到 trapframe
    STORE s0, 2*REGBYTES(sp)   # 保存用户栈指针（x2/sp 的位置）
    STORE s1, 32*REGBYTES(sp)  # sstatus
    STORE s2, 33*REGBYTES(sp)  # sepc
    STORE s3, 34*REGBYTES(sp)  # stval
    STORE s4, 35*REGBYTES(sp)  # scause
.endm
```

##### 用户态中断时的栈指针变化图解

```
【中断发生前 - 用户态运行】
┌─────────────────┐
│   用户栈        │
│   (用户空间)     │
├─────────────────┤ ← sp (用户栈指针)
│                 │
└─────────────────┘

sscratch = 内核栈顶地址

┌─────────────────┐ ← sscratch (内核栈顶)
│   内核栈        │
│   (内核空间)     │
│   (空的)        │
└─────────────────┘

===============================================

【执行 csrrw sp, sscratch, sp 后】

┌─────────────────┐
│   用户栈        │
├─────────────────┤ 
│                 │
└─────────────────┘

sscratch = 用户栈指针 (原来的 sp)

┌─────────────────┐ ← sp (现在指向内核栈顶)
│   内核栈        │
│   (内核空间)     │
│   (空的)        │
└─────────────────┘

===============================================

【分配 trapframe 空间后】
addi sp, sp, -36 * REGBYTES

┌─────────────────┐ ← 内核栈顶
│   trapframe     │
│   (36*8 字节)   │
├─────────────────┤ ← sp (新位置)
│   内核栈        │
│   (未使用部分)   │
└─────────────────┘

===============================================

【保存完上下文后】

┌─────────────────┐ ← 内核栈顶
│   trapframe:    │
│   - x0-x31      │
│   - 用户sp存在  │ ← tf->gpr.sp = 用户栈指针
│     x2的位置    │
│   - sstatus     │
│   - sepc        │
│   - stval       │
│   - scause      │
├─────────────────┤ ← sp
│   (未使用)      │
└─────────────────┘

sscratch = 0 (标记现在是内核态)
```

##### `RESTORE_ALL` 宏详解

```asm
.macro RESTORE_ALL
    # 1. 加载 sstatus 和 sepc
    LOAD s1, 32*REGBYTES(sp)  # sstatus
    LOAD s2, 33*REGBYTES(sp)  # sepc

    # 2. 判断要返回用户态还是内核态
    # 通过 sstatus.SPP 位判断
    andi s0, s1, SSTATUS_SPP
    bnez s0, _restore_context  # SPP=1，返回内核态，跳过保存内核栈

_save_kernel_sp:
    # SPP=0，要返回用户态
    # 需要把内核栈指针保存到 sscratch，供下次中断使用
    addi s0, sp, 36 * REGBYTES  # s0 = 内核栈顶
    csrw sscratch, s0           # 保存到 sscratch

_restore_context:
    # 3. 恢复 CSR 寄存器
    csrw sstatus, s1
    csrw sepc, s2

    # 4. 恢复通用寄存器 x1, x3-x31
    LOAD x1, 1*REGBYTES(sp)
    LOAD x3, 3*REGBYTES(sp)
    # ... 恢复 x4-x31 ...
    
    # 5. 最后恢复 sp (x2)
    # 如果返回用户态，这里恢复的是用户栈指针
    # 如果返回内核态，这里恢复的是之前的内核栈指针
    LOAD x2, 2*REGBYTES(sp)
.endm
```

##### 返回用户态时的栈指针变化

```
【RESTORE_ALL 执行前 - 准备返回用户态】

┌─────────────────┐ ← 内核栈顶
│   trapframe:    │
│   - gpr.sp =    │ ← 保存着用户栈指针
│     用户栈地址   │
│   - sstatus     │ ← SPP=0 (表示要返回用户态)
│   - sepc        │
├─────────────────┤ ← sp
│                 │
└─────────────────┘

sscratch = 0

===============================================

【执行 _save_kernel_sp 后】
addi s0, sp, 36 * REGBYTES
csrw sscratch, s0

sscratch = 内核栈顶 (为下次中断准备)

===============================================

【执行 LOAD x2, 2*REGBYTES(sp) 后】

sp = 用户栈指针 (从 trapframe 恢复)

===============================================

【sret 执行后 - 返回用户态】

┌─────────────────┐
│   用户栈        │
├─────────────────┤ ← sp (用户栈指针，已恢复)
│                 │
└─────────────────┘

sscratch = 内核栈顶 (为下次中断准备好了)
```

##### 内核态中断时的处理

当中断发生在内核态时：

```asm
csrrw sp, sscratch, sp  # 交换 sp 和 sscratch
# 此时：sp = 0（因为内核态时 sscratch=0）
#       sscratch = 原内核栈指针

bnez sp, _save_context  # sp=0，不跳转

_restore_kernel_sp:
csrr sp, sscratch       # 从 sscratch 取回内核栈指针
```

**内核态中断的特点**：
- 不需要切换栈，继续使用当前内核栈
- `sscratch` 保持为 0
- 在当前内核栈上分配新的 trapframe（支持嵌套中断）

##### `forkrets` 函数的作用

```asm
.globl forkrets
forkrets:
    move sp, a0       # sp = 新进程的 trapframe 地址
    j __trapret       # 跳转到恢复上下文并返回
```

**用途**：新创建的进程第一次被调度运行时的入口点。

在 `copy_thread` 中设置：
```c
proc->context.ra = (uintptr_t)forkret;  // forkret 会调用 forkrets
proc->context.sp = (uintptr_t)(proc->tf);
```

当调度器切换到新进程时：
1. `switch_to` 恢复上下文，跳转到 `forkret`
2. `forkret` 调用 `forkrets(current->tf)`
3. `forkrets` 设置 `sp` 为 trapframe 地址
4. 跳转到 `__trapret` 恢复寄存器并 `sret`

##### 双栈机制总结

```
┌─────────────────────────────────────────────────────────────┐
│                     用户进程的双栈                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  用户地址空间                    内核地址空间                 │
│  ┌─────────────┐               ┌─────────────┐             │
│  │  用户栈     │               │  内核栈     │             │
│  │             │   中断/异常    │             │             │
│  │  ─────────  │ ──────────→  │  trapframe  │             │
│  │  用户程序   │               │  ─────────  │             │
│  │  运行时使用  │   sret 返回   │  中断处理   │             │
│  │             │ ←──────────  │  时使用     │             │
│  └─────────────┘               └─────────────┘             │
│        ↑                              ↑                     │
│        │                              │                     │
│    用户态 sp                     内核态 sp                   │
│    (运行时)                      (中断时)                    │
│                                                             │
│  sscratch 的作用：                                          │
│  - 用户态运行时：保存内核栈顶地址                             │
│  - 内核态运行时：值为 0（标识当前在内核态）                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

##### 关键设计要点

1. **`csrrw` 指令的原子性**：`csrrw sp, sscratch, sp` 原子地交换两个寄存器，保证中断安全

2. **`sscratch=0` 的约定**：内核态时 `sscratch=0`，这样可以区分中断来源，也能正确处理嵌套中断

3. **用户栈指针的保存**：用户栈指针保存在 `trapframe->gpr.sp`（x2 的位置），返回用户态时恢复

4. **内核栈顶的维护**：返回用户态前，把内核栈顶保存到 `sscratch`，为下次中断做准备

---

#### 进程退出机制

##### 为什么进程退出需要两步完成？

进程退出时需要释放其占用的所有资源，但有一个矛盾：

| 问题 | 说明 |
|------|------|
| **内核栈** | 进程执行退出代码时还在使用内核栈，不能自己释放 |
| **进程控制块** | 进程存在的标志，不能自己删除自己的 PCB |

**解决方案**：分两步完成退出

```
┌─────────────────────────────────────────────────────────────┐
│                    进程退出的两步机制                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  第一步：进程自己完成（do_exit）                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  1. 释放用户内存空间（mm_struct）                     │   │
│  │  2. 释放页表                                         │   │
│  │  3. 设置状态为 PROC_ZOMBIE                           │   │
│  │  4. 唤醒父进程                                       │   │
│  │  5. 将子进程托孤给 initproc                          │   │
│  │  6. 调用 schedule() 让出 CPU                         │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  第二步：父进程完成（do_wait）                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  1. 释放子进程的内核栈                                │   │
│  │  2. 释放子进程的进程控制块（PCB）                     │   │
│  │  3. 从进程链表中删除子进程                            │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

##### 用户态 `exit` 函数

```c
// /user/libs/ulib.c
void exit(int error_code) {
    sys_exit(error_code);        // 系统调用，进入内核
    cprintf("BUG: exit failed.\n");  // 正常情况下不会执行到这里
    while (1);                   // 防止意外返回
}
```

**说明**：
- `exit` 函数调用 `sys_exit` 系统调用
- 正常情况下 `sys_exit` 不会返回（进程已退出）
- 后面的代码是防御性编程，防止异常情况

##### 系统调用入口

```c
// /kern/syscall/syscall.c
static int sys_exit(uint64_t arg[]) {
    int error_code = (int)arg[0];
    return do_exit(error_code);
}
```

##### `do_exit` 函数详解

```c
// /kern/process/proc.c
int do_exit(int error_code) {
    //==========================================================
    // 第一部分：安全检查
    //==========================================================
    
    // idleproc 和 initproc 不能退出
    if (current == idleproc) {
        panic("idleproc exit.\n");
    }
    if (current == initproc) {
        panic("initproc exit.\n");
    }

    //==========================================================
    // 第二部分：释放用户内存空间
    //==========================================================
    
    struct mm_struct *mm = current->mm;
    
    if (mm != NULL) {  // 用户进程才有 mm
        // 切换到内核页表（因为要释放用户页表）
        lcr3(boot_cr3);
        
        // mm 引用计数减 1，如果变为 0 则释放
        if (mm_count_dec(mm) == 0) {
            exit_mmap(mm);    // 释放所有 VMA 和对应的物理页
            put_pgdir(mm);    // 释放页目录
            mm_destroy(mm);   // 释放 mm_struct 本身
        }
        current->mm = NULL;   // 标记已释放
    }
    // 注意：内核线程的 mm 为 NULL，跳过这部分

    //==========================================================
    // 第三部分：设置进程状态
    //==========================================================
    
    current->state = PROC_ZOMBIE;     // 设置为僵尸状态
    current->exit_code = error_code;  // 保存退出码

    //==========================================================
    // 第四部分：通知父进程并托孤子进程（关中断保护）
    //==========================================================
    
    bool intr_flag;
    struct proc_struct *proc;
    
    local_intr_save(intr_flag);  // 关中断
    {
        // 4.1 唤醒父进程
        proc = current->parent;
        if (proc->wait_state == WT_CHILD) {
            wakeup_proc(proc);  // 父进程在等待，唤醒它
        }
        
        // 4.2 将所有子进程托孤给 initproc
        while (current->cptr != NULL) {
            proc = current->cptr;
            current->cptr = proc->optr;
            
            // 将子进程加入 initproc 的子进程链表
            proc->yptr = NULL;
            if ((proc->optr = initproc->cptr) != NULL) {
                initproc->cptr->yptr = proc;
            }
            proc->parent = initproc;
            initproc->cptr = proc;
            
            // 如果子进程也是僵尸，通知 initproc
            if (proc->state == PROC_ZOMBIE) {
                if (initproc->wait_state == WT_CHILD) {
                    wakeup_proc(initproc);
                }
            }
        }
    }
    local_intr_restore(intr_flag);  // 开中断

    //==========================================================
    // 第五部分：让出 CPU
    //==========================================================
    
    schedule();  // 调度其他进程运行
    
    // 永远不会执行到这里
    panic("do_exit will not return!! %d.\n", current->pid);
}
```

##### 进程退出流程图

```
用户程序调用 exit(code)
        │
        ▼
sys_exit(code) 系统调用
        │
        ▼
┌───────────────────────────────────────────────────┐
│              do_exit(error_code)                  │
├───────────────────────────────────────────────────┤
│                                                   │
│  1. 安全检查                                       │
│     ├── idleproc 不能退出 → panic                 │
│     └── initproc 不能退出 → panic                 │
│                                                   │
│  2. 释放用户内存（如果是用户进程）                  │
│     ├── lcr3(boot_cr3)  切换到内核页表            │
│     ├── exit_mmap(mm)   释放虚拟内存区域          │
│     ├── put_pgdir(mm)   释放页目录                │
│     └── mm_destroy(mm)  释放 mm 结构体            │
│                                                   │
│  3. 设置进程状态                                   │
│     ├── state = PROC_ZOMBIE                       │
│     └── exit_code = error_code                    │
│                                                   │
│  4. 处理父子关系（关中断保护）                      │
│     │                                             │
│     ├── 唤醒父进程（如果父进程在 wait）            │
│     │                                             │
│     └── 托孤所有子进程给 initproc                  │
│         ├── 修改子进程的 parent 指针              │
│         ├── 加入 initproc 的子进程链表            │
│         └── 如果子进程是僵尸，唤醒 initproc        │
│                                                   │
│  5. schedule() 调度其他进程                        │
│     └── 当前进程不再运行                          │
│                                                   │
└───────────────────────────────────────────────────┘
        │
        │ (不会返回)
        ▼
父进程被唤醒，在 do_wait 中回收剩余资源
```

##### 进程状态转换

```
                    fork()
                      │
                      ▼
    ┌─────────────────────────────────┐
    │         PROC_UNINIT             │
    │        (刚创建，未初始化)         │
    └─────────────────────────────────┘
                      │
                      │ wakeup_proc()
                      ▼
    ┌─────────────────────────────────┐
    │         PROC_RUNNABLE           │◄────────┐
    │          (可运行状态)            │         │
    └─────────────────────────────────┘         │
           │                   │                │
           │ schedule()        │ wait/sleep     │ wakeup
           ▼                   ▼                │
    ┌──────────────┐  ┌────────────────────┐   │
    │   运行中      │  │  PROC_SLEEPING     │───┘
    │  (占用CPU)    │  │   (等待状态)        │
    └──────────────┘  └────────────────────┘
           │
           │ do_exit()
           ▼
    ┌─────────────────────────────────┐
    │         PROC_ZOMBIE             │
    │          (僵尸状态)              │
    │  等待父进程回收剩余资源           │
    └─────────────────────────────────┘
           │
           │ 父进程 do_wait() 回收
           ▼
    ┌─────────────────────────────────┐
    │           进程消亡               │
    │    (内核栈和PCB被释放)           │
    └─────────────────────────────────┘
```

##### 为什么要托孤给 `initproc`？

当一个进程退出时，它可能还有子进程。这些子进程需要有父进程来：
1. 回收它们的僵尸资源
2. 接收它们的退出状态

**托孤机制**：将退出进程的所有子进程的父进程改为 `initproc`

```
【进程A退出前】                    【进程A退出后】
                                  
initproc                          initproc
    │                                 │
    └── A (将要退出)                  │ (A 已成为僵尸)
        ├── B                         ├── B ←─┐
        └── C                         └── C ←─┼── 托孤给 initproc
                                              │
                                    A (ZOMBIE) ── 等待 initproc 回收
```

**`initproc` 的特殊职责**：
- 作为所有孤儿进程的养父
- 负责回收所有孤儿进程的僵尸资源
- 这就是为什么 `initproc` 不能退出

##### 关中断的必要性

```c
local_intr_save(intr_flag);
{
    // 操作进程链表...
}
local_intr_restore(intr_flag);
```

**原因**：
- 进程链表是全局数据结构
- 中断处理程序可能也会访问进程链表
- 关中断保证操作的原子性，防止竞态条件

##### 内存释放的详细过程

```
┌─────────────────────────────────────────────────────────────┐
│                 用户内存空间的释放过程                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. lcr3(boot_cr3) - 切换到内核页表                         │
│     └── 因为接下来要释放用户页表，不能还在使用它              │
│                                                             │
│  2. exit_mmap(mm) - 释放所有虚拟内存区域                     │
│     ├── 遍历所有 VMA                                        │
│     ├── 取消页表映射（unmap）                                │
│     └── 释放对应的物理页                                     │
│                                                             │
│  3. put_pgdir(mm) - 释放页目录                              │
│     └── 释放页目录占用的物理页                               │
│                                                             │
│  4. mm_destroy(mm) - 释放 mm_struct                         │
│     └── 释放 mm 结构体本身                                   │
│                                                             │
│  【不释放的资源】                                            │
│  ├── 内核栈 (kstack) - 还在使用中                           │
│  └── 进程控制块 (proc_struct) - 进程存在的标志               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

##### 三个内存释放函数详解

###### 1. `exit_mmap(mm)` - 释放所有虚拟内存区域的映射和物理页

```c
// /kern/mm/vmm.c
void exit_mmap(struct mm_struct *mm)
{
    assert(mm != NULL && mm_count(mm) == 0);
    pde_t *pgdir = mm->pgdir;
    list_entry_t *list = &(mm->mmap_list), *le = list;
    
    // 第一次遍历：取消所有 VMA 的页表映射，释放物理页
    while ((le = list_next(le)) != list) {
        struct vma_struct *vma = le2vma(le, list_link);
        unmap_range(pgdir, vma->vm_start, vma->vm_end);
    }
    
    // 第二次遍历：释放页表本身占用的页面
    while ((le = list_next(le)) != list) {
        struct vma_struct *vma = le2vma(le, list_link);
        exit_range(pgdir, vma->vm_start, vma->vm_end);
    }
}
```

**`unmap_range` 函数**：取消页表映射，释放数据页

```c
// /kern/mm/pmm.c
void unmap_range(pde_t *pgdir, uintptr_t start, uintptr_t end)
{
    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
    assert(USER_ACCESS(start, end));
    
    do {
        // 获取页表项
        pte_t *ptep = get_pte(pgdir, start, 0);
        if (ptep == NULL) {
            // 该区域没有页表，跳到下一个页表范围
            start = ROUNDDOWN(start + PTSIZE, PTSIZE);
            continue;
        }
        if (*ptep != 0) {
            // 页表项有效，删除映射并释放物理页
            page_remove_pte(pgdir, start, ptep);
        }
        start += PGSIZE;
    } while (start != 0 && start < end);
}
```

**`exit_range` 函数**：释放页表本身（三级页表结构）

```c
// /kern/mm/pmm.c
void exit_range(pde_t *pgdir, uintptr_t start, uintptr_t end)
{
    // 遍历 Sv39 三级页表
    // 当页表中所有条目都无效时，释放该页表占用的物理页
    
    do {
        pde1 = pgdir[PDX1(d1start)];  // 一级页目录项
        if (pde1 & PTE_V) {
            pd0 = page2kva(pde2page(pde1));  // 二级页目录
            
            do {
                pde0 = pd0[PDX0(d0start)];  // 二级页目录项
                if (pde0 & PTE_V) {
                    pt = page2kva(pde2page(pde0));  // 页表
                    
                    // 检查页表是否所有条目都无效
                    free_pt = 1;
                    for (int i = 0; i < NPTEENTRY; i++)
                        if (pt[i] & PTE_V) {
                            free_pt = 0;
                            break;
                        }
                    
                    // 如果全部无效，释放页表
                    if (free_pt) {
                        free_page(pde2page(pde0));
                        pd0[PDX0(d0start)] = 0;
                    }
                }
                d0start += PTSIZE;
            } while (...);
            
            // 如果二级页目录所有条目都无效，释放二级页目录
            if (free_pd0) {
                free_page(pde2page(pde1));
                pgdir[PDX1(d1start)] = 0;
            }
        }
        d1start += PDSIZE;
    } while (...);
}
```

**`exit_mmap` 的工作流程**：

```
┌─────────────────────────────────────────────────────────────┐
│                    exit_mmap(mm) 工作流程                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  mm_struct                                                  │
│  └── mmap_list (VMA 链表)                                   │
│      ├── VMA1: [0x1000, 0x3000)  代码段                     │
│      ├── VMA2: [0x4000, 0x6000)  数据段                     │
│      └── VMA3: [0x7fff0000, 0x80000000)  用户栈             │
│                                                             │
│  第一步：unmap_range - 释放每个 VMA 对应的物理页             │
│  ════════════════════════════════════════════                │
│                                                             │
│  对于每个 VMA:                                               │
│  ┌─────────────────────────────────────┐                    │
│  │  遍历 [vm_start, vm_end) 的每一页   │                    │
│  │  ├── 获取页表项 (get_pte)           │                    │
│  │  ├── 调用 page_remove_pte():        │                    │
│  │  │   ├── 减少物理页引用计数          │                    │
│  │  │   ├── 如果引用为0，释放物理页     │                    │
│  │  │   └── 清空页表项                  │                    │
│  │  └── 刷新 TLB (tlb_invalidate)      │                    │
│  └─────────────────────────────────────┘                    │
│                                                             │
│  第二步：exit_range - 释放页表本身                           │
│  ════════════════════════════════════════                    │
│                                                             │
│  Sv39 三级页表结构：                                         │
│  ┌───────────┐                                              │
│  │  一级页目录 │ (pgdir - 顶级，不在此释放)                  │
│  └─────┬─────┘                                              │
│        ↓                                                    │
│  ┌───────────┐                                              │
│  │ 二级页目录  │ ← 如果所有条目无效，释放此页                 │
│  └─────┬─────┘                                              │
│        ↓                                                    │
│  ┌───────────┐                                              │
│  │   页表     │ ← 如果所有条目无效，释放此页                 │
│  └───────────┘                                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

###### 2. `put_pgdir(mm)` - 释放页目录（顶级页表）

```c
// /kern/process/proc.c
static void put_pgdir(struct mm_struct *mm)
{
    free_page(kva2page(mm->pgdir));  // 释放页目录占用的物理页
}
```

**说明**：
- `mm->pgdir` 是页目录的内核虚拟地址
- `kva2page()` 将内核虚拟地址转换为 `struct Page*`
- `free_page()` 释放该物理页

**为什么单独释放**：
- `exit_range` 只释放二级页目录和页表
- 顶级页目录（一级页目录）需要单独释放

```
┌─────────────────────────────────────────────────────────────┐
│                    put_pgdir(mm) 释放的内容                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Sv39 页表结构：                                             │
│                                                             │
│  ┌───────────────┐                                          │
│  │   pgdir       │ ← put_pgdir 释放这一页                   │
│  │  (一级页目录)  │                                          │
│  └───────────────┘                                          │
│         │                                                   │
│         ├──→ 二级页目录 (已被 exit_range 释放)              │
│         │         │                                         │
│         │         └──→ 页表 (已被 exit_range 释放)          │
│         │                   │                               │
│         │                   └──→ 物理页 (已被 unmap_range   │
│         │                              释放)                │
│         │                                                   │
│         ├──→ 二级页目录 (已释放)                            │
│         │         ...                                       │
│         │                                                   │
│         └──→ ...                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

###### 3. `mm_destroy(mm)` - 释放 mm_struct 和所有 VMA 结构体

```c
// /kern/mm/vmm.c
void mm_destroy(struct mm_struct *mm)
{
    // 前置条件：mm 的引用计数必须为 0
    assert(mm_count(mm) == 0);
    
    // 遍历并释放所有 VMA 结构体
    list_entry_t *list = &(mm->mmap_list), *le;
    while ((le = list_next(list)) != list) {
        list_del(le);                    // 从链表中删除
        kfree(le2vma(le, list_link));    // 释放 vma_struct
    }
    
    // 释放 mm_struct 本身
    kfree(mm);
    mm = NULL;
}
```

**说明**：
- 此时物理页和页表都已释放（由前两步完成）
- 这里释放的是管理数据结构本身

```
┌─────────────────────────────────────────────────────────────┐
│                    mm_destroy(mm) 释放的内容                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  【释放前】                                                  │
│                                                             │
│  mm_struct (kmalloc 分配)                                   │
│  ├── mmap_list ──→ VMA1 ──→ VMA2 ──→ VMA3 ──→ ...         │
│  │                 ↑        ↑        ↑                      │
│  │              kmalloc  kmalloc  kmalloc                   │
│  ├── pgdir (已被 put_pgdir 释放)                            │
│  ├── map_count                                              │
│  └── mm_count = 0                                           │
│                                                             │
│  【释放后】                                                  │
│                                                             │
│  所有 VMA 和 mm_struct 都被 kfree 释放                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

##### 三个函数的调用顺序和分工

```
┌─────────────────────────────────────────────────────────────┐
│           内存释放的三步流程（必须按顺序执行）                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  【调用顺序】                                                │
│  1. exit_mmap(mm)  →  2. put_pgdir(mm)  →  3. mm_destroy(mm)│
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  【步骤 1: exit_mmap】                                       │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  释放内容：                                          │   │
│  │  ├── 用户数据页（代码、数据、堆、栈等）              │   │
│  │  ├── 二级页目录                                      │   │
│  │  └── 页表                                            │   │
│  │                                                      │   │
│  │  不释放：                                            │   │
│  │  ├── 一级页目录（pgdir）                             │   │
│  │  └── VMA 结构体                                      │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  【步骤 2: put_pgdir】                                       │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  释放内容：                                          │   │
│  │  └── 一级页目录（pgdir）占用的物理页                  │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↓                                  │
│  【步骤 3: mm_destroy】                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │  释放内容：                                          │   │
│  │  ├── 所有 vma_struct 结构体                          │   │
│  │  └── mm_struct 结构体                                │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

##### 为什么要分成三个函数？

| 原因 | 说明 |
|------|------|
| **依赖关系** | 必须先释放数据页，才能释放页表；必须先释放页表，才能释放页目录 |
| **顺序要求** | 如果先释放页目录，就无法找到页表和数据页了 |
| **代码复用** | `exit_mmap` 在 `do_execve` 中也被使用（替换进程映像时） |
| **引用计数** | `mm_destroy` 检查引用计数，确保没有其他进程在使用 |

##### `mm_count` 引用计数的作用


```c
if (mm_count_dec(mm) == 0) {
    // 释放 mm 相关资源
}
```

**场景**：当多个进程共享同一个内存空间时（如线程）

```
┌─────────────────────────────────────────┐
│  进程 A 和 进程 B 共享 mm_struct         │
├─────────────────────────────────────────┤
│                                         │
│  mm_struct                              │
│  ├── mm_count = 2                       │
│  ├── VMA 列表                           │
│  └── 页表                               │
│       ↑       ↑                         │
│       │       │                         │
│  进程 A    进程 B                        │
│                                         │
│  当进程 A 退出：                         │
│  - mm_count-- → 变为 1                  │
│  - 不释放 mm（进程 B 还在用）            │
│                                         │
│  当进程 B 退出：                         │
│  - mm_count-- → 变为 0                  │
│  - 释放 mm 相关资源                      │
│                                         │
└─────────────────────────────────────────┘
```

##### `do_exit` 与 `do_wait` 的配合

```
┌─────────────────────────────────────────────────────────────┐
│                  父子进程的退出-回收配合                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  子进程                              父进程                  │
│  ══════                              ══════                  │
│                                                             │
│  执行任务...                         waitpid(child, ...)    │
│      │                                    │                 │
│      ▼                                    ▼                 │
│  exit(code)                          do_wait()              │
│      │                                    │                 │
│      ▼                                    ▼                 │
│  do_exit():                          等待子进程退出          │
│  - 释放用户内存                       state = SLEEPING       │
│  - state = ZOMBIE                         │                 │
│  - 唤醒父进程 ─────────────────────────────┘                │
│  - schedule()                             │                 │
│      │                                    ▼                 │
│      │                               被唤醒，继续 do_wait    │
│      │                                    │                 │
│      │                                    ▼                 │
│      │                               找到 ZOMBIE 子进程     │
│      │                                    │                 │
│      │                                    ▼                 │
│      │                               回收子进程资源：        │
│      │                               - 释放内核栈            │
│      │                               - 释放 PCB             │
│      │◄───────────────────────────── 返回退出码             │
│      │                                                      │
│  子进程彻底消亡                       父进程继续执行          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---
