#### 如何第一次进入到用户进程？

需要在**内核态**触发一个异常，从而借助异常处理机制的返回流程进行上下文的切换。

---

#### Lab4 与 Lab5 中 `init_main` 函数的对比

##### Lab4 中的 `init_main`（内核线程示例）

```c
// kern/process/proc.c (lab4)
static int init_main(void *arg) {
    cprintf("this initproc, pid = %d, name = \"%s\"\n", current->pid, get_proc_name(current));
    cprintf("To U: \"%s\".\n", (const char *)arg);
    cprintf("To U: \"en.., Bye, Bye. :)\"\n");
    return 0;
}
```

**特点**：
- 这是一个纯粹的**内核线程**
- 只是简单地打印一些信息后就返回
- 没有创建用户进程的功能
- 用于演示内核线程的创建和运行机制

##### Lab5 中的 `init_main`（用户进程管理）


**特点**：
- 充当**所有用户进程的祖先进程**（类似 Linux 的 init 进程）
- 调用 `kernel_thread(user_main, NULL, 0)` 创建 `user_main` 内核线程
- 使用 `do_wait(0, NULL)` 循环等待回收所有子进程
- 进行内存泄漏检查（通过断言验证进程关系和数量）

##### `init_main` 代码详细解读

```c
static int init_main(void *arg)
{
    // 1. 记录当前内存状态（用于后续内存泄漏检查）
    size_t nr_free_pages_store = nr_free_pages();      // 记录空闲页面数
    size_t kernel_allocated_store = kallocated();       // 记录内核已分配内存

    // 2. 创建 user_main 内核线程（将来会变成用户进程）
    int pid = kernel_thread(user_main, NULL, 0);
    if (pid <= 0) {
        panic("create user_main failed.\n");
    }

    // 3. 循环等待并回收所有子进程
    // do_wait(0, NULL): pid=0 表示等待任意子进程，NULL 表示不需要获取退出码
    while (do_wait(0, NULL) == 0) {
        schedule();  // 让出 CPU，等待子进程运行和退出
    }
    // 当 do_wait 返回非 0（-E_BAD_PROC）时，说明没有子进程了

    cprintf("all user-mode processes have quit.\n");
    
    // 4. 内存泄漏检查：验证所有子进程都已回收
    assert(initproc->cptr == NULL && initproc->yptr == NULL && initproc->optr == NULL);
    // cptr/yptr/optr 都为 NULL 说明没有子进程、兄弟进程了
    
    assert(nr_process == 2);  // 只剩 idleproc(pid=0) 和 initproc(pid=1)
    assert(list_next(&proc_list) == &(initproc->list_link));
    assert(list_prev(&proc_list) == &(initproc->list_link));
    // 进程链表中只有 initproc 一个进程（idleproc 不在链表中）

    cprintf("init check memory pass.\n");
    return 0;
}
```

**`init_main` 的三大职责**：
1. **创建用户进程**：调用 `kernel_thread(user_main, ...)` 创建执行用户程序的线程
2. **回收子进程**：循环调用 `do_wait` 回收所有僵尸子进程的资源
3. **完整性检查**：验证所有子进程都已退出，内存都已回收

---

#### `user_main` 函数详细分析

```c
// user_main - kernel thread used to exec a user program
static int
user_main(void *arg)
{
#ifdef TEST
    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);
#else
    KERNEL_EXECVE(exit);
#endif
    panic("user_main execve failed.\n");
}
```

##### 执行流程

```
user_main() 被创建为内核线程
      |
      v
调用 KERNEL_EXECVE(exit)
      |
      v
KERNEL_EXECVE 宏展开，调用 kernel_execve("exit", binary, size)
      |
      v
kernel_execve 通过 ebreak 触发断点异常
      |
      v
异常处理程序调用 do_execve() -> load_icode()
      |
      v
load_icode 加载 ELF 程序，设置用户态 trapframe
      |
      v
异常返回时通过 sret 进入用户态执行 exit 程序
      |
      v
【注意】如果成功，代码流程永远不会返回到 user_main
        因为进程已经变成了用户进程，执行用户代码去了
      |
      v
panic() 只有在 kernel_execve 失败时才会执行
```

**为什么 `user_main` 是内核线程却能执行用户程序？**

`user_main` 一开始确实是内核线程（运行在内核态），但通过 `kernel_execve` → `do_execve` → `load_icode` 这条调用链：
1. 创建新的用户地址空间（mm_struct）
2. 加载用户程序的 ELF 文件到内存
3. 设置 trapframe 使得异常返回时进入用户态
4. 当 `sret` 指令执行后，进程就从内核态"变身"为用户态进程了

---

#### `kernel_execve` 函数详细分析

##### 为什么需要 `kernel_execve`？

**问题**：`user_main` 是内核线程，运行在内核态。如何让它"变成"用户进程？

**解决方案**：利用**异常返回机制**。在内核态触发一个异常，然后在异常处理中加载用户程序并设置好 trapframe，当异常返回（`sret`）时就会进入用户态。

##### 代码逐行解析

```c
static int
kernel_execve(const char *name, unsigned char *binary, size_t size)
{
    int64_t ret = 0, len = strlen(name);
    
    // 使用内联汇编触发断点异常
    asm volatile(
        "li a0, %1\n"      // a0 = SYS_exec (系统调用号，值为 4)
        "lw a1, %2\n"      // a1 = name (程序名字符串地址)
        "lw a2, %3\n"      // a2 = len (程序名长度)
        "lw a3, %4\n"      // a3 = binary (程序二进制数据地址)
        "lw a4, %5\n"      // a4 = size (程序大小)
        "li a7, 10\n"      // a7 = 10 (特殊标记，表示这是内核态的 execve 调用)
        "ebreak\n"         // 触发断点异常（CAUSE_BREAKPOINT）
        "sw a0, %0\n"      // 异常返回后，保存返回值到 ret
        : "=m"(ret)
        : "i"(SYS_exec), "m"(name), "m"(len), "m"(binary), "m"(size)
        : "memory");
    cprintf("ret = %d\n", ret);
    return ret;
}
```

##### 为什么用 `ebreak` 而不是 `ecall`？

- **`ecall`**：用户态程序调用系统调用时使用，会产生 `CAUSE_USER_ECALL` 异常
- **`ebreak`**：产生断点异常 `CAUSE_BREAKPOINT`，可以在任何特权级使用

因为 `user_main` 运行在**内核态（S-mode）**，如果使用 `ecall` 会产生 `CAUSE_SUPERVISOR_ECALL`，处理方式不同。使用 `ebreak` + `a7=10` 的组合可以明确标识这是"内核态发起的 exec 系统调用"。

##### 异常处理程序中的处理（trap.c）

```c
case CAUSE_BREAKPOINT:
    cprintf("Breakpoint\n");
    if (tf->gpr.a7 == 10)  // 检查是否是 kernel_execve 发起的
    {
        tf->epc += 4;      // 跳过 ebreak 指令（4字节）
        syscall();         // 调用 syscall()，它会根据 a0 调用 do_execve
        kernel_execve_ret(tf, current->kstack + KSTACKSIZE);
        // kernel_execve_ret 设置新的内核栈，准备返回用户态
    }
    break;
```

##### 完整调用链

```
kernel_execve()
    |
    +-- ebreak 指令触发断点异常
    |
    v
trap() -> exception_handler()
    |
    +-- case CAUSE_BREAKPOINT:
    |       if (tf->gpr.a7 == 10)
    |
    v
syscall()
    |
    +-- case SYS_exec:
    |       do_execve(name, len, binary, size)
    |
    v
do_execve()
    |
    +-- 释放旧的内存空间（如果有）
    +-- load_icode(binary, size)
    |
    v
load_icode()
    |
    +-- (1) 创建新的 mm_struct
    +-- (2) 创建新的页目录表
    +-- (3) 解析 ELF，加载代码段、数据段、BSS段
    +-- (4) 创建用户栈
    +-- (5) 设置 current->mm 和 current->pgdir
    +-- (6) 设置 trapframe:
    |         tf->gpr.sp = USTACKTOP (用户栈顶)
    |         tf->epc = elf->e_entry (程序入口点)
    |         tf->status = 用户态状态（清除 SPP 位）
    |
    v
kernel_execve_ret(tf, kstacktop)
    |
    +-- 切换到正确的内核栈
    |
    v
sret 指令执行
    |
    +-- 根据 trapframe 恢复寄存器
    +-- 根据 tf->status（SPP=0）返回到用户态
    +-- 根据 tf->epc 跳转到程序入口执行
    |
    v
用户程序开始在用户态运行！
```

---

#### `syscall()` 函数详解

##### 系统调用号定义（unistd.h）

```c
/* syscall number */
#define SYS_exit            1
#define SYS_fork            2
#define SYS_wait            3
#define SYS_exec            4   // kernel_execve 使用这个
#define SYS_clone           5
#define SYS_yield           10
#define SYS_sleep           11
#define SYS_kill            12
#define SYS_gettime         17
#define SYS_getpid          18
#define SYS_putc            30
#define SYS_pgdir           31
```

##### 系统调用处理函数表

```c
// 各个系统调用的处理函数
static int sys_exit(uint64_t arg[])  { return do_exit((int)arg[0]); }
static int sys_fork(uint64_t arg[])  { return do_fork(0, tf->gpr.sp, tf); }
static int sys_wait(uint64_t arg[])  { return do_wait((int)arg[0], (int *)arg[1]); }
static int sys_exec(uint64_t arg[])  { 
    return do_execve((const char *)arg[0], (size_t)arg[1], 
                     (unsigned char *)arg[2], (size_t)arg[3]); 
}
static int sys_yield(uint64_t arg[]) { return do_yield(); }
static int sys_kill(uint64_t arg[])  { return do_kill((int)arg[0]); }
static int sys_getpid(uint64_t arg[]){ return current->pid; }
static int sys_putc(uint64_t arg[])  { cputchar((int)arg[0]); return 0; }

// 系统调用函数指针数组（用系统调用号作为下标）
static int (*syscalls[])(uint64_t arg[]) = {
    [SYS_exit]    sys_exit,
    [SYS_fork]    sys_fork,
    [SYS_wait]    sys_wait,
    [SYS_exec]    sys_exec,    // syscalls[4] = sys_exec
    [SYS_yield]   sys_yield,
    [SYS_kill]    sys_kill,
    [SYS_getpid]  sys_getpid,
    [SYS_putc]    sys_putc,
    [SYS_pgdir]   sys_pgdir,
};
```

##### `syscall()` 函数源码详解

```c
void syscall(void) 
{
    // 1. 获取当前进程的 trapframe
    struct trapframe *tf = current->tf;
    uint64_t arg[5];
    
    // 2. 从 a0 寄存器获取系统调用号
    // 在 kernel_execve 中: li a0, SYS_exec (即 a0 = 4)
    int num = tf->gpr.a0;
    
    // 3. 检查系统调用号是否有效
    if (num >= 0 && num < NUM_SYSCALLS) {
        if (syscalls[num] != NULL) {
            // 4. 从寄存器 a1-a5 获取系统调用参数
            // kernel_execve 中设置了:
            //   a1 = name (程序名)
            //   a2 = len (名字长度)
            //   a3 = binary (程序二进制地址)
            //   a4 = size (程序大小)
            arg[0] = tf->gpr.a1;
            arg[1] = tf->gpr.a2;
            arg[2] = tf->gpr.a3;
            arg[3] = tf->gpr.a4;
            arg[4] = tf->gpr.a5;
            
            // 5. 调用对应的系统调用处理函数
            // syscalls[4] = sys_exec
            // sys_exec 会调用 do_execve(name, len, binary, size)
            tf->gpr.a0 = syscalls[num](arg);
            // 返回值存入 a0，供调用者使用
            return;
        }
    }
    
    // 6. 未定义的系统调用，panic
    print_trapframe(tf);
    panic("undefined syscall %d, pid = %d, name = %s.\n",
            num, current->pid, current->name);
}
```

##### `kernel_execve` 与 `syscall` 的参数传递

```c
// kernel_execve 中的内联汇编
asm volatile(
    "li a0, %1\n"      // a0 = SYS_exec = 4 (系统调用号)
    "lw a1, %2\n"      // a1 = name
    "lw a2, %3\n"      // a2 = len
    "lw a3, %4\n"      // a3 = binary
    "lw a4, %5\n"      // a4 = size
    "li a7, 10\n"      // a7 = 10 (标记这是 kernel_execve)
    "ebreak\n"         // 触发断点异常
    ...
);
```

**参数传递流程**：
```
kernel_execve 设置寄存器:
    a0 = 4 (SYS_exec)
    a1 = name
    a2 = len  
    a3 = binary
    a4 = size
    a7 = 10
        |
        v (ebreak 触发异常，寄存器保存到 trapframe)
        
trapframe 中:
    tf->gpr.a0 = 4
    tf->gpr.a1 = name
    tf->gpr.a2 = len
    tf->gpr.a3 = binary
    tf->gpr.a4 = size
    tf->gpr.a7 = 10
        |
        v (syscall 从 trapframe 读取)
        
syscall() 中:
    num = tf->gpr.a0 = 4
    arg[0] = tf->gpr.a1 = name
    arg[1] = tf->gpr.a2 = len
    arg[2] = tf->gpr.a3 = binary
    arg[3] = tf->gpr.a4 = size
        |
        v (调用 syscalls[4] = sys_exec)
        
sys_exec(arg):
    do_execve(arg[0], arg[1], arg[2], arg[3])
    即 do_execve(name, len, binary, size)
```

##### 用户态系统调用 vs 内核态系统调用

| 方面 | 用户态系统调用 | 内核态系统调用 (kernel_execve) |
|------|----------------|-------------------------------|
| 触发方式 | `ecall` 指令 | `ebreak` 指令 |
| 异常类型 | `CAUSE_USER_ECALL` | `CAUSE_BREAKPOINT` |
| 识别标记 | 无需特殊标记 | `a7 = 10` |
| 调用位置 | 用户程序 | 内核线程 (`user_main`) |
| 目的 | 用户程序请求内核服务 | 内核线程加载用户程序 |

##### 系统调用完整流程图

```
【用户态系统调用】                 【内核态 kernel_execve】
用户程序调用 syscall()             kernel_execve() 
    |                                   |
    v                                   v
设置 a0=调用号, a1-a5=参数        设置 a0=SYS_exec, a1-a4=参数, a7=10
    |                                   |
    v                                   v
ecall 指令                         ebreak 指令
    |                                   |
    v                                   v
CAUSE_USER_ECALL                   CAUSE_BREAKPOINT
    |                                   |
    v                                   v
exception_handler                  exception_handler
    |                                   |
    v                                   v
tf->epc += 4                       if (a7 == 10): tf->epc += 4
    |                                   |
    v                                   v
syscall()                          syscall()
    |                                   |
    v                                   v
根据 a0 调用对应处理函数           syscalls[4] = sys_exec
    |                                   |
    v                                   v
返回用户态继续执行                  do_execve -> load_icode
                                        |
                                        v
                                   kernel_execve_ret
                                        |
                                        v
                                   sret 进入用户态
```

---

#### `do_execve` 函数详解

##### 函数功能

`do_execve` 负责**替换当前进程的地址空间**，用新的用户程序替代原有内容。这是 `exec` 系统调用的核心实现。

##### 源码详解

```c
// do_execve - call exit_mmap(mm)&put_pgdir(mm) to reclaim memory space of current process
//           - call load_icode to setup new memory space accroding binary prog.
int do_execve(const char *name, size_t len, unsigned char *binary, size_t size)
{
    struct mm_struct *mm = current->mm;
    
    // 1. 验证程序名指针的有效性
    // 检查 name 指向的内存是否在用户空间且可读
    if (!user_mem_check(mm, (uintptr_t)name, len, 0))
    {
        return -E_INVAL;
    }
    
    // 2. 限制程序名长度
    if (len > PROC_NAME_LEN)
    {
        len = PROC_NAME_LEN;
    }

    // 3. 将程序名复制到内核空间的局部变量
    // 因为稍后会释放用户空间，name 指针会失效
    char local_name[PROC_NAME_LEN + 1];
    memset(local_name, 0, sizeof(local_name));
    memcpy(local_name, name, len);

    // 4. 释放当前进程的用户空间（如果有）
    if (mm != NULL)
    {
        cputs("mm != NULL");
        
        // 4.1 切换到内核页目录表
        // 因为要释放当前进程的页目录表，必须先切换出去
        lsatp(boot_pgdir_pa);
        
        // 4.2 减少 mm 的引用计数
        // 如果计数变为 0，说明没有其他进程共享这个 mm，可以释放
        if (mm_count_dec(mm) == 0)
        {
            exit_mmap(mm);   // 释放所有 VMA 对应的物理页
            put_pgdir(mm);   // 释放页目录表
            mm_destroy(mm);  // 释放 mm_struct 结构体
        }
        current->mm = NULL;
    }
    
    // 5. 加载新的用户程序
    int ret;
    if ((ret = load_icode(binary, size)) != 0)
    {
        goto execve_exit;  // 加载失败，退出进程
    }
    
    // 6. 设置进程名
    set_proc_name(current, local_name);
    return 0;

execve_exit:
    // 加载失败，终止进程
    do_exit(ret);
    panic("already exit: %e.\n", ret);  // 不应该执行到这里
}
```

##### 执行流程图

```
do_execve(name, len, binary, size)
    |
    v
验证 name 指针有效性
    |
    v
复制 name 到 local_name（内核空间）
    |
    v
current->mm != NULL?  ----No----> 跳到 load_icode
    |
   Yes
    |
    v
lsatp(boot_pgdir_pa)  // 切换到内核页目录
    |
    v
mm_count_dec(mm) == 0?  ----No----> 只是解除关联
    |
   Yes（没有其他进程共享）
    |
    v
exit_mmap(mm)    // 释放物理页
put_pgdir(mm)    // 释放页目录表
mm_destroy(mm)   // 释放 mm_struct
    |
    v
current->mm = NULL
    |
    v
load_icode(binary, size)  // 加载新程序
    |
    +--失败--> do_exit(ret) 退出进程
    |
   成功
    |
    v
set_proc_name(current, local_name)
    |
    v
return 0
```

##### 关键操作说明

**为什么要先切换到内核页目录表？**

```c
lsatp(boot_pgdir_pa);
```

因为接下来要释放当前进程的页目录表（`put_pgdir`），如果 CPU 还在使用这个页目录表，释放后会导致崩溃。所以必须先切换到一个安全的页目录表（内核页目录表）。

**为什么要复制 name 到局部变量？**

```c
char local_name[PROC_NAME_LEN + 1];
memcpy(local_name, name, len);
```

`name` 指针指向用户空间，当调用 `exit_mmap` 释放用户空间后，`name` 指向的内存就失效了。所以必须在释放前将其复制到内核栈上。

**mm_count 引用计数的作用**

```c
if (mm_count_dec(mm) == 0)
{
    // 释放 mm 相关资源
}
```

多个进程可能共享同一个 `mm_struct`（通过 `CLONE_VM` 标志创建的线程）。只有当引用计数降为 0 时，才能真正释放这些资源。

##### `do_execve` 与 `load_icode` 的分工

| 函数 | 职责 |
|------|------|
| `do_execve` | 释放旧的地址空间，调用 `load_icode`，设置进程名 |
| `load_icode` | 创建新的 mm_struct、页目录表，解析 ELF，加载代码/数据，创建用户栈，设置 trapframe |

##### 对于 `kernel_execve` 调用的特殊情况

当 `kernel_execve` → `syscall` → `do_execve` 时：

```c
if (mm != NULL)  // 对于 user_main 内核线程，mm 是 NULL
{
    // 这段代码不会执行
}
```

因为 `user_main` 是**内核线程**，它的 `mm` 字段为 `NULL`（内核线程没有独立的用户地址空间）。所以 `do_execve` 会直接调用 `load_icode` 创建全新的用户地址空间。

---

#### `kernel_execve_ret` 函数详解

##### 为什么需要 `kernel_execve_ret`？

在 `kernel_execve` 触发断点异常时，异常处理使用的是**当时的内核栈**。但经过 `load_icode` 后：
- 进程的地址空间已经**完全改变**了（新的页目录表、新的用户空间）
- 原来的内核栈位置可能已经不正确了
- `trapframe` 的位置需要调整到新进程的内核栈顶

**`kernel_execve_ret` 的作用**：将 `trapframe` 复制到正确的内核栈位置，然后从那里返回用户态。

##### 调用位置（trap.c）

```c
case CAUSE_BREAKPOINT:
    cprintf("Breakpoint\n");
    if (tf->gpr.a7 == 10)  // 是 kernel_execve 发起的
    {
        tf->epc += 4;      // 跳过 ebreak 指令
        syscall();         // 调用 do_execve -> load_icode
        kernel_execve_ret(tf, current->kstack + KSTACKSIZE);
        // 参数：tf = 当前 trapframe
        //       current->kstack + KSTACKSIZE = 内核栈顶
    }
    break;
```

##### 汇编源码详解（trapentry.S）

```asm
    .global kernel_execve_ret
kernel_execve_ret:
    // 参数：a0 = tf (原 trapframe 地址)
    //       a1 = kstacktop (内核栈顶地址)
    
    // 1. 计算新 trapframe 的位置
    // trapframe 结构体大小 = 36 * REGBYTES (36个寄存器，每个8字节)
    addi a1, a1, -36*REGBYTES
    // 现在 a1 指向新 trapframe 的起始位置（内核栈顶 - trapframe大小）

    // 2. 将原 trapframe 的内容复制到新位置
    // 从 a0 (原tf) 复制到 a1 (新tf)
    // 使用 s1 作为临时寄存器，逐个字段复制
    LOAD s1, 35*REGBYTES(a0)    // 加载原 tf 的第35个字段
    STORE s1, 35*REGBYTES(a1)   // 存储到新 tf 的第35个字段
    LOAD s1, 34*REGBYTES(a0)
    STORE s1, 34*REGBYTES(a1)
    // ... 复制所有 36 个字段 (0-35) ...
    LOAD s1, 1*REGBYTES(a0)
    STORE s1, 1*REGBYTES(a1)
    LOAD s1, 0*REGBYTES(a0)
    STORE s1, 0*REGBYTES(a1)

    // 3. 将 sp 设置为新 trapframe 的地址
    move sp, a1
    
    // 4. 跳转到 __trapret，从新的 trapframe 返回
    j __trapret
```

##### `__trapret` 的作用

```asm
__trapret:
    RESTORE_ALL    // 从 trapframe 恢复所有寄存器
    sret           // 返回到用户态（根据 sstatus.SPP 和 sepc）
```

##### 内存布局变化图解

**调用 `kernel_execve_ret` 之前**：
```
原内核栈（可能已经不在正确位置）:
+------------------+ <- 某个位置
|   原 trapframe   |
|   (36 * 8 字节)  |
+------------------+ <- tf (a0)
|      ...         |
+------------------+

当前进程的新内核栈（load_icode 后）:
+------------------+ <- current->kstack + KSTACKSIZE (栈顶)
|    (空的)        |
+------------------+ <- current->kstack (栈底)
```

**调用 `kernel_execve_ret` 之后**：
```
当前进程的新内核栈:
+------------------+ <- current->kstack + KSTACKSIZE (栈顶)
|   新 trapframe   |  <-- 从原 tf 复制过来
|   (36 * 8 字节)  |
+------------------+ <- sp = a1 (新 trapframe 起始地址)
|    (未使用)      |
+------------------+ <- current->kstack (栈底)
```

##### 为什么要复制 trapframe？

1. **原 trapframe 位置不对**：`kernel_execve` 是从 `user_main` 内核线程调用的，使用的是 `user_main` 被创建时分配的栈空间。但 `load_icode` 可能改变了进程的内核栈。


2. **确保 sret 能正确返回**：`sret` 指令执行后会根据 trapframe 中的 `epc`、`status`、`sp` 等恢复状态。trapframe 必须在正确的内核栈位置，才能保证后续的中断/异常处理正确。

3. **新进程的内核栈顶**：`current->kstack + KSTACKSIZE` 是内核栈的最高地址，trapframe 应该放在栈顶位置（栈是向下增长的）。

##### 完整流程总结

```
kernel_execve() 触发 ebreak
    |
    v
trap() 保存 trapframe 到当前栈
    |
    v
exception_handler() -> syscall() -> do_execve() -> load_icode()
    |                                              |
    |                                    设置了新的 mm、pgdir
    |                                    修改了 tf->epc、tf->sp、tf->status
    v
kernel_execve_ret(tf, current->kstack + KSTACKSIZE)
    |
    +-- 计算新栈位置: a1 = kstacktop - 36*REGBYTES
    |
    +-- 复制 trapframe: 从 tf(a0) 复制到新位置(a1)
    |
    +-- 设置 sp = a1
    |
    +-- j __trapret
            |
            v
        RESTORE_ALL (恢复所有寄存器)
            |
            v
        sret (返回用户态)
            |
            v
        用户程序从 tf->epc (程序入口) 开始执行
        使用 tf->gpr.sp (USTACKTOP) 作为用户栈
```


#### 进程创建流程总结

```
proc_init()
    |
    +--> idleproc (pid=0, 第一个内核线程，空闲进程)
    |
    +--> kernel_thread(init_main, ...) 创建 initproc (pid=1)
              |
              +--> init_main()
                        |
                        +--> kernel_thread(user_main, ...) 创建 user_main 线程 (pid=2)
                        |           |
                        |           +--> user_main()
                        |                    |
                        |                    +--> KERNEL_EXECVE(exit)
                        |                            |
                        |                            +--> kernel_execve()
                        |                                    |
                        |                                    +--> ebreak 触发异常
                        |                                            |
                        |                                            +--> do_execve()
                        |                                                    |
                        |                                                    +--> load_icode() 加载用户程序
                        |                                                            |
                        |                                                            +--> 设置 trapframe
                        |                                                                    |
                        |                                                                    +--> sret 返回用户态
                        |
                        +--> do_wait() 循环等待子进程退出
                        |
                        +--> 所有子进程退出后，进行内存检查
```

---

#### Lab4 到 Lab5 的核心变化

| 方面 | Lab4 | Lab5 |
|------|------|------|
| `init_main` 功能 | 简单打印信息 | 创建用户进程，等待回收 |
| 进程类型 | 仅内核线程 | 支持用户进程 |
| 新增函数 | 无 | `user_main`, `kernel_execve`, `do_execve`, `load_icode` |
| 系统调用 | 无 | `SYS_exec`, `SYS_exit`, `SYS_wait` 等 |
| 进程关系 | 简单链表 | 父子兄弟关系（`cptr`, `optr`, `yptr`） |

---

#### `do_wait` 的作用

```c
while (do_wait(0, NULL) == 0)
{
    schedule();
}
```

- `do_wait(0, NULL)` 等待任意子进程（pid=0 表示任意子进程）退出
- 当子进程变为 `PROC_ZOMBIE` 状态时，`do_wait` 回收其资源
- 循环直到没有子进程可回收（返回 `-E_BAD_PROC`）
- 类似于 Linux 中 init 进程回收孤儿进程的机制

##### `do_wait` 源码详解

```c
// do_wait - wait one OR any children with PROC_ZOMBIE state, and free memory space of kernel stack
//         - proc struct of this child.
// NOTE: only after do_wait function, all resources of the child proces are free.
int do_wait(int pid, int *code_store)
{
    struct mm_struct *mm = current->mm;
    
    // 1. 验证 code_store 指针的有效性（如果不为NULL）
    if (code_store != NULL)
    {
        // 检查用户空间地址是否可写
        if (!user_mem_check(mm, (uintptr_t)code_store, sizeof(int), 1))
        {
            return -E_INVAL;
        }
    }

    struct proc_struct *proc;
    bool intr_flag, haskid;
    
repeat:  // 循环标签，用于重复等待
    haskid = 0;  // 标记是否有子进程
    
    // 2. 根据 pid 参数决定等待哪个子进程
    if (pid != 0)
    {
        // pid != 0: 等待指定 pid 的子进程
        proc = find_proc(pid);
        if (proc != NULL && proc->parent == current)
        {
            haskid = 1;  // 找到了指定的子进程
            if (proc->state == PROC_ZOMBIE)
            {
                goto found;  // 子进程已退出，跳转到回收代码
            }
        }
    }
    else
    {
        // pid == 0: 等待任意子进程
        // 遍历当前进程的所有子进程（通过 cptr 和 optr 链表）
        proc = current->cptr;  // cptr 指向第一个子进程
        for (; proc != NULL; proc = proc->optr)  // optr 指向下一个兄弟进程
        {
            haskid = 1;  // 有子进程存在
            if (proc->state == PROC_ZOMBIE)
            {
                goto found;  // 找到一个已退出的子进程
            }
        }
    }
    
    // 3. 如果有子进程但都没退出，则睡眠等待
    if (haskid)
    {
        current->state = PROC_SLEEPING;      // 当前进程进入睡眠状态
        current->wait_state = WT_CHILD;      // 设置等待原因为"等待子进程"
        schedule();                           // 调度其他进程运行
        
        // 被唤醒后检查是否需要退出
        if (current->flags & PF_EXITING)
        {
            do_exit(-E_KILLED);  // 如果被标记为退出，则退出
        }
        goto repeat;  // 重新检查子进程状态
    }
    
    // 4. 没有子进程，返回错误
    return -E_BAD_PROC;

found:
    // 5. 找到了 ZOMBIE 状态的子进程，回收其资源
    
    // 安全检查：不能回收 idleproc 或 initproc
    if (proc == idleproc || proc == initproc)
    {
        panic("wait idleproc or initproc.\n");
    }
    
    // 如果调用者需要获取子进程的退出码
    if (code_store != NULL)
    {
        *code_store = proc->exit_code;
    }
    
    // 关中断，保证原子操作
    local_intr_save(intr_flag);
    {
        unhash_proc(proc);    // 从 hash 表中移除
        remove_links(proc);   // 从进程链表和父子关系中移除
    }
    local_intr_restore(intr_flag);
    
    // 释放子进程的内核栈
    put_kstack(proc);
    // 释放 proc_struct 结构体
    kfree(proc);
    
    return 0;  // 成功回收
}
```

##### `do_wait` 流程图

```
do_wait(pid, code_store)
    |
    v
验证 code_store 地址有效性
    |
    v
+---> [repeat] 开始/重新查找
|         |
|         v
|    pid != 0 ?
|    /        \
|   Yes        No
|   |          |
|   v          v
| find_proc(pid)   遍历 current->cptr 链表
|   |          |
|   v          v
| 是当前进程的子进程?   找到任意子进程?
|   |          |
|   v          v
| proc->state == ZOMBIE?  proc->state == ZOMBIE?
|   |          |
|   +----+-----+
|        |
|        v
|   有子进程但未退出 (haskid=1, 未找到ZOMBIE)
|        |
|        v
|   current->state = SLEEPING
|   current->wait_state = WT_CHILD
|   schedule() 让出CPU
|        |
|        v
|   被唤醒后（子进程调用 do_exit 时会唤醒父进程）
|        |
|        v
|   检查 PF_EXITING 标志
|        |
+--------+ goto repeat
         
找到 ZOMBIE 子进程 (goto found)
    |
    v
获取退出码（如果需要）
    |
    v
关中断 -> unhash_proc -> remove_links -> 开中断
    |
    v
put_kstack() 释放内核栈
    |
    v
kfree(proc) 释放进程控制块
    |
    v
return 0 成功
```

##### 进程关系指针说明

| 指针 | 含义 | 用途 |
|------|------|------|
| `cptr` | child pointer | 指向**第一个子进程** |
| `optr` | older sibling pointer | 指向**兄进程**（较早创建的兄弟） |
| `yptr` | younger sibling pointer | 指向**弟进程**（较晚创建的兄弟） |
| `parent` | parent pointer | 指向**父进程** |

**遍历所有子进程的方式**：
```c
// 从 cptr 开始，沿着 optr 遍历
for (proc = current->cptr; proc != NULL; proc = proc->optr) {
    // proc 依次为第一个子进程、第二个子进程...
}
```

##### `do_wait` 与 `do_exit` 的配合

1. **子进程退出时**（`do_exit`）：
   - 设置 `state = PROC_ZOMBIE`
   - 调用 `wakeup_proc(parent)` 唤醒等待的父进程

2. **父进程等待时**（`do_wait`）：
   - 如果没有 ZOMBIE 子进程，进入 `PROC_SLEEPING` 状态
   - 被唤醒后重新检查子进程状态
   - 找到 ZOMBIE 子进程后回收其资源

---


#### `KERNEL_EXECVE` 系列宏详解

##### 宏定义代码

```c
#define __KERNEL_EXECVE(name, binary, size) ({           \
    cprintf("kernel_execve: pid = %d, name = \"%s\".\n", \
            current->pid, name);                         \
    kernel_execve(name, binary, (size_t)(size));         \
})

#define KERNEL_EXECVE(x) ({                                    \
    extern unsigned char _binary_obj___user_##x##_out_start[], \
        _binary_obj___user_##x##_out_size[];                   \
    __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,    \
                    _binary_obj___user_##x##_out_size);        \
})

#define __KERNEL_EXECVE2(x, xstart, xsize) ({   \
    extern unsigned char xstart[], xsize[];     \
    __KERNEL_EXECVE(#x, xstart, (size_t)xsize); \
})

#define KERNEL_EXECVE2(x, xstart, xsize) __KERNEL_EXECVE2(x, xstart, xsize)
```

##### `KERNEL_EXECVE(x)` 宏解析

**作用**：加载并执行名为 `x` 的用户程序

**宏展开过程**（以 `KERNEL_EXECVE(exit)` 为例）：

```c
KERNEL_EXECVE(exit)
// 展开为：
{
    extern unsigned char _binary_obj___user_exit_out_start[];  // 用户程序的起始地址
    extern unsigned char _binary_obj___user_exit_out_size[];   // 用户程序的大小
    __KERNEL_EXECVE("exit", _binary_obj___user_exit_out_start, 
                    _binary_obj___user_exit_out_size);
}
// 最终展开为：
{
    cprintf("kernel_execve: pid = %d, name = \"exit\".\n", current->pid, "exit");
    kernel_execve("exit", _binary_obj___user_exit_out_start, 
                  (size_t)(_binary_obj___user_exit_out_size));
}
```

**关键技巧**：
- `##` 是**token 粘贴运算符**，将 `x` 与其他字符串拼接
- `#x` 是**字符串化运算符**，将 `x` 转换为字符串 `"x"`
- `_binary_obj___user_##x##_out_start` 和 `_binary_obj___user_##x##_out_size` 是**链接器自动生成的符号**

##### 链接器符号的来源

当用户程序（如 `user/exit.c`）编译后，通过 `objcopy` 工具或链接脚本将其嵌入到内核中。链接器会自动创建以下符号：

| 符号名 | 含义 |
|--------|------|
| `_binary_obj___user_exit_out_start` | 用户程序二进制数据的**起始地址** |
| `_binary_obj___user_exit_out_size` | 用户程序二进制数据的**大小**（以指针形式表示） |
| `_binary_obj___user_exit_out_end` | 用户程序二进制数据的**结束地址** |

##### `KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE)` 解析

**用途**：用于测试时指定**自定义的用户程序符号**

**使用场景**：
```c
static int user_main(void *arg)
{
#ifdef TEST
    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);  // 测试模式：运行指定的测试程序
#else
    KERNEL_EXECVE(exit);                        // 默认模式：运行 exit 程序
#endif
    panic("user_main execve failed.\n");
}
```

**宏展开**（假设 `TEST=hello`, `TESTSTART=_binary_obj___user_hello_out_start`, `TESTSIZE=_binary_obj___user_hello_out_size`）：

```c
KERNEL_EXECVE2(hello, _binary_obj___user_hello_out_start, _binary_obj___user_hello_out_size)
// 展开为：
{
    extern unsigned char _binary_obj___user_hello_out_start[];
    extern unsigned char _binary_obj___user_hello_out_size[];
    __KERNEL_EXECVE("hello", _binary_obj___user_hello_out_start, 
                    (size_t)_binary_obj___user_hello_out_size);
}
```

##### 两个宏的区别

| 宏 | 参数 | 用途 |
|----|------|------|
| `KERNEL_EXECVE(x)` | 只需程序名 | 自动拼接符号名，适合固定命名规则的程序 |
| `KERNEL_EXECVE2(x, start, size)` | 程序名 + 起始地址符号 + 大小符号 | 可自定义符号名，适合测试或特殊情况 |

##### 编译时如何定义 TEST

在 `Makefile` 中通过 `-D` 选项传递：

```makefile
# 运行 hello 测试程序
make run TEST=hello
# 编译时会加入：-DTEST=hello -DTESTSTART=_binary_obj___user_hello_out_start -DTESTSIZE=_binary_obj___user_hello_out_size
```

这样 `user_main` 就会执行指定的测试程序而不是默认的 `exit` 程序。

---

#### 用户程序与用户态系统调用

##### 用户程序的存放与加载

用户程序源码存放在 `user/` 目录下，编译时被嵌入到内核镜像中。当 `KERNEL_EXECVE(exit)` 执行时，就是加载 `user/exit.c` 编译后的二进制程序。

##### 用户程序示例：`exit.c`

```c
// user/exit.c
#include <stdio.h>
#include <ulib.h>

int magic = -0x10384;

int main(void) {
    int pid, code;
    cprintf("I am the parent. Forking the child...\n");
    
    // fork() 创建子进程
    if ((pid = fork()) == 0) {
        // 子进程执行这里
        cprintf("I am the child.\n");
        yield();  // 主动让出 CPU
        yield();
        yield();
        yield();
        yield();
        yield();
        yield();
        exit(magic);  // 子进程退出，返回 magic 作为退出码
    }
    else {
        // 父进程执行这里
        cprintf("I am parent, fork a child pid %d\n", pid);
    }
    
    assert(pid > 0);
    cprintf("I am the parent, waiting now..\n");

    // 等待子进程退出，并获取退出码
    assert(waitpid(pid, &code) == 0 && code == magic);
    // 再次等待应该失败（子进程已经被回收）
    assert(waitpid(pid, &code) != 0 && wait() != 0);
    
    cprintf("waitpid %d ok.\n", pid);
    cprintf("exit pass.\n");
    return 0;
}
```

##### `fork()` 的返回值详解

`fork()` 系统调用会**创建一个子进程**，子进程是父进程的副本（复制地址空间）。关键点在于：**`fork()` 调用一次，返回两次**。

| 返回值 | 含义 | 执行位置 |
|--------|------|----------|
| `0` | 当前是**子进程** | 子进程中 |
| `> 0` | 当前是**父进程**，返回值是子进程的 PID | 父进程中 |
| `< 0` | 创建失败 | 父进程中 |

```c
pid = fork();
// 这行代码之后，存在两个进程在并行执行！
// 父进程：pid = 子进程的 PID（比如 3）
// 子进程：pid = 0
```

##### `if` 和 `else` 分支的含义

```c
if ((pid = fork()) == 0) {
    // 【子进程执行这里】
    // 因为子进程中 fork() 返回 0
    cprintf("I am the child.\n");
    // ...
    exit(magic);
}
else {
    // 【父进程执行这里】
    // 因为父进程中 fork() 返回子进程的 PID（> 0）
    cprintf("I am parent, fork a child pid %d\n", pid);
}
```

**执行流程**：
```
fork() 之前：只有父进程（PID=2）

fork() 之后：
┌─────────────────────────────────────────────────────────┐
│                      父进程 (PID=2)                      │
│  pid = fork() 返回 3（子进程的PID）                       │
│  if (pid == 0) --> false                                │
│  else { cprintf("I am parent..."); }  ← 执行这里         │
│  继续执行 assert(pid > 0); ...                           │
│  waitpid(pid, &code) 等待子进程退出                      │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                      子进程 (PID=3)                      │
│  pid = fork() 返回 0                                     │
│  if (pid == 0) --> true  ← 执行这里                      │
│  { cprintf("I am the child."); yield(); exit(magic); }  │
│  子进程调用 exit() 后终止，不会执行 else 和后面的代码       │
└─────────────────────────────────────────────────────────┘
```

##### 为什么要使用 `yield()`？

```c
if ((pid = fork()) == 0) {
    cprintf("I am the child.\n");
    yield();  // 主动让出 CPU
    yield();
    yield();
    yield();
    yield();
    yield();
    yield();
    exit(magic);
}
```

**`yield()` 的作用**：主动让出 CPU，让调度器选择其他进程运行。

**为什么子进程要连续调用 7 次 `yield()`？**

1. **测试调度器**：验证 `yield` 系统调用和进程调度是否正常工作

2. **模拟真实场景**：真实程序中，子进程可能需要做一些工作后再退出。这里用 `yield()` 模拟"做一些事情"

3. **给父进程运行机会**：
   - `fork()` 后，父子进程的执行顺序是不确定的
   - 子进程调用 `yield()` 可以让父进程有机会先执行到 `waitpid()`
   - 这样当子进程 `exit()` 时，父进程已经在等待了

4. **测试进程状态转换**：
   ```
   子进程: RUNNABLE → (yield) → RUNNABLE → ... → (exit) → ZOMBIE
   父进程: RUNNABLE → (waitpid) → SLEEPING → (被唤醒) → RUNNABLE
   ```

**如果没有 `yield()` 会怎样？**

程序仍然能正确运行，但执行顺序可能不同：
- 子进程可能立即执行 `exit()`，变成 ZOMBIE
- 父进程之后执行 `waitpid()`，立即回收子进程
- 或者父进程先执行 `waitpid()`，进入 SLEEPING 等待子进程

**这个程序测试了**：
- `fork()` - 创建子进程
- `yield()` - 主动让出 CPU
- `exit()` - 进程退出
- `wait()` / `waitpid()` - 等待子进程退出

##### 用户库函数封装：`ulib.c`

用户程序不能直接调用内核函数，必须通过**系统调用**。`user/libs/ulib.c` 提供了对系统调用的封装：

```c
// user/libs/ulib.c
#include <defs.h>
#include <syscall.h>
#include <stdio.h>
#include <ulib.h>

void exit(int error_code) {
    sys_exit(error_code);
    // 执行完 sys_exit 后，进程就结束了，不应该执行到这里
    // 如果执行到这里说明 exit 失败了
    cprintf("BUG: exit failed.\n"); 
    while (1);  // 死循环，防止继续执行
}

int fork(void) { 
    return sys_fork(); 
}

int wait(void) { 
    return sys_wait(0, NULL);  // 等待任意子进程
}

int waitpid(int pid, int *store) { 
    return sys_wait(pid, store);  // 等待指定子进程
}

void yield(void) { 
    sys_yield();  // 主动让出 CPU
}

int kill(int pid) { 
    return sys_kill(pid); 
}

int getpid(void) { 
    return sys_getpid(); 
}
```

**封装层次**：
```
用户程序调用          用户库函数           系统调用封装          内核处理
fork()        -->    fork()        -->   sys_fork()    -->   do_fork()
exit(code)    -->    exit(code)    -->   sys_exit()    -->   do_exit()
wait()        -->    wait()        -->   sys_wait()    -->   do_wait()
yield()       -->    yield()       -->   sys_yield()   -->   do_yield()
```

##### 系统调用的底层实现：`syscall.c`

```c
// user/libs/syscall.c
#include <defs.h>
#include <unistd.h>
#include <stdarg.h>
#include <syscall.h>

#define MAX_ARGS 5

// 通用系统调用函数
static inline int syscall(int64_t num, ...) {
    va_list ap;
    va_start(ap, num);
    uint64_t a[MAX_ARGS];
    int i, ret;
    
    // 获取可变参数
    for (i = 0; i < MAX_ARGS; i++) {
        a[i] = va_arg(ap, uint64_t);
    }
    va_end(ap);

    // 使用 ecall 指令触发系统调用
    asm volatile (
        "ld a0, %1\n"      // a0 = num (系统调用号)
        "ld a1, %2\n"      // a1 = 第1个参数
        "ld a2, %3\n"      // a2 = 第2个参数
        "ld a3, %4\n"      // a3 = 第3个参数
        "ld a4, %5\n"      // a4 = 第4个参数
        "ld a5, %6\n"      // a5 = 第5个参数
        "ecall\n"          // 触发系统调用（从 U-mode 进入 S-mode）
        "sd a0, %0"        // 保存返回值
        : "=m" (ret)
        : "m"(num), "m"(a[0]), "m"(a[1]), "m"(a[2]), "m"(a[3]), "m"(a[4])
        : "memory"
    );
    return ret;
}

// 各个系统调用的封装
int sys_exit(int64_t error_code) {
    return syscall(SYS_exit, error_code);
}

int sys_fork(void) {
    return syscall(SYS_fork);
}

int sys_wait(int64_t pid, int *store) {
    return syscall(SYS_wait, pid, store);
}

int sys_yield(void) {
    return syscall(SYS_yield);
}

int sys_kill(int64_t pid) {
    return syscall(SYS_kill, pid);
}

int sys_getpid(void) {
    return syscall(SYS_getpid);
}

int sys_putc(int64_t c) {
    return syscall(SYS_putc, c);  // 打印单个字符
}
```

##### 用户态 `ecall` vs 内核态 `ebreak`

| 方面 | 用户态系统调用 | 内核态 kernel_execve |
|------|----------------|---------------------|
| 指令 | `ecall` | `ebreak` |
| 异常类型 | `CAUSE_USER_ECALL` | `CAUSE_BREAKPOINT` |
| 调用者 | 用户程序（U-mode） | 内核线程（S-mode） |
| 系统调用号位置 | `a0` 寄存器 | `a0` 寄存器 |
| 识别标记 | 无需额外标记 | `a7 = 10` |

##### 用户态 `cprintf` 的实现

用户程序中的 `cprintf` 不能直接调用 SBI 接口（那是 M-mode 的），必须通过系统调用：

```c
// user/libs/stdio.c
#include <defs.h>
#include <stdio.h>
#include <syscall.h>

// 打印单个字符，通过系统调用
static void cputch(int c, int *cnt) {
    sys_putc(c);  // 系统调用：SYS_putc
    (*cnt)++;
}

// 格式化输出
int vcprintf(const char *fmt, va_list ap) {
    int cnt = 0;
    vprintfmt((void*)cputch, &cnt, fmt, ap);
    // 复用内核的 vprintfmt，但传入用户态的 cputch
    return cnt;
}

int cprintf(const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    int cnt = vcprintf(fmt, ap);
    va_end(ap);
    return cnt;
}
```

**打印字符的调用链**：
```
用户程序: cprintf("hello")
    |
    v
user/libs/stdio.c: vcprintf() -> vprintfmt() -> cputch()
    |
    v
user/libs/syscall.c: sys_putc(c)
    |
    v
ecall 指令（U-mode -> S-mode）
    |
    v
kern/trap/trap.c: exception_handler() -> syscall()
    |
    v
kern/syscall/syscall.c: sys_putc() -> cputchar(c)
    |
    v
kern/driver/console.c: cons_putc()
    |
    v
SBI 接口（S-mode -> M-mode）: sbi_console_putchar()
```

##### 完整的系统调用流程图

```
+------------------+     ecall      +------------------+
|   用户程序        | ------------> |   内核           |
|   (U-mode)       |               |   (S-mode)       |
+------------------+               +------------------+
|                  |               |                  |
| fork()           |               | trap()           |
|   |              |               |   |              |
|   v              |               |   v              |
| sys_fork()       |               | exception_handler|
|   |              |               |   |              |
|   v              |               |   v              |
| syscall(SYS_fork)|               | syscall()        |
|   |              |               |   |              |
|   v              |               |   v              |
| ecall ==========>|===============|=> sys_fork()     |
|                  |               |   |              |
|                  |               |   v              |
|                  |               | do_fork()        |
|                  |     sret      |   |              |
| 返回值 <=========|===============|<= 返回 pid       |
+------------------+               +------------------+
```

##### 用户程序与内核的隔离

| 层面 | 用户程序 | 内核 |
|------|----------|------|
| 特权级 | U-mode | S-mode |
| 地址空间 | 用户地址空间（低地址） | 内核地址空间（高地址） |
| 内存访问 | 只能访问用户空间 | 可以访问所有空间 |
| 系统服务 | 必须通过系统调用 | 直接调用内核函数 |
| SBI 接口 | 不能直接调用 | 可以调用 |



---


