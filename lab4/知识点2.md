# proc.h

## 进程控制块（PCB）- struct proc_struct

进程控制块（Process Control Block, PCB）是操作系统用来描述和管理进程的核心数据结构，包含了进程运行所需的全部状态信息。

```c
struct proc_struct
{
    enum proc_state state;        // Process state
    int pid;                      // Process ID
    int runs;                     // the running times of Proces
    uintptr_t kstack;             // Process kernel stack
    volatile bool need_resched;   // bool value: need to be rescheduled to release CPU?
    struct proc_struct *parent;   // the parent process
    struct mm_struct *mm;         // Process's memory management field
    struct context context;       // Switch here to run process
    struct trapframe *tf;         // Trap frame for current interrupt
    uintptr_t pgdir;              // the base addr of Page Directroy Table(PDT)
    uint32_t flags;               // Process flag
    char name[PROC_NAME_LEN + 1]; // Process name
    list_entry_t list_link;       // Process link list
    list_entry_t hash_link;       // Process hash list
};
```

### 字段详解

#### 1. 进程标识与状态

**`enum proc_state state`** - 进程状态
```c
enum proc_state
{
    PROC_UNINIT = 0,  // 未初始化
    PROC_SLEEPING,    // 睡眠（等待某个事件）
    PROC_RUNNABLE,    // 就绪/运行（在就绪队列或正在CPU上运行）
    PROC_ZOMBIE,      // 僵尸状态（进程已结束，等待父进程回收资源）
};
```
- **PROC_UNINIT**：进程刚分配，尚未完成初始化
- **PROC_SLEEPING**：阻塞状态，等待 I/O 或其他事件
- **PROC_RUNNABLE**：可运行状态，包括：
  - 在就绪队列中等待调度
  - 正在 CPU 上执行
- **PROC_ZOMBIE**：进程已退出，但父进程还未回收其资源（类似 Unix 僵尸进程）

**`int pid`** - 进程标识符
- 系统中唯一的进程 ID
- 范围：0 ~ MAX_PID（默认 `MAX_PID = MAX_PROCESS * 2 = 8192`）
- `pid = 0` 通常保留给 idle 进程

**`int runs`** - 运行次数
- 记录该进程被调度运行的次数
- 用于统计和调度算法（如时间片轮转）

---

#### 2. 内存管理相关

**`uintptr_t kstack`** - 内核栈地址
- 指向该进程的内核栈基址
- 内核栈用于：
  - 处理系统调用时的栈空间
  - 中断处理时的栈空间
  - 保存进程切换时的上下文
- 每个进程有独立的内核栈（通常 2 页，8KB）

**`uintptr_t pgdir`** - 页目录表基址
- 指向该进程的一级页表（页目录）的**物理地址**
- 进程切换时会将此地址写入 `satp` 寄存器，切换虚拟地址空间
- 内核线程共享内核页表，用户进程有独立页表

**`struct mm_struct *mm`** - 内存管理结构
- 指向进程的虚拟内存管理结构（Virtual Memory Area）
- 包含：
  - 代码段、数据段、堆、栈等虚拟内存区域描述
  - 页表管理信息
- 内核线程的 `mm` 为 NULL（只使用内核地址空间）

**mm_struct 结构详解**（定义在 vmm.h）：
```c
struct mm_struct {
    list_entry_t mmap_list;        // VMA 链表头，按起始地址排序
    struct vma_struct *mmap_cache; // 最近访问的 VMA，加速查找
    pde_t *pgdir;                  // 该进程的页目录表基址
    int map_count;                 // VMA 的数量
    void *sm_priv;                 // 页面置换算法的私有数据
};
```
- `mmap_list`：管理该进程所有虚拟内存区域（VMA）的链表
- `mmap_cache`：缓存最近访问的 VMA，提高查找效率
- `pgdir`：指向该进程的页目录表（与 `proc_struct->pgdir` 一致）
- `map_count`：该进程有多少个 VMA
- `sm_priv`：用于页面置换算法（如 FIFO、LRU）的私有数据

**VMA（虚拟内存区域）**：
```c
struct vma_struct {
    struct mm_struct *vm_mm;  // 所属的 mm_struct
    uintptr_t vm_start;       // VMA 起始地址（包含）
    uintptr_t vm_end;         // VMA 结束地址（不包含）
    uint32_t vm_flags;        // 权限标志（VM_READ/VM_WRITE/VM_EXEC）
    list_entry_t list_link;   // 链表节点
};
```
- 每个 VMA 描述一段连续的虚拟地址范围及其属性
- 例如：代码段（只读可执行）、数据段（可读写）、堆、栈等

---

#### 3. 调度与上下文切换

**`volatile bool need_resched`** - 重新调度标志
- `volatile` 表示该变量可能被中断处理程序修改，防止编译器优化
- `true`：需要让出 CPU，触发进程调度
- `false`：继续运行当前进程
- 时钟中断时可能设置此标志，实现时间片轮转

**`struct context context`** - 进程上下文
```c
struct context
{
    uintptr_t ra;   // return address (返回地址)
    uintptr_t sp;   // stack pointer (栈指针)
    uintptr_t s0;   // saved registers s0-s11 (被调用者保存寄存器)
    uintptr_t s1;
    // ... s2 ~ s11
};
```
- 保存进程切换时需要恢复的寄存器
- **RISC-V 调用约定**：
  - `ra`：函数返回地址
  - `sp`：栈指针
  - `s0-s11`：被调用者保存寄存器（Callee-saved）
- 进程切换流程：
  1. 保存当前进程的 `context`
  2. 恢复目标进程的 `context`
  3. 跳转到目标进程的 `ra` 地址继续执行

**`struct trapframe *tf`** - 中断帧指针
- 指向保存在内核栈上的 `trapframe` 结构
- 包含进程被中断时的**完整 CPU 状态**：
  - 32 个通用寄存器（x0-x31）
  - `pc`（程序计数器）
  - `sstatus`（状态寄存器）
  - `stval`、`scause` 等
- 用途：
  - 从中断/系统调用返回时恢复现场
  - `fork` 时复制父进程状态给子进程
  - 内核可修改 `tf` 来改变进程返回用户态后的行为

---

#### 4. 进程关系与组织

**`struct proc_struct *parent`** - 父进程指针
- 指向创建该进程的父进程
- 用于：
  - 进程树的管理
  - 子进程退出时向父进程发送信号
  - 孤儿进程的处理（父进程退出，子进程重新指定父进程）

**`list_entry_t list_link`** - 进程链表节点
- 用于将进程串联到全局进程链表 `proc_list`
- 遍历所有进程时使用
- 通过 `le2proc(le, list_link)` 宏从链表节点还原 `proc_struct` 指针

**`list_entry_t hash_link`** - 进程哈希表节点
- 用于将进程串联到基于 PID 的哈希表
- 快速通过 PID 查找进程（`find_proc(pid)`）
- 提高查找效率（O(1) vs O(n)）

---

#### 5. 其他标志

**`uint32_t flags`** - 进程标志位
- 用于标记进程的特殊属性，如：
  - 进程类型（内核线程 vs 用户进程）
  - 调试标志
  - 权限标志
- 具体定义根据实现而定

**`char name[PROC_NAME_LEN + 1]`** - 进程名称
- 最多 15 个字符 + '\0' 结束符
- 用于调试和显示（如 `ps` 命令）
- 示例：`"idle"`、`"init"`

---

### 关键宏与全局变量

```c
#define le2proc(le, member) \
    to_struct((le), struct proc_struct, member)
```
- **功能**：从链表节点指针还原 `proc_struct` 指针
- **原理**：通过成员偏移量计算结构体首地址
- **用法**：
  ```c
  list_entry_t *le = proc_list.next;
  struct proc_struct *proc = le2proc(le, list_link);
  ```

**全局进程指针**：
```c
extern struct proc_struct *idleproc;   // idle 进程（PID=0）
extern struct proc_struct *initproc;   // init 进程（PID=1）
extern struct proc_struct *current;    // 当前正在运行的进程
```

**idle 进程（空闲进程）**：
- **PID = 0**，系统中优先级最低的特殊进程
- **作用**：当没有其他就绪进程时运行，占位作用
- **实现**：死循环检查 `need_resched`，有其他进程就绪时立即调度
- **节能**：可执行 `wfi`（Wait For Interrupt）指令让 CPU 进入低功耗状态
- **简化调度**：确保调度器总有进程可运行，`current` 指针永远有效

---

### PCB 的生命周期

1. **创建**：`alloc_proc()` 分配并初始化 PCB
2. **初始化**：设置 PID、内核栈、页表等
3. **就绪**：加入就绪队列，等待调度
4. **运行**：`proc_run()` 切换到该进程
5. **阻塞**：等待事件，状态变为 `PROC_SLEEPING`
6. **退出**：`do_exit()` 释放资源，变为 `PROC_ZOMBIE`
7. **回收**：父进程调用 `wait` 回收僵尸进程的 PCB

---

## 内核栈（Kernel Stack）详解

### 什么是内核栈？

内核栈是每个进程在**内核态运行**时使用的独立栈空间，与用户栈（用户态栈）分离。

### 为什么需要内核栈？

1. **安全隔离**：
   - 用户栈位于用户空间，不可信（可能被恶意修改）
   - 内核栈位于内核空间，只有内核态可访问，保护内核数据安全

2. **特权级切换**：
   - 从用户态进入内核态（系统调用/中断）时，不能继续使用用户栈
   - 必须切换到内核栈，保证内核函数调用的栈空间安全可靠

3. **独立性**：
   - 每个进程有独立的内核栈，避免内核态执行时的相互干扰
   - 支持多个进程在内核态的并发执行

### 内核栈的大小与位置

```c
#define KSTACKPAGE  2                           // 内核栈占用的页数
#define KSTACKSIZE  (KSTACKPAGE * PGSIZE)       // 内核栈大小 = 2 * 4KB = 8KB
```

- **大小**：通常 2 页（8KB），比用户栈小得多
- **位置**：在内核地址空间，通过 `proc_struct->kstack` 记录基址
- **布局**：从高地址向低地址增长（与大多数栈一致）

```
高地址 →  +------------------+  ← kstack + KSTACKSIZE (栈顶初始位置)
          |                  |
          |   内核栈空间     |  ← 向下增长
          |   (8KB)          |
          |                  |
低地址 →  +------------------+  ← kstack (栈基址)
```

### 内核栈的用途

#### 1. 保存中断/异常时的寄存器状态

当发生中断、异常或系统调用时：
1. 硬件自动将 `pc` 保存到 `sepc`
2. 软件将所有寄存器保存到内核栈上，形成 `trapframe`
3. 内核处理中断
4. 从 `trapframe` 恢复寄存器
5. 通过 `sret` 返回用户态

```c
// trapframe 保存在内核栈上
struct trapframe *tf = (struct trapframe *)(kstack + KSTACKSIZE - sizeof(struct trapframe));
```

#### 2. 提供系统调用的栈空间

- 用户程序调用 `read()` 等系统调用时，进入内核态
- 内核函数（如 `sys_read`）在内核栈上执行
- 函数调用链、局部变量都使用内核栈

#### 3. 保存进程切换的上下文

- `proc_struct->context` 保存在内核栈中
- `switch_to` 函数切换进程时，在内核栈上操作 `context`

#### 4. 内核函数调用

- 内核态执行期间的所有函数调用都使用内核栈
- 包括中断处理函数、调度器、内存管理等



### 栈切换流程示例

#### 系统调用时的栈切换：

```
1. 用户程序调用 read()
   用户栈: sp → [用户栈内容]
   
2. 执行 ecall 指令，进入内核态
   硬件切换: sp → 内核栈顶
   
3. 保存寄存器到内核栈（形成 trapframe）
   内核栈: sp → [trapframe] [内核函数栈帧]
   
4. 内核执行 sys_read()
   内核栈: sp → [sys_read 栈帧] [trapframe]
   
5. 返回用户态（sret）
   恢复 trapframe，sp 切换回用户栈
   
6. 用户程序继续执行
   用户栈: sp → [用户栈内容]
```

### 关键点

1. **每个进程独立**：每个进程都有自己的内核栈，避免内核态的数据混乱
2. **自动切换**：特权级切换时，硬件/软件协作自动完成栈切换
3. **大小有限**：内核栈只有 8KB，不能递归过深或分配大数组
4. **内核栈溢出**：如果内核函数调用链过深，可能导致栈溢出，覆盖相邻内存
5. **trapframe 位置**：通常放在内核栈的顶部（高地址），便于访问


# proc.c

## 全局变量

### 进程管理的核心全局变量

```c
// the process set's list
list_entry_t proc_list;
```
- **进程链表**：串联系统中所有进程的双向链表头
- 通过 `proc->list_link` 将进程加入此链表

```c
#define HASH_SHIFT 10
#define HASH_LIST_SIZE (1 << HASH_SHIFT)  // 1024
#define pid_hashfn(x) (hash32(x, HASH_SHIFT))

// has list for process set based on pid
static list_entry_t hash_list[HASH_LIST_SIZE];
```
- **PID 哈希表**：1024 个链表头组成的哈希表
- 用途：通过 PID 快速查找进程（`find_proc(pid)`）
- 哈希函数：`pid_hashfn(pid)` 将 PID 映射到 0~1023
- 通过 `proc->hash_link` 将进程加入对应的哈希桶

```c
// idle proc
struct proc_struct *idleproc = NULL;
```
- **idle 进程指针**：指向 PID=0 的空闲进程
- 系统启动时第一个创建，最低优先级
- 无其他就绪进程时运行，执行 `cpu_idle()` 死循环

```c
// init proc
struct proc_struct *initproc = NULL;
```
- **init 进程指针**：指向 PID=1 的第一个用户级进程
- 由 idle 进程通过 `kernel_thread` 创建
- 负责启动其他用户进程（类似 Linux 的 init）

```c
// current proc
struct proc_struct *current = NULL;
```
- **当前进程指针**：指向正在 CPU 上运行的进程
- 进程切换时更新：`current = next_proc`
- 内核代码通过 `current` 访问当前进程的 PCB

```c
static int nr_process = 0;
```
- **进程计数器**：记录系统中当前的进程总数
- 创建进程时 `nr_process++`，销毁时 `nr_process--`
- 用于限制进程数量（不超过 `MAX_PROCESS`）

---

### 数据结构关系图

```
proc_list (全局链表)
    ↓
[idle] ←→ [init] ←→ [proc1] ←→ [proc2] ←→ ...
  ↓         ↓         ↓         ↓
hash_list[0]: [idle]
hash_list[1]: [init]
hash_list[n]: [proc1] → [proc2]  (哈希冲突，链式解决)
  ...

current → [当前运行的进程]
idleproc → [idle]
initproc → [init]
```

---

## proc_init() 函数 - 进程系统初始化

### 函数功能

`proc_init()` 是操作系统进程管理子系统的**初始化入口**，负责：
1. 初始化进程管理的全局数据结构（链表、哈希表）
2. 创建并初始化第一个内核线程 **idle 进程**（PID=0）
3. 通过 idle 进程创建第二个内核线程 **init 进程**（PID=1）

### 完整代码分析

```c
void proc_init(void)
{
    int i;

    // 1. 初始化全局进程链表
    list_init(&proc_list);
    
    // 2. 初始化 PID 哈希表的 1024 个链表头
    for (i = 0; i < HASH_LIST_SIZE; i++)
    {
        list_init(hash_list + i);
    }

    // 3. 分配并初始化 idle 进程的 PCB
    if ((idleproc = alloc_proc()) == NULL)
    {
        panic("cannot alloc idleproc.\n");
    }

    // 4. 检查 alloc_proc() 的正确性（验证各字段是否正确初始化为 0）
    int *context_mem = (int *)kmalloc(sizeof(struct context));
    memset(context_mem, 0, sizeof(struct context));
    int context_init_flag = memcmp(&(idleproc->context), context_mem, sizeof(struct context));

    int *proc_name_mem = (int *)kmalloc(PROC_NAME_LEN);
    memset(proc_name_mem, 0, PROC_NAME_LEN);
    int proc_name_flag = memcmp(&(idleproc->name), proc_name_mem, PROC_NAME_LEN);

    // 验证 alloc_proc 是否正确初始化了所有字段
    if (idleproc->pgdir == boot_pgdir_pa && 
        idleproc->tf == NULL && 
        !context_init_flag && 
        idleproc->state == PROC_UNINIT && 
        idleproc->pid == -1 && 
        idleproc->runs == 0 && 
        idleproc->kstack == 0 && 
        idleproc->need_resched == 0 && 
        idleproc->parent == NULL && 
        idleproc->mm == NULL && 
        idleproc->flags == 0 && 
        !proc_name_flag)
    {
        cprintf("alloc_proc() correct!\n");
    }

    // 5. 手动完成 idle 进程的初始化
    idleproc->pid = 0;                          // PID 设为 0
    idleproc->state = PROC_RUNNABLE;            // 状态：可运行
    idleproc->kstack = (uintptr_t)bootstack;    // 内核栈：使用启动栈
    idleproc->need_resched = 1;                 // 需要调度（让出 CPU）
    set_proc_name(idleproc, "idle");            // 进程名
    nr_process++;                               // 进程计数 +1

    // 6. 将 idle 设为当前进程
    current = idleproc;

    // 7. 创建 init 内核线程
    int pid = kernel_thread(init_main, "Hello world!!", 0);
    if (pid <= 0)
    {
        panic("create init_main failed.\n");
    }

    // 8. 查找并初始化 init 进程
    initproc = find_proc(pid);
    set_proc_name(initproc, "init");

    // 9. 断言检查
    assert(idleproc != NULL && idleproc->pid == 0);
    assert(initproc != NULL && initproc->pid == 1);
}
```

---

### 执行流程详解

#### **阶段 1：数据结构初始化**

```c
list_init(&proc_list);
for (i = 0; i < HASH_LIST_SIZE; i++)
{
    list_init(hash_list + i);
}
```

- **proc_list**：初始化全局进程链表（双向循环链表）
- **hash_list[1024]**：初始化 PID 哈希表的所有桶
- 此时系统中还没有任何进程

---

#### **阶段 2：创建 idle 进程（PID=0）**

```c
if ((idleproc = alloc_proc()) == NULL)
{
    panic("cannot alloc idleproc.\n");
}
```

- 调用 `alloc_proc()` 分配 `proc_struct` 结构体
- 此时 idle 进程处于 `PROC_UNINIT` 状态，所有字段初始化为默认值
- **idle 进程的特殊性**：
  - 第一个创建的进程，作为进程系统的"根"
  - 不通过 `do_fork()` 创建，而是手动初始化
  - 使用启动时的 `bootstack` 作为内核栈（不单独分配）

---

#### **阶段 3：验证 alloc_proc() 正确性**

```c
if (idleproc->pgdir == boot_pgdir_pa && 
    idleproc->tf == NULL && 
    !context_init_flag && 
    idleproc->state == PROC_UNINIT && 
    idleproc->pid == -1 && 
    ...)
{
    cprintf("alloc_proc() correct!\n");
}
```

- **目的**：测试 Exercise1 中实现的 `alloc_proc()` 是否正确初始化了所有字段
- **检查项**：
  - `pgdir` 应设为 `boot_pgdir_pa`（内核页表）
  - `tf` 应为 `NULL`（尚未中断）
  - `context` 应全为 0（未运行过）
  - `state` 应为 `PROC_UNINIT`
  - `pid` 应为 -1（表示未分配 PID）
  - `kstack`、`runs`、`parent`、`mm`、`flags` 等应为 0 或 NULL
  - `name` 应为空字符串

---

#### **阶段 4：完成 idle 进程初始化**

```c
idleproc->pid = 0;
idleproc->state = PROC_RUNNABLE;
idleproc->kstack = (uintptr_t)bootstack;
idleproc->need_resched = 1;
set_proc_name(idleproc, "idle");
nr_process++;
```

- **pid = 0**：idle 进程的固定 PID
- **state = PROC_RUNNABLE**：设为可运行状态
- **kstack = bootstack**：复用启动时的内核栈（位于 `entry.S` 中分配）
- **need_resched = 1**：立即标记需要调度（让出 CPU 给 init）
- **name = "idle"**：设置进程名
- **nr_process++**：进程计数变为 1

**注意**：idle 进程没有调用 `setup_kstack()` 分配内核栈，因为它直接使用启动栈。

---

#### **阶段 5：设置当前进程**

```c
current = idleproc;
```

- 将 `current` 指向 idle 进程
- 此时 CPU 正在执行 `proc_init()`，从逻辑上看是在 idle 进程的上下文中
- 后续代码都在 idle 进程的"名下"执行

---

#### **阶段 6：创建 init 进程（PID=1）**

```c
int pid = kernel_thread(init_main, "Hello world!!", 0);
if (pid <= 0)
{
    panic("create init_main failed.\n");
}

initproc = find_proc(pid);
set_proc_name(initproc, "init");
```

- **kernel_thread()**：创建一个内核线程
  - 参数 1：`init_main` - 内核线程的入口函数
  - 参数 2：`"Hello world!!"` - 传递给 `init_main` 的参数
  - 参数 3：`0` - clone_flags（不共享地址空间）
  - 返回值：新进程的 PID（应为 1）


- **find_proc(pid)**：从哈希表中查找 PID=1 的进程
- **set_proc_name()**：设置进程名为 "init"

---

#### **阶段 7：验证结果**

```c
assert(idleproc != NULL && idleproc->pid == 0);
assert(initproc != NULL && initproc->pid == 1);
```

- 确保 idle 和 init 进程都已正确创建
- PID 符合预期（0 和 1）

---

### 关键点总结

#### **idle 进程 vs init 进程的创建方式**

| 特性 | idle 进程 | init 进程 |
|------|----------|----------|
| **创建方式** | 手动调用 `alloc_proc()` | 通过 `kernel_thread()` → `do_fork()` |
| **PID** | 手动设为 0 | 通过 `get_pid()` 分配，返回 1 |
| **内核栈** | 使用 `bootstack`（启动栈） | 通过 `setup_kstack()` 新分配 2 页 |
| **初始化** | 手动设置各字段 | `do_fork()` 自动完成 |
| **加入链表** | 未加入（特殊进程） | `do_fork()` 中加入 `proc_list` 和 `hash_list` |
| **父进程** | 无（`parent = NULL`） | idle 进程 |
| **入口函数** | 无（已在运行中） | `init_main` |

---

#### **idle 进程为什么不需要单独的内核栈？**

- `proc_init()` 在 `kern_init()` 中调用，此时 CPU 使用的是启动时分配的 `bootstack`
- idle 进程复用这个栈，避免浪费（idle 进程不会主动执行复杂操作）
- 后续通过 `schedule()` 切换到其他进程时，idle 的 context 会保存当前栈指针

---

#### **为什么 idle 的 need_resched 初始为 1？**

- 表示 idle 进程愿意立即让出 CPU
- `proc_init()` 完成后，会调用 `cpu_idle()`：
  ```c
  void cpu_idle(void)
  {
      while (1)
      {
          if (current->need_resched)
          {
              schedule();  // 立即调度，切换到 init 进程
          }
      }
  }
  ```
- 这样可以让 init 进程尽快得到执行

---

#### **init_main 函数的作用**

```c
static int init_main(void *arg)
{
    cprintf("this initproc, pid = %d, name = \"%s\"\n", current->pid, get_proc_name(current));
    cprintf("To U: \"%s\".\n", (const char *)arg);
    cprintf("To U: \"en.., Bye, Bye. :)\"\n");
    return 0;
}
```

- **当前实验**：仅打印信息，验证进程创建成功
- **后续实验**：init 进程会负责：
  - 创建第一个用户进程
  - 管理系统资源
  - 成为孤儿进程的父进程

---

### 执行时序图

```
kern_init()
    ↓
proc_init()
    ├─> list_init(&proc_list)          [初始化进程链表]
    ├─> list_init(hash_list[i])        [初始化哈希表]
    ├─> idleproc = alloc_proc()        [分配 idle PCB]
    ├─> 手动初始化 idleproc 字段
    ├─> current = idleproc             [设置当前进程]
    ├─> kernel_thread(init_main, ...) 
    │       ↓
    │   do_fork()
    │       ├─> alloc_proc()           [分配 init PCB]
    │       ├─> setup_kstack()         [分配 init 内核栈]
    │       ├─> copy_thread()          [设置 init 的 tf 和 context]
    │       ├─> get_pid() → 返回 1
    │       ├─> hash_proc()            [加入哈希表]
    │       ├─> list_add(proc_list)    [加入进程链表]
    │       └─> wakeup_proc()          [设为 RUNNABLE]
    ├─> initproc = find_proc(1)        [查找 init 进程]
    └─> set_proc_name(initproc, "init")

cpu_idle()  // idle 进程的主循环
    ↓
schedule()  // 调度到 init 进程
    ↓
init_main() // init 进程开始执行
```

---

### 初始化后的系统状态

```
进程列表 (proc_list):
    [idle (PID=0)] ←→ [init (PID=1)]

哈希表 (hash_list):
    hash_list[0]: → [idle]
    hash_list[1]: → [init]

全局指针:
    current → [idle]
    idleproc → [idle]
    initproc → [init]

进程状态:
    idle: PROC_RUNNABLE, need_resched=1, kstack=bootstack
    init: PROC_RUNNABLE, kstack=新分配的8KB, parent=idle
```

---

## kernel_thread() 函数 - 创建内核线程

### 函数原型与功能

```c
int kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags)
```

**功能**：创建一个新的内核线程，执行指定的函数 `fn`

**参数**：
- `fn`：内核线程的入口函数（函数指针）
- `arg`：传递给 `fn` 的参数
- `clone_flags`：克隆标志位，控制进程创建行为

**返回值**：
- 成功：返回新进程的 PID
- 失败：返回负数错误码

---

### 完整代码分析

```c
int kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags)
{
    struct trapframe tf;
    memset(&tf, 0, sizeof(struct trapframe));
    
    // 1. 将函数指针和参数保存到寄存器
    tf.gpr.s0 = (uintptr_t)fn;        // s0 保存函数指针
    tf.gpr.s1 = (uintptr_t)arg;       // s1 保存参数
    
    // 2. 设置 status 寄存器
    tf.status = (read_csr(sstatus) | SSTATUS_SPP | SSTATUS_SPIE) & ~SSTATUS_SIE;
    
    // 3. 设置入口点为 kernel_thread_entry
    tf.epc = (uintptr_t)kernel_thread_entry;
    
    // 4. 调用 do_fork 创建进程
    return do_fork(clone_flags | CLONE_VM, 0, &tf);
}
```

---

### 关键步骤详解

#### **1. 构造临时 trapframe**

```c
struct trapframe tf;
memset(&tf, 0, sizeof(struct trapframe));
```

- 在栈上创建一个临时的 `trapframe` 结构
- 初始化为全 0（所有寄存器清零）
- 这个 `tf` 会在 `do_fork()` → `copy_thread()` 中被复制到新进程的内核栈上

---

#### **2. 保存函数指针和参数到 s0、s1 寄存器**

```c
tf.gpr.s0 = (uintptr_t)fn;
tf.gpr.s1 = (uintptr_t)arg;
```

**为什么使用 s0 和 s1？**
- `s0-s11` 是 RISC-V 的**被调用者保存寄存器**（Callee-saved registers）
- 进程切换时会通过 `context` 保存和恢复这些寄存器
- 新线程第一次运行时，`s0` 和 `s1` 的值会被保留

**传递机制**：
```
kernel_thread 设置 tf.gpr.s0/s1
    ↓
copy_thread 复制到新进程的 trapframe
    ↓
新进程调度运行，从 trapframe 恢复寄存器
    ↓
kernel_thread_entry 从 s0/s1 中取出 fn 和 arg
```

---

#### **3. 设置 status 寄存器**

```c
tf.status = (read_csr(sstatus) | SSTATUS_SPP | SSTATUS_SPIE) & ~SSTATUS_SIE;
```

这行代码设置了 RISC-V 的 `sstatus` 寄存器，控制新线程的特权级和中断状态。

**位操作分解**：

| 操作 | 含义 | 作用 |
|------|------|------|
| `read_csr(sstatus)` | 读取当前 sstatus 寄存器 | 继承当前的部分状态 |
| `\| SSTATUS_SPP` | 设置 SPP 位为 1 | **新线程从内核态（S-mode）返回** |
| `\| SSTATUS_SPIE` | 设置 SPIE 位为 1 | **返回后开启中断** |
| `& ~SSTATUS_SIE` | 清除 SIE 位为 0 | **当前禁止中断**（在内核态运行） |

**RISC-V sstatus 寄存器关键位**：

```c
#define SSTATUS_SIE  0x00000002   // Supervisor Interrupt Enable
#define SSTATUS_SPIE 0x00000020   // Previous Interrupt Enable
#define SSTATUS_SPP  0x00000100   // Previous Privilege (0=U-mode, 1=S-mode)
```

- **SPP（Supervisor Previous Privilege）**：
  - `SPP=1`：表示进入内核态之前处于 S-mode（内核态）
  - `SPP=0`：表示进入内核态之前处于 U-mode（用户态）
  - 设置为 1 表示这是**内核线程**，"返回"到内核态

- **SPIE（Supervisor Previous Interrupt Enable）**：
  - 保存进入内核态之前的中断使能状态
  - `SPIE=1`：执行 `sret` 返回后，中断会被开启（`SIE=1`）
  - 确保内核线程运行时可以响应中断

- **SIE（Supervisor Interrupt Enable）**：
  - `SIE=1`：当前可以响应中断
  - `SIE=0`：当前禁止中断
  - 清零表示新线程在内核态运行时暂时禁止中断

**为什么这样设置？**
1. 内核线程运行在内核态，所以 `SPP=1`
2. 希望内核线程能响应时钟中断（实现调度），所以 `SPIE=1`（返回后开启中断）
3. 初始时禁止中断（`SIE=0`），避免在线程初始化期间被打断

---

#### **4. 设置程序入口点**

```c
tf.epc = (uintptr_t)kernel_thread_entry;
```

- **epc（Exception Program Counter）**：异常/中断返回后要执行的地址
- 设置为 `kernel_thread_entry` 的地址
- 新进程第一次调度运行时，会通过 `forkret()` → `forkrets()` → `sret` 跳转到这里

**为什么不直接设为 `fn`？**
- 因为 `fn` 需要参数 `arg`，但 `sret` 指令无法传参
- `kernel_thread_entry` 是一个**桥梁函数**，负责从寄存器中取出 `fn` 和 `arg`，然后调用 `fn(arg)`

**深层原因**：
1. **epc 只能指定跳转地址**：`sret` 指令从 `tf.epc` 恢复 PC，跳转到该地址开始执行，但不会自动传递参数
2. **参数存储在寄存器**：`fn` 和 `arg` 被保存在 `s0` 和 `s1` 寄存器中
3. **需要参数重排**：RISC-V 调用约定要求第一个参数放在 `a0` 寄存器，而不是 `s1`
4. **需要安全退出**：如果 `fn` 返回，必须调用 `do_exit` 清理进程，不能让 PC 跳到未定义区域

因此，`kernel_thread_entry` 的作用是：
- 将 `s1`（arg）移动到 `a0`（符合函数调用约定）
- 跳转到 `s0`（fn）执行函数
- 函数返回后调用 `do_exit` 退出进程

**流程对比**：
```
直接设为 fn（错误）:
    sret → fn 入口 → 但 arg 在 s1，fn 期望参数在 a0 → 参数错误
    fn 返回后 → PC 指向未定义地址 → 系统崩溃

通过 kernel_thread_entry（正确）:
    sret → kernel_thread_entry → move a0, s1 → jalr s0 → fn(arg) 正确执行
    fn 返回 → jal do_exit → 安全退出进程
```

**sret 指令的执行时机**：

`sret` 指令在 **`forkrets()`** 汇编函数（`kern/trap/trapentry.S`）的最后执行：

```
schedule() (sched.c)
    ↓
switch_to() (switch.S) - 进程切换
    ↓
恢复 context.ra → 跳转到 forkret() (proc.c)
    ↓
forkret() 调用 forkrets(current->tf) (proc.c)
    ↓
forkrets() (trapentry.S) - 从 trapframe 恢复所有 32 个寄存器
    ↓
【sret 指令执行】← 就在这里！(trapentry.S)
    ↓
跳转到 tf->epc (kernel_thread_entry)
    ↓
kernel_thread_entry (entry.S) - move a0, s1; jalr s0
    ↓
fn(arg) 开始执行
```

**关键点**：
- `sret` 将 `tf->epc` 的值恢复到 PC（程序计数器）
- 同时根据 `tf->status` 恢复中断状态（SPIE → SIE）
- 完成从内核态到新进程入口点的跳转

---

#### **5. 调用 do_fork 创建进程**

```c
return do_fork(clone_flags | CLONE_VM, 0, &tf);
```

**参数解释**：
- `clone_flags | CLONE_VM`：设置 `CLONE_VM` 标志
  - `CLONE_VM = 0x00000100`：表示**共享地址空间**
  - 内核线程共享内核地址空间，不需要独立的用户空间
  
- `0`：栈指针参数，0 表示这是内核线程（没有用户栈）

- `&tf`：传递构造好的 trapframe

---

### kernel_thread_entry 汇编代码

```riscv
.text
.globl kernel_thread_entry
kernel_thread_entry:        # void kernel_thread(void)
    move a0, s1             # 将 s1 (arg) 移动到 a0（第一个参数）
    jalr s0                 # 跳转到 s0 (fn) 并调用

    jal do_exit             # 函数返回后调用 do_exit 退出进程
```

**执行流程**：
1. **`move a0, s1`**：将参数 `arg`（存在 `s1` 中）移动到 `a0` 寄存器
   - RISC-V 调用约定：`a0-a7` 是函数参数寄存器
   - `a0` 是第一个参数

2. **`jalr s0`**：跳转到 `fn` 并执行
   - `jalr` = Jump And Link Register
   - 将返回地址保存到 `ra` 寄存器
   - 跳转到 `s0` 指向的地址（即 `fn`）

3. **`jal do_exit`**：如果 `fn` 返回，调用 `do_exit` 退出进程
   - 确保内核线程正常退出，不会执行到未定义的代码
   - `do_exit` 会清理进程资源并进行进程调度

---

### 新内核线程的启动流程

```
1. kernel_thread(init_main, arg, 0)
   └─> 构造 trapframe:
       - tf.gpr.s0 = init_main
       - tf.gpr.s1 = arg
       - tf.epc = kernel_thread_entry
       - tf.status = ...

2. do_fork(CLONE_VM, 0, &tf)
   ├─> alloc_proc()                    [分配 PCB]
   ├─> setup_kstack()                  [分配内核栈]
   ├─> copy_thread(proc, 0, &tf)      [设置 trapframe 和 context]
   │   ├─> proc->tf = (kstack 顶部)
   │   ├─> *(proc->tf) = tf           [复制 trapframe]
   │   ├─> proc->context.ra = forkret [设置返回地址]
   │   └─> proc->context.sp = proc->tf
   ├─> get_pid() → 1
   ├─> hash_proc() + list_add()       [加入链表]
   └─> wakeup_proc()                  [设为 RUNNABLE]

3. schedule() 调度到新进程
   └─> switch_to(&(prev->context), &(next->context))
       └─> 恢复 next->context
           └─> 跳转到 context.ra = forkret

4. forkret()
   └─> forkrets(current->tf)
       └─> 从 trapframe 恢复所有寄存器
           ├─> s0 = init_main
           ├─> s1 = arg
           ├─> pc = tf.epc = kernel_thread_entry
           └─> sret (返回到 kernel_thread_entry)

5. kernel_thread_entry (汇编)
   ├─> move a0, s1              [a0 = arg]
   ├─> jalr s0                  [调用 init_main(arg)]
   │   └─> init_main 执行...
   └─> jal do_exit              [退出进程]
```

---

### 关键机制总结

#### **1. trapframe 的作用**

- 保存新进程的**初始寄存器状态**
- 通过设置特定寄存器（`s0`、`s1`、`epc`）实现参数传递和入口点设置
- 新进程第一次运行时，从 trapframe 恢复寄存器，开始执行

#### **2. 为什么需要 kernel_thread_entry？**

- **间接跳转**：`sret` 只能跳转到 `epc` 指定的地址，无法直接传参
- **参数传递**：从 `s0`/`s1` 提取 `fn` 和 `arg`，按照 RISC-V 调用约定调用
- **安全退出**：确保内核线程返回后调用 `do_exit`，不会跳到随机地址

#### **3. context vs trapframe**

| 结构 | 用途 | 保存内容 | 使用场景 |
|------|------|---------|---------|
| **context** | 进程切换 | 14 个寄存器（ra, sp, s0-s11） | `switch_to` 时保存/恢复 |
| **trapframe** | 中断/异常 | 所有 32 个寄存器 + pc + status | 中断返回、进程初始化 |

- 新进程第一次运行：先通过 `context` 跳转到 `forkret`，再通过 `trapframe` 跳转到 `kernel_thread_entry`
- 后续进程切换：只需保存/恢复 `context`

#### **4. CLONE_VM 标志**

```c
#define CLONE_VM 0x00000100  // 共享虚拟地址空间
```

- **设置 CLONE_VM**：新进程共享父进程的地址空间（内核线程）
- **不设置 CLONE_VM**：新进程复制父进程的地址空间（用户进程 fork）
- 内核线程只需要内核空间，所以设置 `CLONE_VM`

---

### 使用示例

```c
// 在 proc_init 中创建 init 进程
int pid = kernel_thread(init_main, "Hello world!!", 0);

// init_main 函数
static int init_main(void *arg)
{
    cprintf("To U: \"%s\".\n", (const char *)arg);  // 输出 "Hello world!!"
    return 0;
}
```

**执行流程**：
1. `kernel_thread` 设置 `s0 = init_main`，`s1 = "Hello world!!"`
2. `do_fork` 创建新进程，PID=1
3. 调度器运行 init 进程
4. 跳转到 `kernel_thread_entry`
5. `kernel_thread_entry` 调用 `init_main("Hello world!!")`
6. `init_main` 输出信息并返回
7. `do_exit` 退出进程

---

## do_fork() 函数 - 创建子进程

### 函数原型与功能

```c
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
```

**功能**：为父进程创建一个新的子进程（或内核线程）

**参数**：
- `clone_flags`：克隆标志位，控制进程资源的共享/复制行为
  - `CLONE_VM (0x00000100)`：共享地址空间（内核线程）
  - 其他标志（后续实验）：`CLONE_THREAD`、`CLONE_FILES` 等
  
- `stack`：父进程的用户栈指针
  - `stack == 0`：表示创建内核线程（无用户栈）
  - `stack != 0`：表示创建用户进程，指定用户栈位置
  
- `tf`：trapframe 信息，将被复制到子进程的 `proc->tf`
  - 包含子进程的初始寄存器状态
  - 决定子进程第一次运行时的 CPU 状态

**返回值**：
- 成功：返回子进程的 PID
- 失败：返回负数错误码
  - `-E_NO_FREE_PROC`：进程数量达到上限
  - `-E_NO_MEM`：内存分配失败

---

### 完整代码框架

```c
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    
    // 检查进程数量是否达到上限
    if (nr_process >= MAX_PROCESS)
    {
        goto fork_out;
    }
    
    ret = -E_NO_MEM;
    
    // LAB4:EXERCISE2 实现以下步骤：
    // 1. call alloc_proc to allocate a proc_struct
    // 2. call setup_kstack to allocate a kernel stack for child process
    // 3. call copy_mm to dup OR share mm according clone_flag
    // 4. call copy_thread to setup tf & context in proc_struct
    // 5. insert proc_struct into hash_list && proc_list
    // 6. call wakeup_proc to make the new child process RUNNABLE
    // 7. set ret vaule using child proc's pid
    
fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```

---

### 实现步骤详解

#### **步骤 0：检查进程数量限制**

```c
if (nr_process >= MAX_PROCESS)
{
    goto fork_out;
}
```

- **MAX_PROCESS**：系统允许的最大进程数（通常为 4096）
- **nr_process**：当前系统中的进程总数
- 如果达到上限，返回 `-E_NO_FREE_PROC` 错误

---

#### **步骤 1：分配进程控制块**

```c
proc = alloc_proc();
if (proc == NULL) {
    goto fork_out;
}
```

**alloc_proc() 的作用**：
- 调用 `kmalloc()` 分配 `proc_struct` 结构体
- 初始化所有字段为默认值：
  ```c
  proc->state = PROC_UNINIT;
  proc->pid = -1;
  proc->runs = 0;
  proc->kstack = 0;
  proc->need_resched = 0;
  proc->parent = NULL;
  proc->mm = NULL;
  proc->context = {0};
  proc->tf = NULL;
  proc->pgdir = boot_pgdir_pa;  // 暂时使用内核页表
  proc->flags = 0;
  memset(proc->name, 0, PROC_NAME_LEN);
  ```

**失败处理**：
- 如果分配失败，返回 `-E_NO_MEM`

---

#### **步骤 2：分配内核栈**

```c
if (setup_kstack(proc) != 0) {
    goto bad_fork_cleanup_proc;
}
```

**setup_kstack() 的实现**：
```c
static int setup_kstack(struct proc_struct *proc)
{
    struct Page *page = alloc_pages(KSTACKPAGE);  // 分配 2 页（8KB）
    if (page != NULL)
    {
        proc->kstack = (uintptr_t)page2kva(page);  // 转换为内核虚拟地址
        return 0;
    }
    return -E_NO_MEM;
}
```

**关键点**：
- 为子进程分配独立的内核栈（8KB）
- `proc->kstack` 指向内核栈的**基址**（低地址）
- 栈从高地址向低地址增长

**内核栈布局**：
```
高地址 →  +------------------+  ← kstack + KSTACKSIZE (8KB)
          |   trapframe      |  ← 最顶部预留给 trapframe
          +------------------+
          |                  |
          |   栈空间         |  ← 向下增长
          |                  |
低地址 →  +------------------+  ← kstack (基址)
```

**失败处理**：
- 如果分配失败，跳转到 `bad_fork_cleanup_proc`
- 释放已分配的 `proc` 结构体

---

#### **步骤 3：复制或共享内存管理结构**

```c
if (copy_mm(clone_flags, proc) != 0) {
    goto bad_fork_cleanup_kstack;
}
```

**copy_mm() 的作用**：
```c
static int copy_mm(uint32_t clone_flags, struct proc_struct *proc)
{
    assert(current->mm == NULL);  // 当前实验中，parent 是内核线程
    /* do nothing in this project */
    return 0;
}
```

**两种模式**：
- **clone_flags & CLONE_VM == 1**：共享地址空间（内核线程、Linux 线程）
  - 子进程的 `mm` 指向父进程的 `mm`
  - 不复制页表，共享内核空间
  
- **clone_flags & CLONE_VM == 0**：复制地址空间（fork 用户进程）
  - 为子进程创建新的 `mm_struct`
  - 复制父进程的页表和 VMA
  - 实现写时复制（Copy-on-Write, COW）

**当前实验的简化**：
- 父进程是内核线程（`current->mm == NULL`）
- 子进程也是内核线程，不需要用户空间
- 直接返回 0

**失败处理**：
- 如果失败，跳转到 `bad_fork_cleanup_kstack`
- 释放内核栈和 `proc` 结构体

---

#### **步骤 4：设置 trapframe 和 context**

```c
copy_thread(proc, stack, tf);
```

**copy_thread() 的实现**：
```c
static void copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf)
{
    // 1. 在内核栈顶部放置 trapframe
    proc->tf = (struct trapframe *)(proc->kstack + KSTACKSIZE - sizeof(struct trapframe));
    
    // 2. 复制父进程的 trapframe
    *(proc->tf) = *tf;

    // 3. 修改子进程的返回值为 0（fork 的返回值约定）
    proc->tf->gpr.a0 = 0;
    
    // 4. 设置栈指针
    proc->tf->gpr.sp = (esp == 0) ? (uintptr_t)proc->tf : esp;

    // 5. 设置 context，确保子进程第一次运行时跳转到 forkret
    proc->context.ra = (uintptr_t)forkret;
    proc->context.sp = (uintptr_t)(proc->tf);
}
```

**详细解释**：

1. **确定 trapframe 位置**：
   ```
   proc->tf = kstack + 8KB - sizeof(trapframe)
   ```
   - trapframe 放在内核栈的**最顶部**
   - 便于访问和保护

2. **复制 trapframe**：
   ```c
   *(proc->tf) = *tf;
   ```
   - 将父进程传入的 `tf` 复制到子进程的内核栈
   - 子进程继承父进程的寄存器状态

3. **设置返回值**：
   ```c
   proc->tf->gpr.a0 = 0;
   ```
   - **fork 的约定**：子进程返回 0，父进程返回子进程 PID
   - `a0` 寄存器用于函数返回值

4. **设置栈指针**：
   ```c
   proc->tf->gpr.sp = (esp == 0) ? (uintptr_t)proc->tf : esp;
   ```
   - **esp == 0**（内核线程）：`sp` 指向 `trapframe`
   - **esp != 0**（用户进程）：`sp` 指向用户栈

5. **设置 context**：
   ```c
   proc->context.ra = (uintptr_t)forkret;
   proc->context.sp = (uintptr_t)(proc->tf);
   ```
   - **context.ra**：子进程第一次被调度时，从 `forkret` 开始执行
   - **context.sp**：内核栈指针指向 `trapframe`

**为什么设置 context.ra = forkret？**
- 进程切换通过 `switch_to` 实现，会跳转到 `context.ra`
- 新进程第一次运行时，需要从 `trapframe` 恢复所有寄存器
- `forkret` 就是做这件事的：
  ```c
  static void forkret(void)
  {
      forkrets(current->tf);  // 从 trapframe 恢复寄存器并返回
  }
  ```

---

#### **步骤 5：设置父子进程关系并分配 PID**

```c
proc->parent = current;           // 设置父进程
proc->pid = get_pid();            // 分配唯一 PID
```

**get_pid() 的算法**：
- 从上次分配的 PID 开始递增
- 遍历 `proc_list`，避免 PID 冲突
- 返回一个未使用的 PID（1 ~ MAX_PID）

**PID 分配示例**：
```
第一次调用：返回 1（idle 是 0）
第二次调用：返回 2
...
达到 MAX_PID 后回绕到 1
```

---

#### **步骤 6：加入进程链表和哈希表**

```c
hash_proc(proc);                  // 加入哈希表
list_add(&proc_list, &(proc->list_link));  // 加入进程链表
nr_process++;                     // 进程计数 +1
```

**hash_proc() 的实现**：
```c
static void hash_proc(struct proc_struct *proc)
{
    list_add(hash_list + pid_hashfn(proc->pid), &(proc->hash_link));
}
```
- 根据 PID 计算哈希值：`hash_list[pid_hashfn(pid)]`
- 将 `proc->hash_link` 插入对应的哈希桶
- 支持 O(1) 的 PID 查找

**全局数据结构更新**：
```
proc_list: [idle] ←→ [init] ←→ [new_proc]

hash_list[hash(pid)]: → [new_proc]

nr_process: 2 → 3
```

---

#### **步骤 7：唤醒新进程**

```c
wakeup_proc(proc);
```

**wakeup_proc() 的实现**：
```c
void wakeup_proc(struct proc_struct *proc) {
    assert(proc->state != PROC_ZOMBIE && proc->state != PROC_RUNNABLE);
    proc->state = PROC_RUNNABLE;
}
```

**作用**：
- 将进程状态从 `PROC_UNINIT` 改为 `PROC_RUNNABLE`
- 标记进程为**可运行状态**，等待调度器调度

**状态转换**：
```
PROC_UNINIT (alloc_proc 后)
    ↓
PROC_RUNNABLE (wakeup_proc 后)
    ↓
RUNNING (schedule 调度后)
```

---

#### **步骤 8：返回子进程 PID**

```c
ret = proc->pid;
```

- 设置返回值为子进程的 PID
- 父进程通过 `do_fork` 的返回值获知子进程的 PID

**fork 的双返回值约定**：
```c
// 父进程侧
int pid = do_fork(...);  // 返回子进程 PID（如 1）

// 子进程侧
// proc->tf->gpr.a0 = 0，所以子进程"看到"的返回值是 0
```

---

### 错误处理机制

```c
fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);           // 释放内核栈
bad_fork_cleanup_proc:
    kfree(proc);                // 释放 PCB
    goto fork_out;
```

**三级清理**：
1. **fork_out**：直接返回错误码
2. **bad_fork_cleanup_kstack**：释放内核栈 → 释放 PCB → 返回
3. **bad_fork_cleanup_proc**：释放 PCB → 返回

**优点**：
- 避免内存泄漏
- 统一的错误处理流程
- 使用 goto 简化代码（在内核中常见）

---

### 完整执行流程图

```
do_fork(clone_flags, stack, tf)
    │
    ├─> [1] 检查进程数量
    │       if (nr_process >= MAX_PROCESS)
    │           return -E_NO_FREE_PROC
    │
    ├─> [2] 分配 PCB
    │       proc = alloc_proc()
    │       初始化所有字段为默认值
    │
    ├─> [3] 分配内核栈（8KB）
    │       setup_kstack(proc)
    │       proc->kstack = 新分配的内核栈基址
    │
    ├─> [4] 复制/共享内存管理结构
    │       copy_mm(clone_flags, proc)
    │       当前实验：什么都不做（内核线程）
    │
    ├─> [5] 设置 trapframe 和 context
    │       copy_thread(proc, stack, tf)
    │       ├─> proc->tf = kstack 顶部
    │       ├─> *(proc->tf) = *tf（复制）
    │       ├─> proc->tf->gpr.a0 = 0（子进程返回值）
    │       ├─> proc->tf->gpr.sp = ...
    │       ├─> proc->context.ra = forkret
    │       └─> proc->context.sp = proc->tf
    │
    ├─> [6] 设置进程关系
    │       proc->parent = current
    │       proc->pid = get_pid()
    │
    ├─> [7] 加入全局数据结构
    │       hash_proc(proc)           // 哈希表
    │       list_add(&proc_list, ...)  // 进程链表
    │       nr_process++
    │
    ├─> [8] 唤醒新进程
    │       wakeup_proc(proc)
    │       proc->state = PROC_RUNNABLE
    │
    └─> [9] 返回子进程 PID
            return proc->pid
```

---

### 关键数据结构的变化

#### **创建前（以 init 进程为例）**：
```
current = idle (PID=0)
proc_list: [idle]
nr_process = 1
```

#### **do_fork 执行过程**：
```
1. alloc_proc():
   proc = {state=UNINIT, pid=-1, kstack=0, ...}

2. setup_kstack():
   proc->kstack = 0xffffffffc0200000 (假设)

3. copy_thread():
   proc->tf = 0xffffffffc0201f00 (kstack + 8KB - 160B)
   proc->context.ra = forkret
   proc->context.sp = proc->tf

4. get_pid():
   proc->pid = 1

5. hash_proc() + list_add():
   proc_list: [idle] ←→ [init]
   hash_list[1]: → [init]

6. wakeup_proc():
   proc->state = RUNNABLE
```

#### **创建后**：
```
current = idle (PID=0)
proc_list: [idle] ←→ [init]
nr_process = 2

init 进程:
  - state = PROC_RUNNABLE
  - pid = 1
  - parent = idle
  - kstack = 0xffffffffc0200000
  - tf = 0xffffffffc0201f00
  - context.ra = forkret
  - 等待调度器调度运行
```

---

### do_fork vs kernel_thread

| 特性 | kernel_thread | do_fork |
|------|---------------|---------|
| **层次** | 高层接口 | 底层实现 |
| **功能** | 创建内核线程 | 创建任意进程 |
| **参数** | 函数指针 + 参数 | clone_flags + stack + trapframe |
| **调用方式** | `kernel_thread(fn, arg, flags)` | `do_fork(flags, stack, tf)` |
| **使用场景** | 内核线程创建 | fork、clone、vfork 系统调用 |
| **trapframe 来源** | 内部构造 | 外部传入 |

**关系**：
```c
kernel_thread(fn, arg, flags)
    ↓
    构造 trapframe (设置 s0=fn, s1=arg, epc=kernel_thread_entry)
    ↓
    调用 do_fork(flags | CLONE_VM, 0, &tf)
```

---

### 与 Unix fork() 系统调用的区别

| 特性 | Unix fork() | uCore do_fork |
|------|-------------|---------------|
| **调用方式** | 用户态系统调用 | 内核内部函数 |
| **地址空间** | 总是复制（COW） | 根据 CLONE_VM 决定 |
| **返回值** | 父进程返回子PID，子进程返回0 | 相同 |
| **trapframe** | 从当前 trapframe 复制 | 外部传入 |
| **用途** | 用户进程 fork | 内核线程 + 用户进程 |

---

### 常见问题

#### **Q1：为什么子进程的返回值是 0？**
```c
proc->tf->gpr.a0 = 0;
```
- **约定**：子进程通过返回值 0 区分自己是子进程
- 父进程通过返回值（子进程 PID）区分自己是父进程
- 这样同一份代码可以根据返回值执行不同逻辑：
  ```c
  int pid = fork();
  if (pid == 0) {
      // 子进程执行的代码
  } else {
      // 父进程执行的代码
  }
  ```

#### **Q2：为什么需要 context 和 trapframe 两个结构？**
- **context**：用于进程切换，只保存 14 个寄存器（ra, sp, s0-s11）
- **trapframe**：用于中断返回和进程初始化，保存所有 32 个寄存器 + pc + status
- 新进程第一次运行需要完整状态（trapframe），后续切换只需部分寄存器（context）

#### **Q3：do_fork 可以用于创建用户进程吗？**
- **可以**！只需传入正确的参数：
  - `clone_flags`：不设置 `CLONE_VM`（复制地址空间）
  - `stack`：用户栈指针
  - `tf`：包含用户态 CPU 状态（SPP=0，用户态代码地址）
- 当前实验只实现了内核线程，用户进程在后续实验中实现

---
