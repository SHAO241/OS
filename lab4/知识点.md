# sv39复习


### 3级页表结构

| Page Directory | Page Directory | Page Table     | Offset within Page |
|:--------------:|:--------------:|:--------------:|:------------------:|
| Index 1        | Index 2        |                |                    |
| PDX1(la)       | PDX0(la)       | PTX(la)        | PGOFF(la)          |
|                |                |                |                    |
| <-------------------PPN(la)------------------->                    |


### 虚拟地址结构

|  VPN[2]  |  VPN[1]  |  VPN[0]  |  PGOFF  |
|:--------:|:--------:|:--------:|:-------:|
|   9 bit  |   9 bit  |   9 bit  | 12 bit  |


### 物理地址结构

|  PPN[2]  |  PPN[1]  |  PPN[0]  |  PGOFF  |
|:--------:|:--------:|:--------:|:-------:|
|  26 bit  |   9 bit  |   9 bit  | 12 bit  |


### 页表项结构

|  PPN[2]  |  PPN[1]  |  PPN[0]  | Reserved | D | A | G | U | X | W | R | V |
|:--------:|:--------:|:--------:|:--------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|  26 bit  |   9 bit  |   9 bit  |   2 bit  | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

# kern/mm/mmu.h内容
下面结合源码逐条解释：

#### 地址分解与宏
sv39 的 64 位虚拟地址低 39 位参与页表（9+9+9+12），对应 `PDX1`(VPN[2])、`PDX0`(VPN[1])、`PTX`(VPN[0])、`PGOFF`。`mmu.h` 中：

- `#define PDX1(la) ((((uintptr_t)(la)) >> PDX1SHIFT) & 0x1FF)` 取最高层 9bit；
- `#define PDX0(la) ((((uintptr_t)(la)) >> PDX0SHIFT) & 0x1FF)` 取中间层 9bit；
- `#define PTX(la)  ((((uintptr_t)(la)) >> PTXSHIFT)  & 0x1FF)` 取最低层页表索引 9bit；
- `#define PGOFF(la) (((uintptr_t)(la)) & 0xFFF)` 页内偏移 12bit；
- `#define PPN(la)   (((uintptr_t)(la)) >> PTXSHIFT)` 去掉页内偏移后得到线性地址对应的“页号”字段（含所有 VPN bits 合起来）。一共**44**位

位移常量：

- `PTXSHIFT = 12` 页内偏移长度；
- `PDX0SHIFT = 21` = 12 + 9；
- `PDX1SHIFT = 30` = 12 + 9 + 9。

构造地址：`PGADDR(d1,d0,t,o)` 把三个层级索引与页内偏移重新拼成线性地址。
```cpp
#define PGADDR(d1, d0, t, o) ((uintptr_t)((d1) << PDX1SHIFT |(d0) << PDX0SHIFT | (t) << PTXSHIFT | (o)))
```
一个一个左移相应的位数，然后按位或拼接起来

#### 页表项地址抽取
```cpp
#define PTE_ADDR(pte)   (((uintptr_t)(pte) & ~0x3FF) << (PTXSHIFT - PTE_PPN_SHIFT))
#define PDE_ADDR(pde)   PTE_ADDR(pde)
```
- `PTE_ADDR(pte)` 清掉低 10 位标志位（`& ~0x3FF`），再左移把 PPN 对齐，得到物理页基址。把Reserved和DAG什么的全部删掉，然后左移12位**凑出了12位**的页内偏移。
- `PDE_ADDR(pde)` 与 `PTE_ADDR` 相同，用于目录项。

`PTE_PPN_SHIFT = 10` 表示 PTE 中低 10 位是标志，后面开始为 PPN。

在该页表示一个物理页的时候就有用。

#### 结构和大小常量
- `NPDEENTRY = 512`，`NPTEENTRY = 512`：每层 512 项（9bit）。
- `PGSIZE = 4096`，`PGSHIFT = 12`：页大小与其 log2。
- `PTSIZE = PGSIZE * NPTEENTRY = 2MB`：一个二级页表（最低层）映射的总字节数。
- `PTSHIFT = 21`：log2(2MB)。

#### 权限与标志位（对应 RISC-V PTE）
| 宏 | 值 | 说明 |
|----|----|------|
| `PTE_V` | 0x001 | 有效（Valid）|
| `PTE_R` | 0x002 | 可读 |
| `PTE_W` | 0x004 | 可写 |
| `PTE_X` | 0x008 | 可执行 |
| `PTE_U` | 0x010 | 用户态可访问 |
| `PTE_G` | 0x020 | 全局页（不清 TLB）|
| `PTE_A` | 0x040 | 已访问（硬件或软件置位）|
| `PTE_D` | 0x080 | 已修改（脏页）|
| `PTE_SOFT` | 0x300 | 软件保留位（实现可自定义）|

组合宏：
```cpp
#define PAGE_TABLE_DIR (PTE_V)
#define READ_ONLY (PTE_R | PTE_V)   // 只读
#define READ_WRITE (PTE_R | PTE_W | PTE_V)  //读写
#define EXEC_ONLY (PTE_X | PTE_V)   //只能执行
#define READ_EXEC (PTE_R | PTE_X | PTE_V)   //读 + 执行
#define READ_WRITE_EXEC (PTE_R | PTE_W | PTE_X | PTE_V) // 读写执行
```
- `PAGE_TABLE_DIR`：仅有效位，用来指示该条目指向下一层页表（一般还需要检查其余位是否为 0 来判定非叶子）。
- `READ_ONLY / READ_WRITE / EXEC_ONLY / READ_EXEC / READ_WRITE_EXEC`：常用权限集合，方便建立段/页映射。
- `PTE_USER`：用户页的常用组合（读写执行 + 用户 + 有效）。

#### 关于注释中 Sv32 的提醒
文件顶部和中间的 ASCII 注释仍显示 10/10/12 结构以及 “Sv32 page table entry”，这是旧的双级页表（Sv32）格式。当前宏与常量（512 项、9bit 索引、3 级）对应的是 Sv39。应注意该注释尚未更新，避免混淆。真正的 Sv39 PTE PPN 结构为：PPN[2](26bit) | PPN[1](9bit) | PPN[0](9bit) | Flags。实现中用统一的位屏蔽与移位来抽取地址部分。

#### 快速记忆
- 三层 9bit：`PDX1 / PDX0 / PTX`；
- 页内偏移 12bit：`PGOFF`；
- 一个最低层页表能映射 2MB；
- 权限组合快速使用宏，无需手写位；
- 低 10 位为标志，高位为物理页号。

# pmm.c的内容

### pte2page 和 pa2page 函数解析（pmm.h）

#### pte2page - 从页表项获取对应的 Page 结构体

```c
static inline struct Page *
pte2page(pte_t pte)
{
    if (!(pte & PTE_V))
    {
        panic("pte2page called with invalid pte");
    }
    return pa2page(PTE_ADDR(pte));
}
```

**功能**：从一个页表项（PTE）中提取物理页号，并返回对应的 `Page` 结构体指针。

**实现步骤**：
1. **有效性检查**：`!(pte & PTE_V)` 检查 PTE 的 Valid 位
   - 如果 PTE 无效（V=0），说明该页表项未映射，调用会导致 panic
   - 确保不会访问无效的物理页

2. **提取物理地址**：`PTE_ADDR(pte)` 
   - 清除低 10 位标志位，提取 PPN 字段
   - 左移 2 位对齐到物理地址（补齐页内偏移的 12 位）
   - 得到 4KB 对齐的物理页基址

3. **转换为 Page 结构体**：`pa2page(物理地址)`
   - 调用 `pa2page` 将物理地址转换为 `Page` 结构体指针


---

#### pa2page - 从物理地址获取对应的 Page 结构体

```c
static inline struct Page *
pa2page(uintptr_t pa)
{
    if (PPN(pa) >= npage)
    {
        panic("pa2page called with invalid pa");
    }
    return &pages[PPN(pa) - nbase];
}
```

**功能**：将物理地址转换为管理该物理页的 `Page` 结构体指针。

**实现详解**：

1. **提取物理页号**：`PPN(pa)` = `pa >> 12`
   - 去掉低 12 位页内偏移
   - 得到物理页号（Physical Page Number）

2. **边界检查**：`PPN(pa) >= npage`
   - `npage` 是系统管理的总页数
   - 防止访问超出物理内存范围的地址

3. **计算 Page 数组索引**：`PPN(pa) - nbase`
   - `nbase = DRAM_BASE / PGSIZE`，在 RISC-V 中通常 `DRAM_BASE = 0x80000000`
   - 因此 `nbase = 0x80000000 / 4096 = 0x80000`
   - 物理内存从 0x80000000 开始，对应的 `pages` 数组从索引 0 开始
   - 所以需要减去 `nbase` 来得到正确的数组索引

4. **返回指针**：`&pages[索引]`
   - `pages` 是全局数组，存储所有物理页的 `Page` 结构体
   - 返回对应物理页的 `Page` 结构体地址

**关键常量**：
- `pages`：全局 `struct Page` 数组，每个物理页对应一个元素
- `npage`：系统管理的物理页总数
- `nbase`：物理内存起始地址对应的页号（RISC-V 中为 0x80000）

**示例计算**：
```
物理地址 pa = 0x80001000
PPN(pa) = 0x80001000 >> 12 = 0x80001
数组索引 = 0x80001 - 0x80000 = 1
返回 &pages[1]
```

---

#### 两者关系与调用链

```
页表项(PTE) 
    ↓ pte2page
物理地址(PA) = PTE_ADDR(pte)
    ↓ pa2page
Page结构体指针 = &pages[PPN(pa) - nbase]
```

**核心思想**：
- **PTE → PA**：页表项存储的是物理页号（PPN），通过位操作提取并转换为物理地址
- **PA → Page**：物理地址映射到 `pages` 数组中的对应元素，该元素存储该物理页的元数据（引用计数、标志位等）

## nr_free_pages() 函数

```c
size_t nr_free_pages(void)
{
    size_t ret;
    bool intr_flag;
    local_intr_save(intr_flag);  // 保存中断状态并关闭中断
    {
        ret = pmm_manager->nr_free_pages();  // 调用物理内存管理器的方法
    }
    local_intr_restore(intr_flag);  // 恢复中断状态
    return ret;
}
```

**功能**：返回当前系统中空闲物理页的数量。

**实现要点**：
1. **中断保护**：使用 `local_intr_save` 和 `local_intr_restore` 保证操作的原子性
   - 防止在统计空闲页数时被中断打断
   - 避免并发访问导致的计数不一致
   
2. **委托给 PMM**：实际工作由 `pmm_manager->nr_free_pages()` 完成
   - `pmm_manager` 是物理内存管理器实例（如 first_fit、best_fit、buddy_system 等）
   - 不同的内存分配算法有各自的空闲页链表管理方式
   
3. **返回值**：空闲页数量（size_t 类型），可用于：
   - 检测内存泄漏（测试前后空闲页数是否一致）
   - 判断是否有足够内存进行分配
   - 系统监控与调试

**使用场景**：
- `check_pgdir()` 等测试函数中保存初始空闲页数，最后对比检查是否泄漏
- 内存分配前检查可用内存是否充足

## get_pte() - 获取/创建页表项

```c
pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create)
{
    pde_t *pdep1 = &pgdir[PDX1(la)];
    if (!(*pdep1 & PTE_V))
    {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL)
        {
            return NULL;
        }
        set_page_ref(page, 1);
        uintptr_t pa = page2pa(page);
        memset(KADDR(pa), 0, PGSIZE);
        *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);
    }
    pde_t *pdep0 = &((pte_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
    if (!(*pdep0 & PTE_V))
    {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL)
        {
            return NULL;
        }
        set_page_ref(page, 1);
        uintptr_t pa = page2pa(page);
        memset(KADDR(pa), 0, PGSIZE);
        *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);
    }
    return &((pte_t *)KADDR(PDE_ADDR(*pdep0)))[PTX(la)];
}
```

**功能**：根据虚拟地址查找对应的页表项（PTE）指针，如需要且允许则自动创建中间层页表。

**参数**：
- `pgdir`：一级页目录（根页表）的虚拟地址
- `la`：要查找的线性（虚拟）地址
- `create`：如果中间层页表不存在，是否创建（true=创建，false=返回NULL）

**实现流程**：

### 第一步：处理一级页表（VPN[2]）

```c
pde_t *pdep1 = &pgdir[PDX1(la)];  // 获取一级页表项地址
```
- `PDX1(la)` 提取虚拟地址的高 9 位（VPN[2]），作为一级页表索引
- `pdep1` 指向一级页表中的对应项

```c
if (!(*pdep1 & PTE_V))  // 如果一级页表项无效
{
    struct Page *page;
    if (!create || (page = alloc_page()) == NULL)
        return NULL;  // 不允许创建或分配失败，返回NULL
    
    set_page_ref(page, 1);           // 设置引用计数为1
    uintptr_t pa = page2pa(page);    // 获取物理地址
    memset(KADDR(pa), 0, PGSIZE);    // 清零整个页（4KB）
    *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);  // 创建页表项
}
```
- **分配物理页**：为二级页表分配一个物理页
- **初始化**：清零页表内容，避免脏数据
- **设置权限**：`PTE_U`（用户态可访问）+ `PTE_V`（有效位）
- **写入页表项**：将 PPN 和权限组合写入一级页表项

### 第二步：处理二级页表（VPN[1]）

```c
pde_t *pdep0 = &((pte_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];
```
- `PDE_ADDR(*pdep1)`：从一级页表项中提取二级页表的物理地址
- `KADDR(...)`：物理地址转内核虚拟地址
- `[PDX0(la)]`：用 VPN[1] 索引二级页表

```c
if (!(*pdep0 & PTE_V))  // 如果二级页表项无效
{
    // 同样的流程：分配页 → 清零 → 设置权限 → 写入
    struct Page *page;
    if (!create || (page = alloc_page()) == NULL)
        return NULL;
    set_page_ref(page, 1);
    uintptr_t pa = page2pa(page);
    memset(KADDR(pa), 0, PGSIZE);
    *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);
}
```

### 第三步：返回三级页表项指针（VPN[0]）

```c
return &((pte_t *)KADDR(PDE_ADDR(*pdep0)))[PTX(la)];
```
- `PDE_ADDR(*pdep0)`：从二级页表项中提取三级页表的物理地址
- `KADDR(...)`：转为内核虚拟地址
- `[PTX(la)]`：用 VPN[0] 索引三级页表
- 返回该页表项的**指针**（调用者可以读写该 PTE）

**为什么要用 KADDR 转换？**
- 页表项中存储的是**物理地址**（PPN），CPU 无法直接访问物理地址
- 必须转换为**内核虚拟地址**才能在代码中读写页表内容
- `KADDR(pa)` = `pa + va_pa_offset`，将物理地址映射到内核虚拟地址空间

**关键点**：
1. **按需分配**：只在需要时才分配中间层页表，节省内存
2. **权限传播**：中间层页表项设置 `PTE_U`，确保用户态可访问
3. **清零初始化**：新分配的页表必须清零，否则随机数据会被当作有效项
4. **返回指针**：返回的是 PTE 的地址，不是 PTE 的值，便于调用者修改


## page_insert() - 建立虚拟地址到物理页的映射

```c
int page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm)
{
    pte_t *ptep = get_pte(pgdir, la, 1);
    if (ptep == NULL)
    {
        return -E_NO_MEM;
    }
    page_ref_inc(page);
    if (*ptep & PTE_V)
    {
        struct Page *p = pte2page(*ptep);
        if (p == page)
        {
            page_ref_dec(page);
        }
        else
        {
            page_remove_pte(pgdir, la, ptep);
        }
    }
    *ptep = pte_create(page2ppn(page), PTE_V | perm);
    tlb_invalidate(pgdir, la);
    return 0;
}
```

**功能**：将一个物理页映射到指定的虚拟地址，设置访问权限，并正确处理引用计数和 TLB。

**参数**：
- `pgdir`：页目录（根页表）虚拟地址
- `page`：要映射的物理页（`Page` 结构体指针）
- `la`：目标虚拟地址
- `perm`：权限位（如 `PTE_U | PTE_W` 表示用户可读写）

**返回值**：
- `0`：成功
- `-E_NO_MEM`：内存不足（无法分配中间层页表）

**实现步骤详解**：

### 1. 获取页表项指针
```c
pte_t *ptep = get_pte(pgdir, la, 1);  // create=1，自动创建缺失的页表
if (ptep == NULL)
    return -E_NO_MEM;  // 分配失败
```
- 调用 `get_pte` 查找/创建对应的页表项
- 如果中间层页表分配失败，返回内存不足错误

### 2. 增加物理页引用计数
```c
page_ref_inc(page);  // 先增加引用，防止后续释放
```
- **预先增加**引用计数，防止在处理旧映射时误释放该页
- 如果后续发现重复映射同一页，会相应减少

### 3. 处理已存在的映射
```c
if (*ptep & PTE_V)  // 如果该虚拟地址已有映射
{
    struct Page *p = pte2page(*ptep);  // 获取旧物理页
    if (p == page)  // 情况1：重新映射到同一物理页
    {
        page_ref_dec(page);  // 撤销前面的 inc，保持计数不变
    }
    else  // 情况2：映射到不同物理页
    {
        page_remove_pte(pgdir, la, ptep);  // 移除旧映射
        // 这会减少旧页的引用计数，可能释放旧页
    }
}
```

**关键逻辑**：
- **情况1**（重映射同一页）：
  - 只是修改权限，物理页不变
  - 引用计数不应改变，所以 `page_ref_dec` 抵消前面的 `page_ref_inc`
  
- **情况2**（替换物理页）：
  - 调用 `page_remove_pte` 移除旧映射
  - 旧页引用计数减1，可能释放；新页引用计数已在步骤2增加

### 4. 设置新映射
```c
*ptep = pte_create(page2ppn(page), PTE_V | perm);
```
- `page2ppn(page)`：获取物理页号
- `PTE_V | perm`：有效位 + 用户指定的权限
- 将组合后的页表项写入 `*ptep`

### 5. 刷新TLB
```c
tlb_invalidate(pgdir, la);  // 使该虚拟地址的TLB缓存失效
return 0;
```
- TLB（Translation Lookaside Buffer）缓存了虚拟地址到物理地址的转换
- 修改页表后必须刷新 TLB，否则 CPU 仍使用旧的缓存映射
- `tlb_invalidate` 通过 `sfence.vma` 指令刷新

**核心思想**：
1. **先增后减**：先增加新页引用，处理完旧映射再调整，避免误释放
2. **原子性**：通过引用计数机制确保物理页在有映射时不被释放
3. **TLB一致性**：修改页表必须刷新TLB，保证硬件使用最新映射

**典型调用场景**：
```c
struct Page *p = alloc_page();
page_insert(boot_pgdir_va, p, 0x1000, PTE_U | PTE_W);  // 映射到用户空间，可读写
```

## page_remove() 和 page_remove_pte() - 移除虚拟地址映射

### page_remove_pte - 底层移除函数

```c
static inline void page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep)
{
    if (*ptep & PTE_V)  //(1) 检查页表项是否有效
    {
        struct Page *page = pte2page(*ptep);  //(2) 找到对应的物理页
        page_ref_dec(page);  //(3) 减少物理页引用计数
        if (page_ref(page) == 0)  //(4) 引用计数归零时释放物理页
        {
            free_page(page);
        }
        *ptep = 0;  //(5) 清空页表项
        tlb_invalidate(pgdir, la);  //(6) 刷新TLB
    }
}
```

**功能**：移除一个已知页表项指针对应的映射，并维护引用计数和 TLB 一致性。

**实现步骤**：

#### (1) 有效性检查
```c
if (*ptep & PTE_V)
```
- 只处理有效的页表项
- 无效项（V=0）表示未映射，无需处理

#### (2) 获取物理页
```c
struct Page *page = pte2page(*ptep);
```
- 从页表项中提取 PPN，转换为 `Page` 结构体指针
- 以便后续操作引用计数

#### (3) 减少引用计数
```c
page_ref_dec(page);
```
- 该虚拟地址不再映射此物理页，引用计数减1
- `page->ref--`

#### (4) 条件释放物理页
```c
if (page_ref(page) == 0)
    free_page(page);
```
- **关键机制**：只有引用计数归零时才释放物理页
- 允许多个虚拟地址映射同一物理页（共享内存）
- 最后一个映射移除时，物理页才被回收到空闲链表

#### (5) 清空页表项
```c
*ptep = 0;
```
- 将页表项设为 0（所有位都清零，包括 V 位）
- 后续访问该虚拟地址会触发缺页异常

#### (6) 刷新TLB
```c
tlb_invalidate(pgdir, la);
```
- TLB 可能缓存了该虚拟地址的旧映射
- 使用 `sfence.vma` 指令清除对应的 TLB 条目
- 确保 CPU 不会继续使用失效的映射

---

### page_remove - 上层接口

```c
void page_remove(pde_t *pgdir, uintptr_t la)
{
    pte_t *ptep = get_pte(pgdir, la, 0);  // 查找页表项（不创建）
    if (ptep != NULL)
    {
        page_remove_pte(pgdir, la, ptep);
    }
}
```

**功能**：通过虚拟地址移除映射的便捷接口。

**实现**：
1. **查找页表项**：`get_pte(pgdir, la, 0)`
   - `create=0` 表示不创建新页表
   - 如果中间层页表不存在，返回 NULL

2. **调用底层函数**：
   - 如果找到页表项，调用 `page_remove_pte` 执行实际移除
   - 如果未找到（返回 NULL），说明该地址未映射，无需操作

**对比两个函数**：
| 函数 | 参数 | 使用场景 |
|------|------|----------|
| `page_remove_pte` | 需要已知的 `ptep` 指针 | 内部调用，已有页表项指针 |
| `page_remove` | 只需虚拟地址 `la` | 外部接口，更方便 |

**典型调用**：
```c
// 移除虚拟地址 0x1000 的映射
page_remove(boot_pgdir_va, 0x1000);
```

---

### page_ref_dec() - 减少引用计数（pmm.h）

```c
static inline int page_ref_dec(struct Page *page)
{
    page->ref -= 1;
    return page->ref;
}
```

**功能**：将物理页的引用计数减1，并返回新值。

**实现**：
- 直接操作 `page->ref` 字段
- 返回减少后的值，方便调用者判断是否需要释放

**配套函数**：
```c
static inline int page_ref_inc(struct Page *page)
{
    page->ref += 1;
    return page->ref;
}

static inline int page_ref(struct Page *page)
{
    return page->ref;  // 只读取，不修改
}

static inline void set_page_ref(struct Page *page, int val)
{
    page->ref = val;  // 直接设置
}
```

**引用计数的意义**：
- **共享内存**：多个虚拟地址（或进程）可映射同一物理页
- **延迟释放**：只有所有映射都移除（ref=0）时才释放物理页
- **写时复制（COW）**：fork 时父子进程共享页面，ref>1 时才复制

**示例**：
```c
struct Page *p = alloc_page();  // ref = 0
set_page_ref(p, 1);             // ref = 1

page_insert(pgdir, p, 0x1000, 0);  // ref = 1（已在内部处理）
page_insert(pgdir, p, 0x2000, 0);  // ref = 2（两个虚拟地址映射同一页）

page_remove(pgdir, 0x1000);  // ref = 1（减1，但不释放）
page_remove(pgdir, 0x2000);  // ref = 0（减1后为0，free_page被调用）
```

**核心原则**：
1. **谁映射谁增加**：`page_insert` 增加引用
2. **谁移除谁减少**：`page_remove` 减少引用
3. **归零才释放**：`ref == 0` 时调用 `free_page`

## check_pgdir() 函数解析

该函数用于测试页表操作的正确性，包括页表项的插入、查询、权限设置和引用计数等。

### 函数完整代码与解释

```c
static void check_pgdir(void)
{
    size_t nr_free_store;
    nr_free_store = nr_free_pages();
    // 保存当前空闲页数量，用于最后检查是否有内存泄漏
```

#### 1. 基本检查
```c
    assert(npage <= KERNTOP / PGSIZE);
    assert(boot_pgdir_va != NULL && (uint32_t)PGOFF(boot_pgdir_va) == 0);
    // 确保页目录表存在且按页对齐（低12位为0）
    
    assert(get_page(boot_pgdir_va, 0x0, NULL) == NULL);
    // 虚拟地址0x0处应该没有映射
```

#### 2. 测试页表插入与查询
```c
    struct Page *p1, *p2;
    p1 = alloc_page();
    assert(page_insert(boot_pgdir_va, p1, 0x0, 0) == 0);
    // 将物理页p1映射到虚拟地址0x0，权限为0（仅内核可访问，只读）
```

**关键操作**：`page_insert` 会：
- 调用 `get_pte` 获取/创建对应的页表项
- 如有必要，自动分配中间层页表（三级页表结构）
- 设置页表项内容：PPN + 权限位
- 增加物理页的引用计数

```c
    pte_t *ptep;
    assert((ptep = get_pte(boot_pgdir_va, 0x0, 0)) != NULL);
    // 获取虚拟地址0x0对应的页表项指针（不创建新页表）
    
    assert(pte2page(*ptep) == p1);
    // 验证该页表项指向的物理页确实是p1
    
    assert(page_ref(p1) == 1);
    // p1的引用计数应为1
```

#### 3. 验证页表项地址计算
```c
    ptep = (pte_t *)KADDR(PDE_ADDR(boot_pgdir_va[0]));
    // boot_pgdir_va[0] 是一级页目录项，指向二级页表
    // PDE_ADDR 提取其物理地址，KADDR 转为内核虚拟地址
    
    ptep = (pte_t *)KADDR(PDE_ADDR(ptep[0])) + 1;
    // ptep[0] 是二级页目录项，指向三级页表
    // +1 得到三级页表中索引为1的项
    
    assert(get_pte(boot_pgdir_va, PGSIZE, 0) == ptep);
    // 虚拟地址 PGSIZE(4096) 对应的页表项应该就是上面计算出的 ptep
    // 因为 PGSIZE 的 PDX1=0, PDX0=0, PTX=1
```

**知识点**：手工遍历三级页表结构验证 `get_pte` 的正确性。

#### 4. 测试用户权限位传播
```c
    p2 = alloc_page();
    assert(page_insert(boot_pgdir_va, p2, PGSIZE, PTE_U | PTE_W) == 0);
    // 映射p2到虚拟地址PGSIZE，设置用户可访问(U)和可写(W)权限
    
    assert((ptep = get_pte(boot_pgdir_va, PGSIZE, 0)) != NULL);
    assert(*ptep & PTE_U);
    assert(*ptep & PTE_W);
    // 验证页表项包含正确的权限位
    
    assert(boot_pgdir_va[0] & PTE_U);
    // 重要：验证一级页目录项也被设置了PTE_U位
    // 这是因为RISC-V要求权限位在整条路径上传播
```

**知识点**：Sv39 要求从根页表到叶子页表的整条路径都要有 `PTE_U` 位，否则用户态无法访问。

```c
    assert(page_ref(p2) == 1);
    // p2的引用计数为1
```

#### 5. 测试页面替换与引用计数
```c
    assert(page_insert(boot_pgdir_va, p1, PGSIZE, 0) == 0);
    // 将虚拟地址PGSIZE重新映射到p1（覆盖原来的p2映射）
    
    assert(page_ref(p1) == 2);
    // p1现在被两个虚拟地址映射（0x0 和 PGSIZE），引用计数为2
    
    assert(page_ref(p2) == 0);
    // p2被自动释放，引用计数归0
    
    assert((ptep = get_pte(boot_pgdir_va, PGSIZE, 0)) != NULL);
    assert(pte2page(*ptep) == p1);
    // 验证PGSIZE现在映射到p1
    
    assert((*ptep & PTE_U) == 0);
    // 新的映射权限为0，不包含PTE_U位
```

**知识点**：`page_insert` 会自动处理旧映射的释放，正确维护引用计数。

#### 6. 测试页面移除
```c
    page_remove(boot_pgdir_va, 0x0);
    // 移除虚拟地址0x0的映射
    assert(page_ref(p1) == 1);
    // p1引用计数减1
    assert(page_ref(p2) == 0);
    
    page_remove(boot_pgdir_va, PGSIZE);
    // 移除虚拟地址PGSIZE的映射
    assert(page_ref(p1) == 0);
    // p1引用计数归0，物理页被自动释放
    assert(page_ref(p2) == 0);
```

#### 7. 清理中间页表并检查内存泄漏
```c
    assert(page_ref(pde2page(boot_pgdir_va[0])) == 1);
    // 一级页表项指向的二级页表页面引用计数为1
    
    pde_t *pd1 = boot_pgdir_va, *pd0 = page2kva(pde2page(boot_pgdir_va[0]));
    // pd1: 一级页表，pd0: 二级页表
    
    free_page(pde2page(pd0[0]));
    // 释放三级页表页面
    free_page(pde2page(pd1[0]));
    // 释放二级页表页面
    
    boot_pgdir_va[0] = 0;
    // 清空一级页表第0项
    flush_tlb();
    // 刷新TLB
    
    assert(nr_free_store == nr_free_pages());
    // 验证空闲页数量恢复，无内存泄漏
    
    cprintf("check_pgdir() succeeded!\n");
}
```

### 核心知识点总结

1. **三级页表遍历**：虚拟地址 → 一级页表 → 二级页表 → 三级页表 → 物理页
2. **权限位传播**：用户态访问需要整条路径的 `PTE_U` 位都设置
3. **引用计数管理**：多个虚拟地址可映射同一物理页，通过引用计数自动释放
4. **页表自动分配**：`page_insert`/`get_pte` 自动创建缺失的中间层页表
5. **TLB 一致性**：修改页表后必须刷新 TLB（通过 `sfence.vma` 指令）


