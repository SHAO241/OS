
## 进程状态

1. **PROC_UNINIT：** 这个状态表示进程刚刚被分配相应的进程控制块，但还没有初始化，需要进一步的初始化才能进入PROC_RUNNABLE的状态。
2. **PROC_SLEEPING：** 这个状态表示进程正在等待某个事件的发生，通常由于等待锁的释放，或者主动交出CPU资源（do_sleep）。这个状态下的进程是不会被调度的。
3. **PROC_RUNNABLE：** 这个状态表示进程已经准备好要执行了，只需要操作系统给他分配相应的CPU资源就可以运行。
4. **PROC_ZOMBIE：** 这个状态表示进程已经退出，相应的资源被回收（大部分），almost dead。

### 进程生命周期

1. 刚刚开始初始化，进程处在PROC_UNINIT的状态

2. 进程已经完成初始化，时刻准备执行，进入PROC_RUNNABLE状态

3. 在调度的时候，调度器选中该进程进行执行，进程处在running的状态

**4.(1)**  正在运行的进程由于wait等系统调用被阻塞，进入PROC_SLEEPING，等待相应的资源或者信号。

**4.(2)**  另一种可能是正在运行的进程被外部中断打断，此时进程变为PROC_RUNNABLE状态，等待下次被调用

5. 等待的事件发生，进程又变成PROC_RUNNABLE状态

6. 重复3~6，直到进程执行完毕，通过exit进入PROC_ZOMBIE状态，由父进程对他的资源进行回收，释放进程控制块。至此，这个进程的生命周期彻底结束

## 进程切换

### 进程切换究竟在什么情况下会发生？

**主动调度** 与 **被动调度**

#### 主动调度

进程自愿放弃 CPU。

**典型情况包括：**

1. 进程主动放弃当前的CPU资源，显式调用 `wait`、`sleep` 等接口表示自己需要等待；

2. 进程尝试获取某个不可用的资源（比如尝试获得未被释放的锁，或进行磁盘I/O操作的时候），因此必须阻塞；

3. 内核线程在执行过程中基于逻辑需要显式调用 `schedule。`


在 ucore 中，由于**内核线程**是**不可抢占**的，它们无法被其他内核线程强行打断，因此必须依靠这种**主动让出 CPU 的方式**来**避免死锁**，维持系统整体的可调度性。




| 函数            | 原因                                         |
|-----------------|----------------------------------------------|
| proc.c/do_exit  | 用户进程退出，主动放弃 CPU                   |
| proc.c/do_wait  | 用户进程等待，主动放弃 CPU                   |
| proc.c/init_main| init线程等待其他用户线程结束，并调度 kswapd 执行 |
| proc.c/cpu_idle | idle线程等待就绪线程，必要时主动调用 schedule |
| sync.c/lock     | 获取锁失败时主动进入等待                     |


#### 被动调度


被动调度主要通过两类途径完成：

1. **系统调用陷入内核态。**
用户进程在执行系统调用时会通过 ecall 进入内核态。虽然这是由用户显式触发的，但从调度角度看此时进程并没有主动想放弃 CPU，因此属于被动调度的触发点。内核在系统调用返回前会检查调度标记，从而决定是否切换到其他就绪进程。


2. **外部中断（比如时钟中断）将用户态打断。**
用户进程在正常执行过程中可能被外部硬件中断打断，其中最关键的是时钟中断。时钟中断使内核能够周期性获得控制权，用于更新时间片并在必要时触发抢占，以保证用户进程不会无限运行下去。

无论是哪一种情况，用户进程都会通过 `trap` 机制进入内核态。


进入 trap 时，硬件会首先保存用户态的中断帧，CPU 切换到内核态并执行相应的中断或系统调用的处理函数。在处理完这些 trap 逻辑之后，内核会统一检查当前进程是否应当调度，比如时间片是否用尽或是否已被标记为需要调度。如果满足条件，内核便保存当前进程 A 的内核态上下文，切换到进程 B 的内核态。之后 B 将从内核态返回到用户态继续执行。如果将来 B 再次陷入 trap 并触发调度，则控制权可能重新回到 A，使得 A 能从先前的内核态继续执行并最终返回用户态。

```
用户态进程A运行
	|
	v
-----------------------------
|  trap触发（系统调用/中断） |
-----------------------------
	|
	v
硬件保存用户态上下文
	|
	v
CPU切换到内核态
	|
	v
内核处理trap逻辑
	|
	v
检查是否需要调度
	|
	v
-----------------------------
|  是：保存A的内核态上下文   |
-----------------------------
	|
	v
切换到进程B的内核态
	|
	v
进程B从内核态返回用户态继续执行
	|
	v
-----------------------------
|  B再次trap时可切回A        |
-----------------------------
	|
	v
A恢复内核态->用户态继续执行
```


## 调度算法框架

### 调度算法结构体

```c
struct sched_class {
    // 调度类的名字
    const char *name;

    // 初始化run queue
    void (*init)(struct run_queue *rq);
    // init 是函数指针，指向一个初始化 run_queue 的 函数

    // 把进程放进run queue，这个是run queue的维护函数
    void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);
    // enqueue 是一个函数指针，接收两个参数：run_queue的指针 rq 和 proc_struct 结构体指针 proc, 把进程proc插进队列run_queue中


    // 把进程取出run queue
    void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);
    // 和 enqueue 类似，功能相反
    
    
    // 选择下一个要执行的进程
    struct proc_struct *(*pick_next)(struct run_queue *rq);
    // pick_next 是一个函数指针，接收参数是run_queue结构体的指针 rq, 返回proc_struct 结构体指针，表示从run_queue中取出一个proc_struct
    
    
    // 每次时钟中断调用
    // proc_tick 是一个时钟滴答处理函数指针。每当发生时钟中断时，调度器会调用该函数，用于更新当前进程的时间片、判断是否需要抢占、设置进程的调度标记等。
    // 典型用途：
    //   - 对于时间片轮转（RR）调度，proc_tick 会递减当前进程的 time_slice，当用尽时设置 need_resched 标记，触发调度。
    //   - 对于优先级、stride等调度算法，也可在此更新调度相关的统计信息。

    void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);
};
```


所有的进程被组织成一个 `run_queue` 数据结构。目前ucore仅支持单个CPU核心，所以只有一个全局的 `run_queue` 。


#### struct proc_struct
```c
struct proc_struct
{
    enum proc_state state;                  // Process state
    int pid;                                // Process ID
    int runs;                               // the running times of Proces
    uintptr_t kstack;                       // Process kernel stack
    volatile bool need_resched;             // bool value: need to be rescheduled to release CPU?
    struct proc_struct *parent;             // the parent process
    struct mm_struct *mm;                   // Process's memory management field
    struct context context;                 // Switch here to run process
    struct trapframe *tf;                   // Trap frame for current interrupt
    uintptr_t pgdir;                        // the base addr of Page Directroy Table(PDT)
    uint32_t flags;                         // Process flag
    char name[PROC_NAME_LEN + 1];           // Process name
    list_entry_t list_link;                 // Process link list
    list_entry_t hash_link;                 // Process hash list
    int exit_code;                          // exit code (be sent to parent proc)
    uint32_t wait_state;                    // waiting state
    struct proc_struct *cptr, *yptr, *optr; // relations between processes
    struct run_queue *rq;                   // running queue contains Process
    list_entry_t run_link;                  // the entry linked in run queue
    int time_slice;                         // time slice for occupying the CPU
    skew_heap_entry_t lab6_run_pool;        // FOR LAB6 ONLY: the entry in the run pool
    uint32_t lab6_stride;                   // FOR LAB6 ONLY: the current stride of the process
    uint32_t lab6_priority;                 // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)
};
```

`proc_struct` 是内核中用于描述进程（或线程）的核心数据结构。其主要成员说明如下：

- `enum proc_state state`：进程当前的状态（如UNINIT、SLEEPING、RUNNABLE、ZOMBIE）。
- `int pid`：进程ID。
- `int runs`：该进程被调度运行的次数。
- `uintptr_t kstack`：内核栈的起始地址。
- `volatile bool need_resched`：是否需要被调度（抢占/主动让出CPU时置1）。
- `struct proc_struct *parent`：父进程指针。
- `struct mm_struct *mm`：进程的内存管理结构体。
- `struct context context`：保存进程切换时的寄存器上下文。
- `struct trapframe *tf`：陷入内核时保存的寄存器快照。
- `uintptr_t pgdir`：页目录表物理地址。
- `uint32_t flags`：进程标志位。
- `char name[PROC_NAME_LEN + 1]`：进程名。
- `list_entry_t list_link`：用于将进程挂入全局进程链表。
- `list_entry_t hash_link`：用于哈希表加速查找。
- `int exit_code`：进程退出码。
- `uint32_t wait_state`：等待状态。
- `struct proc_struct *cptr, *yptr, *optr`：子进程/兄弟进程链表指针。
- `struct run_queue *rq`：指向所在的运行队列。
- `list_entry_t run_link`：用于挂入run_queue的链表节点。
- `int time_slice`：该进程当前剩余的时间片。
- `skew_heap_entry_t lab6_run_pool`：LAB6专用，斜堆节点。
- `uint32_t lab6_stride`：LAB6专用，stride调度算法步长。
- `uint32_t lab6_priority`：LAB6专用，进程优先级。

`proc_struct` 记录了进程的所有核心信息，包括调度、内存、父子关系、切换上下文等，是进程管理的基础。

#### struct run_queue
```c
struct run_queue
{
    list_entry_t run_list;
    unsigned int proc_num;
    int max_time_slice;
    // For LAB6 ONLY
    skew_heap_entry_t *lab6_run_pool;
};
```
`run_queue` 是调度器维护的就绪队列结构体，主要成员说明如下：

- `list_entry_t run_list`：就绪进程链表头。
- `unsigned int proc_num`：队列中进程数量。
- `int max_time_slice`：分配给每个进程的最大时间片。
- `skew_heap_entry_t *lab6_run_pool`：LAB6专用，指向斜堆根节点，用于stride等调度算法。

`run_queue` 负责管理所有处于RUNNABLE状态、等待CPU调度的进程集合。调度器通过它进行进程的插入、移除和选择下一个运行进程。


### sched.c 详解


#### 1. 调度类接口封装 (Wrapper Functions)

这部分代码是对具体调度算法（如 Round Robin）的抽象封装，屏蔽了底层实现细节。

```c
// [入队] 将进程加入就绪队列
static inline void
sched_class_enqueue(struct proc_struct *proc)
{
    // 只有非 idleproc (空闲进程) 才需要进入调度队列
    // idleproc 是系统无事可做时的兜底，不参与正常排队
    if (proc != idleproc)
    {
        // 调用具体的调度算法（如 round_robin_enqueue）将进程加入 rq (run_queue)
        sched_class->enqueue(rq, proc);
    }
}

// [出队] 将进程从就绪队列移除
static inline void
sched_class_dequeue(struct proc_struct *proc)
{
    // 当进程被选中运行，或被移动到其他队列时调用
    sched_class->dequeue(rq, proc);
}

// [挑选] 询问调度器下一个运行谁
static inline struct proc_struct *
sched_class_pick_next(void)
{
    // 返回就绪队列中最适合运行的下一个进程指针
    return sched_class->pick_next(rq);
}

// [时钟滴答] 时钟中断时的处理
void sched_class_proc_tick(struct proc_struct *proc)
{
    if (proc != idleproc)
    {
        // 普通进程：调用算法更新其时间片 (time_slice)，可能触发重调度标记
        sched_class->proc_tick(rq, proc);
    }
    else
    {
        // 如果当前是 idleproc，说明 CPU 很空闲
        // 此时一旦有时钟中断（意味着可能发生了其他事件），立即标记需要调度
        // 这样可以立刻检查是否有新唤醒的进程，避免 idleproc 占用太久
        proc->need_resched = 1;
    }
}

```

---

#### 2. 调度子系统初始化 (Initialization)

```c
static struct run_queue __rq; // 静态分配的全局运行队列实例

void sched_init(void)
{
    list_init(&timer_list);          // 初始化系统定时器链表

    sched_class = &default_sched_class; // 绑定默认调度策略（通常是 Round Robin）

    rq = &__rq;                      // 初始化运行队列指针
    rq->max_time_slice = MAX_TIME_SLICE; // 设置系统允许的最大时间片
    sched_class->init(rq);           // 调用具体算法的初始化函数

    cprintf("sched class: %s\n", sched_class->name); // 打印当前调度器名称
}

```

---

#### 3. 唤醒进程 (Wake up)

将进程从“阻塞/等待”状态变为“就绪/可运行”状态。

```c
void wakeup_proc(struct proc_struct *proc)
{
    assert(proc->state != PROC_ZOMBIE); // 确保不唤醒僵尸进程
    
    bool intr_flag;
    local_intr_save(intr_flag); // 【关键】关中断，保证原子性，防止操作队列时被打断
    {
        // 只有当前不处于 RUNNABLE 状态才需要唤醒
        if (proc->state != PROC_RUNNABLE)
        {
            proc->state = PROC_RUNNABLE; // 1. 修改状态为“就绪”
            proc->wait_state = 0;        // 2. 清除等待原因标记
            
            // 3. 将其加入调度队列
            // 注意：通常唤醒的是别的进程，如果是自己唤醒自己(极少见)则不需要入队
            if (proc != current)
            {
                sched_class_enqueue(proc);
            }
        }
        else
        {
            warn("wakeup runnable process.\n"); // 警告：试图唤醒一个已经在跑的进程
        }
    }
    local_intr_restore(intr_flag); // 恢复中断状态
}

```

---

### 4. 核心调度函数 (Schedule)

这是操作系统的核心心脏，决定 CPU 下一刻归谁使用。

```c
void schedule(void)
{
    bool intr_flag;
    struct proc_struct *next;
    
    local_intr_save(intr_flag); // 【关键】全程关中断，调度过程必须独占 CPU，不可被打断
    {
        current->need_resched = 0; // 清除当前进程的“需要调度”标记
        
        // --- 步骤 1: 处理当前进程 (Current) ---
        // 如果 current 状态仍是 RUNNABLE，说明它是被抢占的（如时间片用完）
        // 而不是主动阻塞（如等待IO，那时状态会变成 SLEEPING）
        // 所以需要把它重新放回队列末尾，等待下一次轮号
        if (current->state == PROC_RUNNABLE)
        {
            sched_class_enqueue(current);
        }

        // --- 步骤 2: 挑选下一个进程 (Next) ---
        // 尝试从队列中取出一个最合适的进程
        if ((next = sched_class_pick_next()) != NULL)
        {
            // 如果找到了，把它从就绪队列里拿出来（因为它马上要变成 Running 了）
            sched_class_dequeue(next);
        }

        // --- 步骤 3: 兜底逻辑 ---
        // 如果队列是空的（next 为 NULL），说明没有进程想运行
        // 这时必须运行 idleproc（空闲进程）来让 CPU 空转
        if (next == NULL)
        {
            next = idleproc;
        }

        next->runs++; // 统计该进程运行次数

        // --- 步骤 4: 执行切换 ---
        // 只有当选出的进程不是当前进程时，才进行上下文切换
        // 避免无意义的自我切换开销
        if (next != current)
        {
            proc_run(next); // 汇编级操作：切换内核栈、页表(CR3)，跳转指令流
        }
    }
    local_intr_restore(intr_flag); // 恢复中断
}

```

## RR 调度算法

当一个进程运行够了其最大运行时间片那么长的时间后，调度器会把它标记为需要调度，并且把它的进程控制块放在队尾，重置其时间片。

没有区分不同进程的优先级。

这是**时间片轮转调度算法 (Round Robin, RR)** 的具体实现代码。

RR 算法的核心思想是让所有可运行的进程轮流使用 CPU，每个进程分配一个固定的时间片（Time Slice）。当时间片用完时，强制剥夺 CPU 并放回队列尾部。



#### 1. 运行队列初始化 (Initialization)

初始化运行队列结构体，确保链表头指向自己，计数器清零。

```c
/*
 * RR_init: 初始化运行队列 rq
 * 设置 run_list 为空链表，proc_num 置 0
 */
static void
RR_init(struct run_queue *rq)
{
    // LAB6: 2312991
    
    // 初始化链表头节点 (prev 和 next 都指向自己)
    list_init(&rq->run_list);
    
    // 初始化进程计数器
    rq->proc_num = 0;
    
    // 初始化内存池指针 (可能是 Lab 特定需求，置空)
    rq->lab6_run_pool = NULL;
}

```

---

#### 2. 进程入队 (Enqueue)

当进程变为 Ready 状态（被唤醒）或时间片用完被抢占时，调用此函数将其加入队列**尾部**。

```c
/*
 * RR_enqueue: 将进程 proc 加入到运行队列 rq 的队尾
 * 1. 重置进程的时间片
 * 2. 将节点插入链表
 * 3. 更新队列元数据
 */
static void
RR_enqueue(struct run_queue *rq, struct proc_struct *proc)
{
    // LAB6: 2312991
    
    // 【关键】重置时间片
    // 每次进入就绪队列，都恢复其时间片为系统最大值 (max_time_slice)
    // 这样当它下次被调度时，又有满满的时间片可用
    proc->time_slice = rq->max_time_slice;
    
    // 记录该进程当前所属的运行队列
    proc->rq = rq;
    
    // 【关键】加入队尾
    // list_add_before 在头节点(run_list)之前插入，
    // 在双向循环链表中，head 的前一个节点就是 tail。
    list_add_before(&rq->run_list, &proc->run_link);
    
    // 队列进程数 +1
    rq->proc_num++;
}

```

---

#### 3. 进程出队 (Dequeue)

当进程被调度器选中（变成 Running）或者进程退出/阻塞时，将其从就绪队列移除。

```c
/*
 * RR_dequeue: 将进程 proc 从运行队列 rq 中移除
 */
static void
RR_dequeue(struct run_queue *rq, struct proc_struct *proc)
{
    // LAB6: 2312991
    
    // 从链表中删除该节点，并将其重新初始化 (prev/next 指向自己)
    list_del_init(&proc->run_link);
    
    // 维护队列计数器
    if (rq->proc_num > 0)
    {
        rq->proc_num--;
    }
    
    // 解除进程与队列的绑定关系
    proc->rq = NULL;
}

```

---

#### 4. 挑选下一个进程 (Pick Next)

RR 算法的核心调度策略：**先进先出 (FIFO)**。总是选择队列头部的进程。

```c
/*
 * RR_pick_next: 从运行队列队头选择一个进程
 * 返回对应的进程结构体指针，若队列为空则返回 NULL
 */
static struct proc_struct *
RR_pick_next(struct run_queue *rq)
{
    // LAB6: 2312991
    
    // 如果队列为空，没有进程可选
    if (list_empty(&rq->run_list))
    {
        return NULL;
    }
    
    // 获取链表的第一个节点 (head 的 next)
    // 这是一个 list_entry_t 指针
    list_entry_t *le = list_next(&rq->run_list);
    
    // 【关键】使用宏 le2proc 将链表节点转换为进程结构体指针
    // le2proc 利用 offsetof 原理，根据成员变量地址反推结构体首地址
    return le2proc(le, run_link);
}

```

---

#### 5. 时钟滴答处理 (Proc Tick)

每一次时钟中断（Tick）都会调用此函数，用于扣减当前进程的时间片。这是实现**抢占 (Preemption)** 的关键。

```c
/*
 * RR_proc_tick: 处理时钟中断事件
 * 检查当前进程时间片是否耗尽，若耗尽则标记需要调度
 */
static void
RR_proc_tick(struct run_queue *rq, struct proc_struct *proc)
{
    // LAB6: 2312991
    
    // 如果时间片还没用完，就减 1
    if (proc->time_slice > 0)
    {
        proc->time_slice--;
    }
    
    // 如果减完之后变成 0 了
    if (proc->time_slice == 0)
    {
        // 【关键】标记需要调度 (need_resched)
        // 内核会在适当的时候（如中断返回前）检查这个标志
        // 如果为 1，就会调用 schedule() 函数，把当前进程踢下去，
        // 从而实现“时间片轮转”。
        proc->need_resched = 1;
    }
}

```






