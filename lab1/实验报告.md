# 练习1：理解内核启动中的程序入口操作

## 代码注释说明
```c
// 包含与内存管理单元 (MMU) 和内存布局相关的宏定义
#include <mmu.h>
#include <memlayout.h>

    // ------------------------------------------------------------------
    // 内核代码段 (.text)
    // ------------------------------------------------------------------
    // 将以下代码放入 .text section (可执行代码段)
    // "ax" 标志表示该段是可分配(a)和可执行(x)的
    .section .text,"ax",%progbits
    
    // 将 kern_entry 声明为全局符号，使其对链接器可见。
    // 这是内核的入口点，Bootloader 会跳转到这里。
    .globl kern_entry
kern_entry:
    // `la` 是 `load address` 的缩写。
    // 该指令将 bootstacktop 的内存地址加载到 sp (stack pointer) 寄存器中。
    // 这是为即将运行的 C 代码初始化内核栈的关键一步，因为 C 函数的执行依赖于栈。
    // 栈是向下增长的，所以 sp 需要被初始化为栈空间的最高地址。
    la sp, bootstacktop

    // `tail` 是一种优化的跳转（尾调用）。
    // 它直接跳转到 kern_init 函数（在 init.c 中定义），且不会在栈上保存返回地址。
    // 这是因为 kern_init 函数永远不会返回到 kern_entry。
    // 这条指令标志着从汇编环境到 C 环境的转换。
    tail kern_init

    // ------------------------------------------------------------------
    // 内核数据段 (.data)
    // ------------------------------------------------------------------
.section .data
    // `.align PGSHIFT` 确保接下来的 `bootstack` 地址按页对齐。
    // PGSHIFT 通常是 12，所以这是按 2^12 = 4096 字节对齐。
    // 页对齐是良好的内存管理实践。
    .align PGSHIFT
    
    // 将 bootstack 声明为全局符号。
    .global bootstack
bootstack:
    // `.space` 指令用于在内存中保留一块空间。
    // 这里为内核的初始栈分配了 KSTACKSIZE 大小的空间（通常是 1-2 个页的大小）。
    // `bootstack` 标签指向这块空间的起始（低）地址。
    .space KSTACKSIZE
    
    // 将 bootstacktop 声明为全局符号。
    .global bootstacktop
bootstacktop:
    // `bootstacktop` 标签指向刚刚分配的栈空间的末尾（高）地址。
    // 这个地址就是栈顶，将被加载到 sp 寄存器中作为初始栈指针。
```


## 内核启动流程
在运行entry.S之前，已经完成了OpenSBI初始化和内核加载，OpenSBI将编译生成的内核镜像文件加载到物理内存的0x80200000地址处。最后开始内核启动执行，OpenSBI 完成相关工作，跳转到0x80200000地址，开始执行kern/init/entry.S。

## la sp, bootstacktop说明

la 是一个伪指令，它的作用是将bootstacktop的内存地址加载到目标寄存器sp中，bootstacktop指向 .data 段中定义的一块内存区域的末尾。

### 作用

这条指令的目的是初始化内核的第一个栈。这是内核能够从汇编代码过渡到C语言编写的内核初始化函数的执行的关键前提。我们写C语言的时候，默认栈是已经准备好了，但是实际上栈不会凭空出现，它必须从某个地方开始，因此需要初始化栈。

## tail kern_init说明

tail 指令是一个优化的跳转指令，它的作用是直接跳转到kern_init函数，而不在栈上保存返回地址。
### 作用

tail kern_init指令的作用是从汇编环境到C环境的转换，它告诉编译器，接下来要执行的指令是kern_init函数，并且不在栈上保存返回地址。


## 实验中遇到的问题

#### tail kern_init之后就跳转到kern_init函数了，为什么还会执行这些语句呢？

#### 回答
这部分数据定义永远不会被CPU当作指令来“执行”，但它们在编译和链接阶段就已经被处理并安排好了。

当编内核时，工具链（汇编器 as 和链接器 ld）会读取整个 entry.S 文件，从第一行到最后一行。它的工作不是“执行”代码，而是构建一个可执行的内核镜像文件。

**1.读取 .text 部分：**
汇编器读到 .section .text，它知道这是可执行代码区域

它读到 la sp, bootstacktop。这时它可能还不知道 bootstacktop 的确切地址，但它会记下这个符号。

它读到 tail kern_init，记下这个函数。

**2.读取 .data 部分**
汇编器读到 .section .data，它知道这是数据区域

它读到 .align PGSHIFT。这条指令告诉汇编器，接下来要分配的内存区域（bootstack）需要按页对齐。    

    .........

在这个阶段结束时，一张完整的蓝图（内核镜像文件）就生成了。蓝图上同时包含了代码区（.text）和数据区（.data）。并且，之前在 .text 部分悬而未决的 bootstacktop 的地址，现在也因为 .data 部分的设计完成了而被精确地确定了下来。


#### 为内核准备的初始栈,范围是什么？

#### 回答
这个为内核准备的初始栈，就是由 bootstack 和 bootstacktop 这两个标签所界定的那一块连续的内存区域。

`bootstack`是这块内存区域的 起始地址（低地址）。`bootstacktop`是这块内存区域的 结束地址（高地址）。这块区域的大小由 `.space KSTACKSIZE` 决定。
```
      高地址  +------------------+  <-- bootstacktop (sp 初始指向这里)
              |                  |
              |   可用栈空间     |
              |  (KSTACKSIZE)    |
              |      |           |
              |      |           |  <-- 随着数据入栈, sp 向下移动
              |      V           |
              |                  |
      低地址  +------------------+  <-- bootstack (栈的底部界限)
```

#### 为内核准备的栈的大小KSTACKSIZE是多少？

#### 回答
在memlayout.h文件中有
```c
#define KSTACKSIZE          (KSTACKPAGE * PGSIZE)
```
在mmu.h文件中有
```c
#define PGSIZE              4096
```
所以KSTACKSIZE等于8K。

#### 谁把OpenSBI.bin 加载到物理内存以物理地址 0x80000000 开头的区域上？

#### 回答

在QEMU模拟的这款riscv处理器中，将复位向量地址初始化为0x1000，再将PC初始化为该复位地址，因此处理器将从此处开始执行复位代码，复位代码主要是将计算机系统的各个组件（包括处理器、内存、设备等）置于初始状态，并且会启动Bootloader，在这里QEMU的复位代码指定加载Bootloader的位置为0x80000000，Bootloader将加载操作系统内核并启动操作系统的执行。


之后OpenSBI会将内核镜像 os.bin 加载到 Qemu 物理内存以地址 0x80200000 开头的区域上，并将CPU的控制权交给操作系统。


#### 格式化输出在哪一态，为什么？
#### 回答

因为格式化输出是在硬件层面，所以是固件，应该是在M态




------------------------------------

# 练习2: 使用GDB验证启动流程

首先我们验证我们的环境配置正确，实验代码可以正常运行：

![img1](assets\img1.png)

随后我们使用GDB远程连接QEMU进行调试：

![img2](assets\img2.png)

![img3](assets\img3.png)

确保链接上QEMU的CPU之后我们可以进行单步调试，

```c
(gdb) x/10i $pc                   
=> 0x1000:	auipc	t0,0x0
   0x1004:	addi	a1,t0,32
   0x1008:	csrr	a0,mhartid
   0x100c:	ld	t0,24(t0)
   0x1010:	jr	t0
   0x1014:	unimp
   0x1016:	unimp
   0x1018:	unimp
   0x101a:	.insn	2, 0x8000
   0x101c:	unimp

    //理论上，我们应该通过断点获得入口的位置，但是实验文档已经有所提及入口的具体位置，也提供了跳转的代码
    //因此我们后面选择了直接跳转

(gdb) si
0x0000000000001004 in ?? ()
(gdb) info r t0
t0             0x1000	4096
(gdb) si       
0x0000000000001008 in ?? ()
(gdb) info r t0
t0             0x1000	4096
(gdb) si       
0x000000000000100c in ?? ()
(gdb) info r t0
t0             0x1000	4096
(gdb) si
0x0000000000001010 in ?? ()
(gdb) info r t0
t0             0x80000000	2147483648

//这个0x80000000还是从0x00001008处取回来的值

```

由于实验文档里面提及了我们要的代码在0x80200000以及后面的5条，我们直接进行了跳转
对于kern_entry的代码放在下面：

![img4](assets\img4.png)

我们重点看0x8020000处的代码，我们注意到，在kern_init处设置断点之后我们运行程序，OpenSBI不会完整运行：

![img5](assets\img5.png)

可以看到进行了硬件初始化和内存保护设置，尚未开始加载内核（继续运行才会出现）

```c
(gdb) x/5i 0x80200000
   0x80200000 <kern_entry>:	auipc	sp,0x3
   0x80200004 <kern_entry+4>:	mv	sp,sp
   0x80200008 <kern_entry+8>:	j	0x8020000a <kern_init>
   0x8020000a <kern_init>:	auipc	a0,0x3
   0x8020000e <kern_init+4>:	addi	a0,a0,-2
```

我们设置断点并且继续运行：
```c
(gdb) disassemble kern_init
Dump of assembler code for function kern_init:
=> 0x000000008020000a <+0>:	auipc	a0,0x3
   0x000000008020000e <+4>:	addi	a0,a0,-2 # 0x80203008
   0x0000000080200012 <+8>:	auipc	a2,0x3
   0x0000000080200016 <+12>:	addi	a2,a2,-10 # 0x80203008
   0x000000008020001a <+16>:	addi	sp,sp,-16
   0x000000008020001c <+18>:	li	a1,0
   0x000000008020001e <+20>:	sub	a2,a2,a0
   0x0000000080200020 <+22>:	sd	ra,8(sp)
   0x0000000080200022 <+24>:	jal	0x802004b6 <memset>
   0x0000000080200026 <+28>:	auipc	a1,0x0
   0x000000008020002a <+32>:	addi	a1,a1,1186 # 0x802004c8
   0x000000008020002e <+36>:	auipc	a0,0x0
   0x0000000080200032 <+40>:	addi	a0,a0,1210 # 0x802004e8
   0x0000000080200036 <+44>:	jal	0x80200056 <cprintf>
   0x000000008020003a <+48>:	j	0x8020003a <kern_init+48>
End of assembler dump.
```

其中指的关注的是：在这段汇编代码的结尾有一个死循环：“j	0x8020003a”会持续跳转自身
因此我们在内核加载开始之后会重复看到新的一条：

![img6](assets\img6.png)

我之前用Ctrl+C不能强制终结，还怀疑是不是因为哪里出了岔子，后面发现死循环就释然了

为了进行实验验证，我打开了两个终端，这里我们只用GDB调试所用终端的内容：
以展示完整操作流程
```c

user@user-virtual-machine:~/Desktop/lab1$ PATH="$HOME/riscv/bin:$PATH" make gdb
riscv64-unknown-elf-gdb \
    -ex 'file bin/kernel' \
    -ex 'set arch riscv:rv64' \
    -ex 'target remote localhost:1234'
GNU gdb (GDB) 16.3.90.20250610-git
Copyright (C) 2024 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "--host=x86_64-pc-linux-gnu --target=riscv64-unknown-elf".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word".
Reading symbols from bin/kernel...
The target architecture is set to "riscv:rv64".
could not connect: Connection timed out.
(gdb) 
(gdb) target remote localhost:1234
Remote debugging using localhost:1234
0x0000000000001000 in ?? ()
(gdb) x/10i $pc                   
=> 0x1000:	auipc	t0,0x0
   0x1004:	addi	a1,t0,32
   0x1008:	csrr	a0,mhartid
   0x100c:	ld	t0,24(t0)
   0x1010:	jr	t0
   0x1014:	unimp
   0x1016:	unimp
   0x1018:	unimp
   0x101a:	.insn	2, 0x8000
   0x101c:	unimp
(gdb) si
0x0000000000001004 in ?? ()
(gdb) info r t0
t0             0x1000	4096
(gdb) si       
0x0000000000001008 in ?? ()
(gdb) info r t0
t0             0x1000	4096
(gdb) si       
0x000000000000100c in ?? ()
(gdb) info r t0
t0             0x1000	4096
(gdb) si
0x0000000000001010 in ?? ()
(gdb) info r t0
t0             0x80000000	2147483648
(gdb) x/10i 0x80000000
   0x80000000:	csrr	a6,mhartid
   0x80000004:	bgtz	a6,0x80000108
   0x80000008:	auipc	t0,0x0
   0x8000000c:	addi	t0,t0,1032
   0x80000010:	auipc	t1,0x0
   0x80000014:	addi	t1,t1,-16
   0x80000018:	sd	t1,0(t0)
   0x8000001c:	auipc	t0,0x0
   0x80000020:	addi	t0,t0,1020
   0x80000024:	ld	t0,0(t0)
(gdb) x/5i 0x80200000
   0x80200000 <kern_entry>:	auipc	sp,0x3
   0x80200004 <kern_entry+4>:	mv	sp,sp
   0x80200008 <kern_entry+8>:	j	0x8020000a <kern_init>
   0x8020000a <kern_init>:	auipc	a0,0x3
   0x8020000e <kern_init+4>:	addi	a0,a0,-2
(gdb) break kern_entry
Breakpoint 1 at 0x80200000: file kern/init/entry.S, line 7.
(gdb) continue        
Continuing.

Breakpoint 1, kern_entry () at kern/init/entry.S:7
7	    la sp, bootstacktop
(gdb) break kern_init 
Breakpoint 2 at 0x8020000a: file kern/init/init.c, line 8.
(gdb) continue
Continuing.

Breakpoint 2, kern_init () at kern/init/init.c:8
8	    memset(edata, 0, end - edata);

(gdb) disassemble kern_init
Dump of assembler code for function kern_init:
=> 0x000000008020000a <+0>:	auipc	a0,0x3
   0x000000008020000e <+4>:	addi	a0,a0,-2 # 0x80203008
   0x0000000080200012 <+8>:	auipc	a2,0x3
   0x0000000080200016 <+12>:	addi	a2,a2,-10 # 0x80203008
   0x000000008020001a <+16>:	addi	sp,sp,-16
   0x000000008020001c <+18>:	li	a1,0
   0x000000008020001e <+20>:	sub	a2,a2,a0
   0x0000000080200020 <+22>:	sd	ra,8(sp)
   0x0000000080200022 <+24>:	jal	0x802004b6 <memset>
   0x0000000080200026 <+28>:	auipc	a1,0x0
   0x000000008020002a <+32>:	addi	a1,a1,1186 # 0x802004c8
   0x000000008020002e <+36>:	auipc	a0,0x0
   0x0000000080200032 <+40>:	addi	a0,a0,1210 # 0x802004e8
   0x0000000080200036 <+44>:	jal	0x80200056 <cprintf>
   0x000000008020003a <+48>:	j	0x8020003a <kern_init+48>
End of assembler dump.
(gdb) continue
Continuing.

    //以供流程参考，并没有做任何代码的修改

```

--------------------------------------

# 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）

## 实验的知识点和OS原理对应的知识点

### 系统引导与引导加载程序

#### 实验知识点
通过GDB，我们跟踪了从QEMU模拟加电（PC指向0x1000）开始，执行固件代码，然后跳转到OpenSBI（在0x80000000），最终由OpenSBI将控制权交给内核（跳转到0x80200000）的全过程。

#### 对应OS原理
系统引导和引导加载程序

#### 理解与关联
**含义：** 系统引导是一个自举过程，指的是计算机从一个非常简单的初始状态，一步步加载更复杂的软件，直到整个操作系统完全运行起来。Bootloader是实现这个过程的关键程序，它的唯一使命就是将操作系统内核从存储介质加载到内存中，然后跳转到内核的入口点。

**关系：** 实验中的OpenSBI就扮演了一个具体的Bootloader角色。我们亲眼见证了它在完成硬件初始化后，是如何找到内核镜像并将其加载到指定的0x80200000内存地址，最后通过一条跳转指令启动了我们的内核。这让抽象的“Bootloader”概念变得非常具体。

**差异：** OS原理中的Bootloader概念更广泛，它可以非常复杂，也可以非常简单。


### 程序链接与执行入口

#### 实验知识点
我们了解到内核的入口地址是0x80200000，第一条指令位于kern/init/entry.S。同时，tail kern_init指令将执行流从汇编代码转移到了C函数。
#### 对应OS原理
程序的链接与加载。
#### 理解与关联
**含义：** 一个程序（包括OS内核）由多个源文件编译、链接而成。链接器根据链接脚本将这些代码和数据片段组合成一个可执行文件，并指定一个唯一的程序入口点。

**联系：** 实验中，0x80200000这个地址就是由链接器脚本tools/kernel.ld指定的。OpenSBI扮演了加载器（bootloader）的角色，将这个可执行文件加载到内存。而entry.S中的kern_entry标签就是链接器设定的入口点。tail kern_init则体现了模块化编程中不同语言模块间的调用关系，是汇编“引导模块”与C语言“主功能模块”的接口。

----------------------------------


# 列出你认为OS原理中很重要，但在实验中没有对应上的知识点


中断与异常处理、内存管理、并发与进程/线程管理、设备驱动与文件系统。应该在后面的实验会有吧

