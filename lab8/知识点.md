# Lab8 页错误处理与用户内存访问安全 - 修改笔记

## 一、核心问题

在 Lab8 中，用户程序执行时会触发页错误（Page Fault），需要在内核中正确处理：
1. **有效的页错误**：如访问未分配的 BSS 段，应分配物理页并映射
2. **无效的页错误**：如访问内核地址或不在 VMA 范围的地址，应杀死进程
3. **系统调用安全**：内核不能直接访问用户传入的指针，需要先验证

## 二、修改文件清单

### 1. kern/trap/trap.c - 页错误处理入口

**问题**：原始代码中页错误处理只是打印错误信息并递增 epc，没有真正处理。

**修改内容**：

```c
// 添加页错误信息打印函数
static void print_pgfault(struct trapframe *tf) {
    /* 
     * 打印页错误的详细信息：
     * - scause: 页错误类型（取指令/读数据/写数据）
     * - sepc: 触发页错误的指令地址
     * - stval: 导致页错误的虚拟地址
     */
    cprintf("%s page fault\n", 
            (tf->cause == CAUSE_LOAD_PAGE_FAULT) ? "Load/AMO" : 
            (tf->cause == CAUSE_STORE_PAGE_FAULT) ? "Store/AMO" : "Instruction");
}

// 添加页错误处理函数
static int pgfault_handler(struct trapframe *tf) {
    /*
     * 页错误处理流程：
     * 1. 获取当前进程的内存管理结构 mm
     * 2. 检查 mm 是否为空（内核线程没有 mm）
     * 3. 调用 do_pgfault 尝试处理页错误
     * 4. 返回处理结果（0=成功，非0=失败）
     */
    extern struct mm_struct *check_mm_struct;
    
    // 如果是用户进程，使用进程的 mm；否则使用全局的 check_mm_struct
    struct mm_struct *mm;
    if (check_mm_struct != NULL) {
        // 用于测试的特殊情况
        mm = check_mm_struct;
    } else {
        // 正常情况：使用当前进程的 mm
        mm = current->mm;
    }
    
    // 调用 vmm 层的页错误处理函数
    return do_pgfault(mm, tf->cause, tf->tval);
}

// 在 exception_handler 中修改三个页错误处理分支
void exception_handler(struct trapframe *tf) {
    int ret;
    switch (tf->cause) {
        // ... 其他异常处理 ...
        
        case CAUSE_LOAD_PAGE_FAULT:      // 读取数据页错误
        case CAUSE_STORE_PAGE_FAULT:     // 写入数据页错误
        case CAUSE_FETCH_PAGE_FAULT:     // 取指令页错误
            /*
             * 处理流程：
             * 1. 打印页错误信息（便于调试）
             * 2. 调用 pgfault_handler 处理
             * 3. 如果处理失败，杀死进程
             */
            print_pgfault(tf);
            if ((ret = pgfault_handler(tf)) != 0) {
                // 页错误无法处理，打印 trapframe 并终止进程
                print_trapframe(tf);
                if (current == NULL) {
                    panic("handle pgfault failed. ret=%d\n", ret);
                } else {
                    // 如果是用户进程，杀死该进程
                    if (trap_in_kernel(tf)) {
                        panic("handle pgfault failed in kernel mode. ret=%d\n", ret);
                    }
                    cprintf("killed by kernel.\n");
                    do_exit(-E_KILLED);
                }
            }
            break;
            
        // ... 其他异常处理 ...
    }
}
```

**关键点**：
- `pgfault_handler` 根据是否有 mm 结构决定是否处理
- 内核态页错误会导致 panic（不应该发生）
- 用户态无法处理的页错误会杀死进程

---

### 2. kern/mm/vmm.c - 页错误处理核心实现

**问题**：缺少 `do_pgfault` 函数实现，以及安全的用户内存访问函数。

**修改内容**：

```c
// 添加全局变量定义（用于测试）
struct mm_struct *check_mm_struct = NULL;

/*
 * do_pgfault - 页错误处理的核心函数
 * @mm: 内存管理结构
 * @error_code: 错误类型（读/写/执行）
 * @addr: 触发页错误的虚拟地址
 * 
 * 返回值：0=成功处理，非0=处理失败
 */
int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr) {
    int ret = -E_INVAL;
    
    // 第一步：查找包含该地址的 VMA（虚拟内存区域）
    struct vma_struct *vma = find_vma(mm, addr);

    // 第二步：验证地址是否合法
    if (vma == NULL || vma->vm_start > addr) {
        // 地址不在任何 VMA 范围内，这是非法访问
        cprintf("not valid addr %x, and can not find it in vma\n", addr);
        goto failed;
    }

    // 第三步：设置页表项权限
    /* 
     * RISC-V 页表权限位：
     * - PTE_V: 页表项有效
     * - PTE_R: 可读
     * - PTE_W: 可写
     * - PTE_X: 可执行
     * - PTE_U: 用户态可访问
     */
    uint32_t perm = PTE_U | PTE_V;  // 基础权限：用户态+有效
    if (vma->vm_flags & VM_WRITE) {
        perm |= (PTE_R | PTE_W);    // 可写区域同时需要可读
    }
    if (vma->vm_flags & VM_READ) {
        perm |= PTE_R;              // 可读权限
    }
    if (vma->vm_flags & VM_EXEC) {
        perm |= PTE_X;              // 可执行权限
    }
    
    // 第四步：页对齐地址
    addr = ROUNDDOWN(addr, PGSIZE);  // 向下对齐到页边界

    ret = -E_NO_MEM;

    // 第五步：获取或创建页表项
    pte_t *ptep = get_pte(mm->pgdir, addr, 1);  // 1 表示如果不存在则创建
    
    if (*ptep == 0) {
        // 情况1：页表项不存在，需要分配新的物理页
        if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL) {
            cprintf("pgdir_alloc_page in do_pgfault failed\n");
            goto failed;
        }
    } else {
        // 情况2：页表项已存在
        /*
         * 这种情况可能是：
         * - 权限不足（如写时复制 COW）
         * - 页面被换出到磁盘（swap）
         * 目前简单处理：如果页面存在就认为成功
         */
        struct Page *page = pte2page(*ptep);
        if (page != NULL) {
            ret = 0;  // 页面已存在，成功
        } else {
            cprintf("pte is not zero but page is NULL\n");
            goto failed;
        }
    }

    ret = 0;  // 成功处理
failed:
    return ret;
}

/*
 * copy_to_user - 安全地将数据从内核复制到用户空间
 * @mm: 用户进程的内存管理结构
 * @dst: 用户空间目标地址
 * @src: 内核空间源地址
 * @len: 复制长度
 * 
 * 返回值：1=成功，0=失败
 * 
 * 安全检查：
 * 1. 验证 dst 在用户空间范围内
 * 2. 验证 dst 在进程的 VMA 范围内
 * 3. 验证 dst 有写权限
 */
bool copy_to_user(struct mm_struct *mm, void *dst, const void *src, size_t len)
{
    // 使用 user_mem_check 验证目标地址的合法性
    if (!user_mem_check(mm, (uintptr_t)dst, len, 1))  // 1 表示检查写权限
    {
        return 0;  // 验证失败
    }
    // 验证通过，执行复制
    memcpy(dst, src, len);
    return 1;
}

/*
 * copy_from_user - 安全地将数据从用户空间复制到内核
 * @mm: 用户进程的内存管理结构
 * @dst: 内核空间目标地址
 * @src: 用户空间源地址
 * @len: 复制长度
 * @writable: 是否需要写权限（通常为 false）
 * 
 * 返回值：1=成功，0=失败
 */
bool copy_from_user(struct mm_struct *mm, void *dst, const void *src, size_t len, bool writable)
{
    // 验证源地址的合法性
    if (!user_mem_check(mm, (uintptr_t)src, len, writable))
    {
        return 0;
    }
    memcpy(dst, src, len);
    return 1;
}
```

**关键点**：
- `do_pgfault` 通过 VMA 验证地址合法性
- 根据 VMA 的权限标志设置页表权限
- `copy_to_user/copy_from_user` 必须先调用 `user_mem_check` 验证

---

### 3. kern/mm/vmm.h - 函数声明

**修改内容**：

```c
// 在文件中添加 do_pgfault 的函数声明
int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr);
```

---

### 4. kern/process/proc.c - 系统调用中安全访问用户指针

**问题**：`do_wait` 中直接写入用户传入的指针 `code_store`，不安全。

**修改内容**：

```c
int do_wait(int pid, int *code_store)
{
    struct mm_struct *mm = current->mm;
    
    // 第一步：验证用户传入的指针
    if (code_store != NULL)
    {
        /*
         * user_mem_check 验证内容：
         * 1. 地址在用户空间范围内（USERBASE ~ USERTOP）
         * 2. 地址在进程的某个 VMA 内
         * 3. VMA 有写权限（因为 write=1）
         */
        if (!user_mem_check(mm, (uintptr_t)code_store, sizeof(int), 1))
        {
            return -E_INVAL;  // 地址非法，返回错误
        }
    }

    struct proc_struct *proc;
    bool intr_flag, haskid;
    
repeat:
    // ... 查找子进程的代码（省略）...

found:
    if (proc == idleproc || proc == initproc)
    {
        panic("wait idleproc or initproc.\n");
    }
    
    // 第二步：使用 copy_to_user 安全地写入退出码
    if (code_store != NULL)
    {
        /*
         * copy_to_user 会再次验证地址并执行复制
         * 这是双重保护，确保即使地址在验证后被修改也能捕获
         */
        if (!copy_to_user(mm, code_store, &(proc->exit_code), sizeof(int)))
        {
            return -E_INVAL;
        }
    }
    
    // 第三步：清理子进程资源
    local_intr_save(intr_flag);
    {
        unhash_proc(proc);
        remove_links(proc);
    }
    local_intr_restore(intr_flag);
    put_kstack(proc);
    kfree(proc);
    return 0;
}
```

**关键改进**：
- 在函数开始就验证 `code_store` 的合法性
- 使用 `copy_to_user` 而不是直接 `*code_store = ...`
- 如果验证失败立即返回 -E_INVAL，防止内核崩溃

---

### 5. user/libs/ulib.c - 修复 waitpid 实现

**问题**：原始实现在系统调用返回后尝试写入用户指针，如果指针无效会在用户态触发页错误。

**原始代码（有问题）**：
```c
int waitpid(int pid, int *store) {
    int64_t exit_code_store;
    int ret;
    
    if (store == NULL) {
        return sys_wait(pid, NULL);
    }
    
    ret = sys_wait(pid, &exit_code_store);  // 使用栈上的变量
    
    // 问题：如果 store 是无效地址（如 0xC0000000），
    // 这里会在用户态触发页错误，导致进程被杀死
    if (ret == 0 && store != NULL) {
        *store = (int)exit_code_store;  // <-- 危险：可能访问非法地址
    }
    
    return ret;
}
```

**修复后的代码**：
```c
/*
 * waitpid - 等待子进程结束
 * @pid: 子进程 PID（0 表示任意子进程）
 * @store: 用于存储子进程退出码的指针
 * 
 * 返回值：0=成功，负数=错误码
 * 
 * 设计原则：
 * 让内核验证和处理用户指针，而不是在用户态处理
 */
int waitpid(int pid, int *store) {
    // 直接传递用户指针给系统调用
    // 类型转换：int* -> int64_t*（内核期望的类型）
    return sys_wait(pid, (int64_t *)store);
}
```

**为什么这样修复**：
1. **内核验证更安全**：内核中的 `user_mem_check` 可以完整验证地址
2. **避免用户态崩溃**：如果地址无效，系统调用返回错误而不是触发页错误
3. **简化代码**：不需要中间变量，直接传递指针

---

## 三、测试用例分析

### 1. badarg 测试

**测试代码**：
```c
int main(void) {
    int pid, exit_code;
    if ((pid = fork()) == 0) {
        // 子进程
        for (i = 0; i < 10; i++) yield();
        exit(0xbeaf);
    }
    
    // 父进程测试非法参数
    assert(waitpid(-1, NULL) != 0);              // 测试1：无效PID
    assert(waitpid(pid, (void *)0xC0000000) != 0); // 测试2：无效地址（内核地址）
    assert(waitpid(pid, &exit_code) == 0);       // 测试3：正常调用
    
    cprintf("badarg pass.\n");
    return 0;
}
```

**执行流程**：
1. 测试1：`waitpid(-1, NULL)` → 返回 -E_BAD_PROC（找不到 PID=-1 的子进程）
2. 测试2：`waitpid(pid, 0xC0000000)` → `user_mem_check` 检测到地址在内核空间 → 返回 -E_INVAL
3. 测试3：`waitpid(pid, &exit_code)` → 正常等待并返回退出码 0xbeaf

**关键**：测试2 不应该触发页错误，而是系统调用返回错误码。

### 2. testbss 测试

**测试目的**：验证 BSS 段的延迟分配（lazy allocation）

**执行流程**：
1. 访问 BSS 段的数组 → 触发页错误 → `do_pgfault` 分配物理页 → 成功
2. 故意写入超出 BSS 范围的地址 → 触发页错误 → `do_pgfault` 发现不在 VMA 内 → 失败 → 进程被杀死

**预期结果**：
```
Making sure bss works right...
Yes, good.  Now doing a wild write off the end...
testbss may pass.
not valid addr c02000, and can not find it in vma
killed by kernel.
error: -9 - process is killed
```

这是**正常行为**，说明页错误处理正确区分了合法和非法访问。

---

## 四、核心知识点总结

### 1. 页错误处理流程

```
用户程序访问内存
    ↓
触发页错误异常
    ↓
trap.c: exception_handler
    ↓
trap.c: pgfault_handler
    ↓
vmm.c: do_pgfault
    ├─ 查找 VMA
    ├─ 检查权限
    ├─ 分配物理页
    └─ 建立映射
    ↓
返回用户态继续执行
```

### 2. 用户内存访问安全原则

**三不原则**：
1. **不直接解引用用户指针**：可能指向非法地址
2. **不假设用户数据合法**：必须验证所有用户输入
3. **不在用户态处理非法地址**：应该在内核验证并返回错误

**正确做法**：
```c
// ❌ 错误：直接访问用户指针
*user_ptr = kernel_value;

// ✅ 正确：先验证再访问
if (user_mem_check(mm, user_ptr, size, 1)) {
    copy_to_user(mm, user_ptr, &kernel_value, size);
}
```

### 3. VMA（虚拟内存区域）的作用

每个进程的地址空间由多个 VMA 组成：
- **代码段 VMA**：[0x200000, ...），权限：VM_READ | VM_EXEC
- **数据段 VMA**：[..., ...]，权限：VM_READ | VM_WRITE
- **BSS 段 VMA**：[..., ...]，权限：VM_READ | VM_WRITE
- **栈 VMA**：[USTACKTOP-USTACKSIZE, USTACKTOP)，权限：VM_READ | VM_WRITE | VM_STACK

页错误处理时，通过 VMA 判断：
- 地址是否在合法范围（vma->vm_start ≤ addr < vma->vm_end）
- 访问类型是否符合权限（读/写/执行）

### 4. RISC-V 页表权限位

```c
#define PTE_V 0x001  // Valid：页表项有效
#define PTE_R 0x002  // Read：可读
#define PTE_W 0x004  // Write：可写
#define PTE_X 0x008  // Execute：可执行
#define PTE_U 0x010  // User：用户态可访问
```

**重要规则**：
- 可写页必须同时设置 PTE_R（RISC-V 要求）
- 用户页必须设置 PTE_U
- 内核页不设置 PTE_U

---

