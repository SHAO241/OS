## 硬盘文件系统`SFS`

通常文件系统中，磁盘的使用是以扇区（`Sector`）为单位的，但是为了实现简便，`SFS `中以 `block` （`4K`，与内存 page 大小相等）为基本单位。


SFS 文件系统的布局如下表所示。

| superblock | root-dir inode | freemap | inode、File Data、Dir Data Blocks |
| --- | --- | --- | --- |
| 超级块 | 根目录索引节点 | 空闲块映射 | 目录和文件的数据和索引节点 |


第 1 个块放了一个 `root-dir` 的 `inode`，用来记录根目录的相关信息。有关 `inode` 还将在后续部分介绍。这里只要理解 `root-dir` 是 `SFS` 文件系统的根结点，通过这个 `root-dir` 的 `inode` 信息就可以定位并查找到根目录下的所有文件信息。


从第 2 个块开始，根据 `SFS` 中所有块的数量，用 `1` 个 `bit` 来表示一个块的占用和未被占用的情况。这个区域称为 `SFS` 的 `freemap` 区域，这将占用若干个块空间。为了更好地记录和管理 `freemap` 区域，专门提供了两个文件 `kern/fs/sfs/bitmap.[ch]`来完成根据一个块号查找或设置对应的 `bit` 位的值。

最后在剩余的磁盘空间中，存放了所有其他目录和文件的 `inode` 信息和内容数据信息。需要注意的是虽然 `inode` 的大小小于一个块的大小`（4096B）`，但为了实现简单，每个 `inode` 都占用一个完整的 `block。`


### 超级块（Superblock）结构体

超级块 `sfs_super` 是 SFS 文件系统的元数据，位于磁盘的第 0 块，包含了整个文件系统的关键信息。

```c
struct sfs_super {
    uint32_t magic;                                 /* 魔数，用于标识 SFS 文件系统，值应为 SFS_MAGIC (0x2f8dbe2a) */
    uint32_t blocks;                                /* 文件系统中总的块数量 */
    uint32_t unused_blocks;                         /* 文件系统中未使用的块数量（空闲块数） */
    char info[SFS_MAX_INFO_LEN + 1];                /* 文件系统的附加信息字符串（最大32字节，包含'\0'） */
};
```

**字段说明：**
- `magic`：魔数，用于识别和验证文件系统类型，防止误操作
- `blocks`：文件系统总块数，表示整个文件系统的容量
- `unused_blocks`：空闲块数量，用于快速判断是否有足够的空间
- `info`：可选的描述信息，用于存储文件系统的额外信息

### 磁盘索引节点（Disk Inode）结构体

磁盘索引节点 `sfs_disk_inode` 是存储在磁盘上的 inode 结构，记录了文件或目录的元数据和数据块索引信息。每个文件或目录都对应一个 inode。

```c
struct sfs_disk_inode {
    uint32_t size;                                  /* 文件大小（以字节为单位） */
    uint16_t type;                                  /* 文件类型：SFS_TYPE_FILE(1)=普通文件, SFS_TYPE_DIR(2)=目录, SFS_TYPE_LINK(3)=链接 */
    uint16_t nlinks;                                /* 硬链接数，表示有多少个目录项指向此 inode */
    uint32_t blocks;                                /* 文件占用的数据块数量 */
    uint32_t direct[SFS_NDIRECT];                   /* 直接索引块数组（12个），直接指向数据块的块号 */
    uint32_t indirect;                              /* 一级间接索引块号，指向一个存储块号的块 */
    // uint32_t db_indirect;                        /* 二级间接索引块（未使用） */
};
```

**字段说明：**
- `size`：文件的实际大小（字节数），对于目录则是目录项的总大小
- `type`：标识这是文件、目录还是链接
- `nlinks`：硬链接计数，当计数为 0 时可以删除该 inode
- `blocks`：文件占用的块数，用于计算文件占用的磁盘空间
- `direct[12]`：直接索引，最多可索引 12 个块（12 × 4KB = 48KB）
- `indirect`：间接索引，指向一个索引块，该索引块中存储了更多的数据块号（可索引 1024 个块，即 4MB）

**索引结构说明：**
- 小文件（≤48KB）：只使用直接索引
- 大文件（48KB - 4MB+48KB）：使用直接索引 + 一级间接索引
- 最大文件大小：12 × 4KB + 1024 × 4KB = 48KB + 4MB ≈ 4MB

### 目录项（Disk Entry）结构体

目录项 `sfs_disk_entry` 是存储在磁盘上的目录条目，表示目录中的一个文件或子目录。它建立了文件名与 inode 的映射关系。

```c
struct sfs_disk_entry {
    uint32_t ino;                                   /* inode 编号，指向对应文件/目录的 inode 所在的磁盘块号 */
    char name[SFS_MAX_FNAME_LEN + 1];               /* 文件名或目录名（以'\0'结尾的字符串） */
};
```

**字段说明：**
- `ino`：inode 编号，实际上就是该 inode 所在的磁盘块号。当 `ino = 0` 时，表示这是一个无效的目录项
- `name`：文件或目录的名称，最大长度由 `SFS_MAX_FNAME_LEN` 定义

**使用说明：**
- 每个目录项占用一个完整的 block（4KB），尽管实际数据远小于 4KB
- 目录的内容就是由多个 `sfs_disk_entry` 组成的数组
- 通过 `ino` 字段可以找到对应的 inode，进而访问文件或子目录的实际内容
- 根目录的 inode 编号为 1（位于磁盘的第 1 块）


`sfs_disk_inode` 记录了文件或目录的内容存储的**索引信息**，该数据结构在**硬盘里储存**，需要时读入内存（从磁盘读进来的是**一段连续的字节**，我们将这段连续的字节强制转换成`sfs_disk_inod`e结构体


同样，写入的时候换一个方向强制转换）。`sfs_disk_entry` 表示一个目录中的一个文件或目录，包含该项所对应 `inode` 的位置和文件名，同样也在硬盘里储存，需要时读入内存。


操作系统中，每个文件系统下的 `inode `都应该分配唯一的 `inode `编号。SFS 下，为了实现的简便 **（偷懒）**，每个 `inode` 直接用他所在的磁盘` block` 的编号作为 `inode` 编号。比如，`root block` 的 `inode` 编号为 1；每个 `sfs_disk_entry` 数据结构中，`name` 表示目录下文件或文件夹的名称，`ino` 表示磁盘 `block` 编号，通过读取该 `block `的数据，能够得到相应的文件或文件夹的 `inode`。ino 为 0 时，表示一个**无效的 entry**。

此外，和 `inode` 相似，每个 `sfs_disk_entry`也占用一个 `block`。

### 内存索引节点（Memory Inode）结构体

内存索引节点 `sfs_inode` 是 `sfs_disk_inode` 在内存中的扩展版本，除了包含磁盘 inode 的指针外，还包含了用于内存管理和同步的额外信息。

```c
struct sfs_inode {
    struct sfs_disk_inode *din;                     /* 指向磁盘 inode 的指针，包含文件的实际元数据 */
    uint32_t ino;                                   /* inode 编号（即该 inode 所在的磁盘块号） */
    bool dirty;                                     /* 脏位标志：true 表示 inode 在内存中被修改，需要写回磁盘 */
    int reclaim_count;                              /* 引用计数：当计数降为 0 时可以回收该 inode */
    semaphore_t sem;                                /* 信号量：用于保护 din 指向的磁盘 inode 数据，实现并发控制 */
    list_entry_t inode_link;                        /* 链表节点：用于将此 inode 加入到 sfs_fs 的 inode 链表中 */
    list_entry_t hash_link;                         /* 哈希链表节点：用于将此 inode 加入到 sfs_fs 的哈希表中，便于快速查找 */
};
```

**字段说明：**
- `din`：指向实际的磁盘 inode 数据（`sfs_disk_inode`），该数据从磁盘读取后存储在内存中
- `ino`：inode 编号，与磁盘块号相同，用于唯一标识文件系统中的一个文件或目录
- `dirty`：脏位，标记 inode 是否被修改。若为 true，则在适当时机需要将修改写回磁盘
- `reclaim_count`：引用计数，记录有多少个进程或内核组件正在使用此 inode。为 0 时可以释放
- `sem`：信号量，用于同步对 inode 数据的并发访问，防止多个进程同时修改造成数据不一致
- `inode_link`：全局 inode 链表的链接节点，所有内存中的 inode 都会通过此字段串联在一起
- `hash_link`：哈希表链表的链接节点，用于根据 inode 编号快速查找对应的内存 inode

**与 `sfs_disk_inode` 的区别：**
- `sfs_disk_inode`：存储在磁盘上，只包含文件的基本元数据和索引信息
- `sfs_inode`：存储在内存中，包含磁盘 inode 的指针，并额外添加了管理信息（如脏位、引用计数、同步机制等）

## SFS 辅助函数详解

### 1. sfs_bmap_load_nolock - 逻辑块号到物理块号的映射

该函数根据文件的逻辑块索引，找到对应的物理磁盘块号。如果逻辑块尚未分配，可以选择是否为其分配新的磁盘块。

```c
/*
 * sfs_bmap_load_nolock - 根据 inode 和逻辑块索引，找到对应的磁盘块号
 * @sfs:      sfs 文件系统
 * @sin:      内存中的 sfs inode
 * @index:    文件的逻辑块索引（从 0 开始）
 * @ino_store: 返回找到的磁盘块号
 * 
 * 功能：将文件的逻辑块号转换为实际的磁盘块号
 * 如果 index == din->blocks，表示需要扩展文件，会分配新块
 */
static int
sfs_bmap_load_nolock(struct sfs_fs *sfs, struct sfs_inode *sin, uint32_t index, uint32_t *ino_store) {
    struct sfs_disk_inode *din = sin->din;
    assert(index <= din->blocks);  // index 最多等于 blocks（表示要新增一个块）
    
    int ret;
    uint32_t ino;
    bool create = (index == din->blocks);  // 如果索引等于当前块数，说明要创建新块
    
    // 调用 sfs_bmap_get_nolock 获取块号
    if ((ret = sfs_bmap_get_nolock(sfs, sin, index, create, &ino)) != 0) {
        return ret;
    }
    
    assert(sfs_block_inuse(sfs, ino));  // 确保块正在使用中
    
    if (create) {
        din->blocks++;  // 增加文件占用的块数
    }
    
    if (ino_store != NULL) {
        *ino_store = ino;  // 返回磁盘块号
    }
    return 0;
}
```

**核心逻辑：**
- 检查 `index` 是否等于 `din->blocks`，若相等则表示需要扩展文件（分配新块）
- 调用 `sfs_bmap_get_nolock` 完成实际的块号查找或分配
- 如果是新分配的块，增加 `din->blocks` 计数

### 2. sfs_bmap_truncate_nolock - 截断文件末尾块

该函数释放文件末尾的一个数据块，用于缩减文件大小。

```c
/*
 * sfs_bmap_truncate_nolock - 释放文件末尾的磁盘块
 * @sfs: sfs 文件系统
 * @sin: 内存中的 sfs inode
 * 
 * 功能：删除文件的最后一个数据块，减少文件占用的磁盘空间
 * 常用于文件截断操作
 */
static int
sfs_bmap_truncate_nolock(struct sfs_fs *sfs, struct sfs_inode *sin) {
    struct sfs_disk_inode *din = sin->din;
    assert(din->blocks != 0);  // 确保文件至少有一个块
    
    int ret;
    // 释放最后一个块（索引为 blocks - 1）
    if ((ret = sfs_bmap_free_nolock(sfs, sin, din->blocks - 1)) != 0) {
        return ret;
    }
    
    din->blocks--;      // 减少块计数
    sin->dirty = 1;     // 标记 inode 为脏，需要写回磁盘
    return 0;
}
```

**核心逻辑：**
- 调用 `sfs_bmap_free_nolock` 释放最后一个块（索引 = `blocks - 1`）
- 减少 `din->blocks` 计数
- 设置脏位，确保修改会被写回磁盘

### 3. sfs_dirent_read_nolock - 读取目录项

该函数从目录的 inode 中读取指定位置的目录项。

```c
/*
 * sfs_dirent_read_nolock - 从磁盘块读取目录项
 * @sfs:   sfs 文件系统
 * @sin:   目录的 sfs inode（必须是目录类型）
 * @slot:  目录项的槽位索引（每个槽位占一个块）
 * @entry: 返回读取到的目录项内容
 * 
 * 功能：读取目录中第 slot 个目录项的内容
 * 注意：每个目录项占用一个完整的块（4KB）
 */
static int
sfs_dirent_read_nolock(struct sfs_fs *sfs, struct sfs_inode *sin, int slot, struct sfs_disk_entry *entry) {
    assert(sin->din->type == SFS_TYPE_DIR);  // 必须是目录类型
    assert(slot >= 0 && slot < sin->din->blocks);  // slot 必须在有效范围内
    
    int ret;
    uint32_t ino;
    
    // 根据目录的 inode 和 slot，找到包含该目录项的磁盘块号
    if ((ret = sfs_bmap_load_nolock(sfs, sin, slot, &ino)) != 0) {
        return ret;
    }
    
    assert(sfs_block_inuse(sfs, ino));  // 确保块在使用中
    
    // 从磁盘块的起始位置读取目录项内容
    if ((ret = sfs_rbuf(sfs, entry, sizeof(struct sfs_disk_entry), ino, 0)) != 0) {
        return ret;
    }
    
    entry->name[SFS_MAX_FNAME_LEN] = '\0';  // 确保文件名以 '\0' 结尾
    return 0;
}
```

**核心逻辑：**
- 目录项以槽位（slot）为单位存储，每个槽位一个块
- 先调用 `sfs_bmap_load_nolock` 找到第 `slot` 个块的磁盘块号
- 使用 `sfs_rbuf` 从块的偏移 0 处读取目录项数据
- 强制在文件名末尾添加 `\0`，确保字符串安全

### 4. sfs_dirent_search_nolock - 在目录中搜索文件

该函数在目录中查找指定名称的文件或子目录，返回其 inode 编号和槽位位置。

```c
/*
 * sfs_dirent_search_nolock - 在目录中搜索指定文件名
 * @sfs:        sfs 文件系统
 * @sin:        目录的 sfs inode
 * @name:       要搜索的文件名
 * @ino_store:  返回找到的文件的 inode 编号
 * @slot:       返回找到的文件所在的槽位索引
 * @empty_slot: 返回第一个空闲槽位的索引（用于创建新文件）
 * 
 * 功能：遍历目录的所有目录项，查找匹配的文件名
 * 返回：成功返回 0，未找到返回 -E_NOENT
 */
static int
sfs_dirent_search_nolock(struct sfs_fs *sfs, struct sfs_inode *sin, const char *name, 
                         uint32_t *ino_store, int *slot, int *empty_slot) {
    assert(strlen(name) <= SFS_MAX_FNAME_LEN);  // 文件名长度检查
    
    struct sfs_disk_entry *entry;
    if ((entry = kmalloc(sizeof(struct sfs_disk_entry))) == NULL) {
        return -E_NO_MEM;
    }

    // 宏定义：安全地设置指针指向的值
    #define set_pvalue(x, v) do { if ((x) != NULL) { *(x) = (v); } } while (0)
    
    int ret, i, nslots = sin->din->blocks;  // nslots = 目录项总数
    set_pvalue(empty_slot, nslots);  // 默认空闲槽位在末尾
    
    // 遍历所有目录项
    for (i = 0; i < nslots; i++) {
        // 读取第 i 个目录项
        if ((ret = sfs_dirent_read_nolock(sfs, sin, i, entry)) != 0) {
            goto out;
        }
        
        // 如果 ino == 0，表示这是一个空闲槽位
        if (entry->ino == 0) {
            set_pvalue(empty_slot, i);  // 记录第一个空闲槽位
            continue;
        }
        
        // 比较文件名
        if (strcmp(name, entry->name) == 0) {
            // 找到匹配的文件
            set_pvalue(slot, i);              // 返回槽位索引
            set_pvalue(ino_store, entry->ino);  // 返回 inode 编号
            goto out;
        }
    }
    #undef set_pvalue
    
    ret = -E_NOENT;  // 未找到文件
out:
    kfree(entry);
    return ret;
}
```

**核心逻辑：**
- 遍历目录的所有槽位（从 0 到 `blocks - 1`）
- 对每个槽位调用 `sfs_dirent_read_nolock` 读取目录项
- 如果 `entry->ino == 0`，记录为空闲槽位（可用于创建新文件）
- 如果文件名匹配，返回该文件的 inode 编号和槽位索引
- 如果遍历完所有槽位仍未找到，返回 `-E_NOENT` 错误

**使用场景：**
- 文件查找：通过文件名在目录中定位文件
- 文件创建：找到空闲槽位插入新的目录项
- 目录操作：实现 `ls`、`open` 等命令的基础

### 5. sfs_bmap_free_nolock - 释放文件的逻辑块

该函数释放文件中指定逻辑块号对应的磁盘块，用于删除文件或缩减文件大小。

```c
/*
 * sfs_bmap_free_nolock - 释放文件中指定逻辑索引的磁盘块
 * @sfs:   sfs 文件系统
 * @sin:   内存中的 sfs inode
 * @index: 要释放的逻辑块索引
 * 
 * 功能：根据逻辑块索引，释放对应的磁盘块（直接块或间接块）
 * 注意：需要同时更新 inode 中的索引信息
 */
static int
sfs_bmap_free_nolock(struct sfs_fs *sfs, struct sfs_inode *sin, uint32_t index) {
    struct sfs_disk_inode *din = sin->din;
    int ret;
    uint32_t ent, ino;
    
    // 情况1：逻辑块在直接索引范围内（index < 12）
    if (index < SFS_NDIRECT) {
        if ((ino = din->direct[index]) != 0) {
            // 释放该磁盘块
            sfs_block_free(sfs, ino);
            din->direct[index] = 0;  // 清空直接索引项
            sin->dirty = 1;           // 标记 inode 为脏
        }
        return 0;
    }

    // 情况2：逻辑块在间接索引范围内
    index -= SFS_NDIRECT;  // 调整为在间接块中的索引
    if (index < SFS_BLK_NENTRY) {
        if ((ent = din->indirect) != 0) {
            // 释放间接索引块中对应位置的数据块
            if ((ret = sfs_bmap_free_sub_nolock(sfs, ent, index)) != 0) {
                return ret;
            }
        }
        return 0;
    }
    return 0;
}
```

**核心逻辑：**
1. **直接块处理**（index < 12）：
   - 检查 `din->direct[index]` 是否非零（已分配）
   - 调用 `sfs_block_free` 释放磁盘块
   - 将 `din->direct[index]` 设为 0，表示该位置已释放
   - 设置脏位，确保修改写回磁盘

2. **间接块处理**（12 ≤ index < 12 + 1024）：
   - 调整索引：`index -= SFS_NDIRECT`
   - 检查间接索引块是否存在（`din->indirect != 0`）
   - 调用 `sfs_bmap_free_sub_nolock` 处理间接块中的条目

**辅助函数 sfs_bmap_free_sub_nolock：**

```c
/*
 * sfs_bmap_free_sub_nolock - 释放间接块中指定位置的数据块
 * @sfs:   sfs 文件系统
 * @ent:   间接索引块的块号
 * @index: 在间接块中的索引（0-1023）
 */
static int
sfs_bmap_free_sub_nolock(struct sfs_fs *sfs, uint32_t ent, uint32_t index) {
    assert(sfs_block_inuse(sfs, ent) && index < SFS_BLK_NENTRY);
    int ret;
    uint32_t ino, zero = 0;
    off_t offset = index * sizeof(uint32_t);  // 计算在间接块中的偏移
    
    // 从间接块中读取数据块号
    if ((ret = sfs_rbuf(sfs, &ino, sizeof(uint32_t), ent, offset)) != 0) {
        return ret;
    }
    
    // 如果该位置有数据块
    if (ino != 0) {
        // 将间接块中该位置设为 0
        if ((ret = sfs_wbuf(sfs, &zero, sizeof(uint32_t), ent, offset)) != 0) {
            return ret;
        }
        // 释放数据块
        sfs_block_free(sfs, ino);
    }
    return 0;
}
```

**使用场景：**
- 文件删除：释放文件占用的所有磁盘块
- 文件截断：缩减文件大小时释放多余的块
- 与 `sfs_bmap_truncate_nolock` 配合使用：逐个释放文件末尾的块

**注意事项：**
- 释放块后必须设置 `sin->dirty = 1`，确保 inode 修改写回磁盘
- 只释放数据块，不释放间接索引块本身（间接索引块在所有数据块释放后单独处理）
- 该函数不修改 `din->blocks` 计数，由调用者负责更新

### 6. sfs_bmap_get_nolock - 获取或分配文件的磁盘块

该函数是块映射的核心函数，根据文件的逻辑块索引查找或分配对应的物理磁盘块号。

```c
/*
 * sfs_bmap_get_nolock - 根据 inode 和逻辑块索引，查找或分配磁盘块号
 * @sfs:      sfs 文件系统
 * @sin:      内存中的 sfs inode
 * @index:    文件的逻辑块索引
 * @create:   是否创建新块（true=分配新块，false=仅查找）
 * @ino_store: 返回磁盘块号（如果未分配且 create=false，则返回 0）
 * 
 * 功能：将文件的逻辑块号映射到物理磁盘块号，支持直接索引和间接索引
 */
static int
sfs_bmap_get_nolock(struct sfs_fs *sfs, struct sfs_inode *sin, uint32_t index, 
                    bool create, uint32_t *ino_store) {
    struct sfs_disk_inode *din = sin->din;
    int ret;
    uint32_t ent, ino;
    
    // 情况1：逻辑块在直接索引范围内（index < 12）
    if (index < SFS_NDIRECT) {
        if ((ino = din->direct[index]) == 0 && create) {
            // 直接索引为空且需要创建，分配新块
            if ((ret = sfs_block_alloc(sfs, &ino)) != 0) {
                return ret;
            }
            din->direct[index] = ino;  // 更新直接索引
            sin->dirty = 1;             // 标记 inode 为脏
        }
        goto out;
    }
    
    // 情况2：逻辑块在间接索引范围内（12 ≤ index < 12 + 1024）
    index -= SFS_NDIRECT;  // 调整为在间接块中的索引（0-1023）
    if (index < SFS_BLK_NENTRY) {
        ent = din->indirect;  // 获取间接索引块号
        
        // 调用辅助函数处理间接索引
        if ((ret = sfs_bmap_get_sub_nolock(sfs, &ent, index, create, &ino)) != 0) {
            return ret;
        }
        
        // 如果间接索引块是新分配的，更新 inode
        if (ent != din->indirect) {
            assert(din->indirect == 0);  // 原来应该为空
            din->indirect = ent;          // 设置间接索引块号
            sin->dirty = 1;               // 标记为脏
        }
        goto out;
    } else {
        // 超出支持的文件大小范围
        panic("sfs_bmap_get_nolock - index out of range");
    }
    
out:
    assert(ino == 0 || sfs_block_inuse(sfs, ino));  // 确保块号有效或为0
    *ino_store = ino;
    return 0;
}
```

**核心逻辑：**

1. **直接索引处理**（index < 12）：
   - 检查 `din->direct[index]` 是否已分配
   - 如果为 0 且 `create=true`，调用 `sfs_block_alloc` 分配新块
   - 更新直接索引数组并设置脏位

2. **间接索引处理**（12 ≤ index < 1036）：
   - 将索引调整为间接块中的偏移：`index -= 12`
   - 获取间接索引块号 `din->indirect`
   - 调用 `sfs_bmap_get_sub_nolock` 处理
   - 如果间接索引块是新创建的，更新 `din->indirect`

**辅助函数 sfs_bmap_get_sub_nolock：**

```c
/*
 * sfs_bmap_get_sub_nolock - 处理间接索引块中的块映射
 * @sfs:      sfs 文件系统
 * @entp:     间接索引块号的指针（输入/输出参数）
 * @index:    在间接块中的索引（0-1023）
 * @create:   是否创建新块
 * @ino_store: 返回数据块号
 */
static int
sfs_bmap_get_sub_nolock(struct sfs_fs *sfs, uint32_t *entp, uint32_t index, 
                        bool create, uint32_t *ino_store) {
    assert(index < SFS_BLK_NENTRY);  // 索引必须在有效范围内
    int ret;
    uint32_t ent, ino = 0;
    off_t offset = index * sizeof(uint32_t);  // 计算在间接块中的偏移
    
    // 如果间接索引块已存在
    if ((ent = *entp) != 0) {
        // 从间接块中读取数据块号
        if ((ret = sfs_rbuf(sfs, &ino, sizeof(uint32_t), ent, offset)) != 0) {
            return ret;
        }
        // 如果已有数据块或不需要创建，直接返回
        if (ino != 0 || !create) {
            goto out;
        }
    }
    else {
        // 间接索引块不存在
        if (!create) {
            goto out;  // 不创建，返回 0
        }
        // 分配间接索引块
        if ((ret = sfs_block_alloc(sfs, &ent)) != 0) {
            return ret;
        }
    }
    
    // 需要分配新的数据块
    if ((ret = sfs_block_alloc(sfs, &ino)) != 0) {
        goto failed_cleanup;
    }
    
    // 将数据块号写入间接块的相应位置
    if ((ret = sfs_wbuf(sfs, &ino, sizeof(uint32_t), ent, offset)) != 0) {
        sfs_block_free(sfs, ino);  // 写入失败，释放数据块
        goto failed_cleanup;
    }

out:
    if (ent != *entp) {
        *entp = ent;  // 返回（可能新分配的）间接索引块号
    }
    *ino_store = ino;
    return 0;

failed_cleanup:
    if (ent != *entp) {
        sfs_block_free(sfs, ent);  // 释放新分配的间接索引块
    }
    return ret;
}
```

**处理流程图：**

```
index < 12 (直接索引)
    ├─ 已分配 → 返回块号
    └─ 未分配 
        ├─ create=false → 返回 0
        └─ create=true  → 分配新块并更新 din->direct[index]

12 ≤ index < 1036 (间接索引)
    ├─ din->indirect == 0 (间接块不存在)
    │   ├─ create=false → 返回 0
    │   └─ create=true  → 分配间接块
    └─ din->indirect != 0 (间接块存在)
        ├─ 读取间接块中的 entry[index-12]
        ├─ entry[index-12] == 0 (数据块不存在)
        │   ├─ create=false → 返回 0
        │   └─ create=true  → 分配数据块并写入间接块
        └─ entry[index-12] != 0 → 返回数据块号
```

**使用场景：**
- **读文件**：`create=false`，只查找已分配的块
- **写文件**：`create=true`，必要时分配新块扩展文件
- 被 `sfs_bmap_load_nolock` 调用，是块映射的底层实现

**关键特性：**
- 支持按需分配（lazy allocation）：只在需要时才分配磁盘块
- 自动管理间接索引块：首次使用间接索引时自动创建间接块
- 错误处理：分配失败时自动清理已分配的资源

## Inode 操作函数

### 文件操作（File Operations）

SFS 为文件类型的 inode 定义了一组操作函数，对应用户进程的文件操作系统调用。

```c
// kern/fs/sfs/sfs_inode.c
static const struct inode_ops sfs_node_fileops = {
    .vop_magic                      = VOP_MAGIC,
    .vop_open                       = sfs_openfile,     // 打开文件
    .vop_close                      = sfs_close,        // 关闭文件
    .vop_read                       = sfs_read,         // 读文件
    .vop_write                      = sfs_write,        // 写文件
    .vop_fstat                      = sfs_fstat,        // 获取文件状态
    .vop_fsync                      = sfs_fsync,        // 同步文件到磁盘
    .vop_reclaim                    = sfs_reclaim,      // 回收 inode
    .vop_gettype                    = sfs_gettype,      // 获取文件类型
    .vop_tryseek                    = sfs_tryseek,      // 尝试定位
    .vop_truncate                   = sfs_truncfile,    // 截断文件
};
```

**主要操作说明：**

- **sfs_openfile**：打开文件操作，实际不需要做特殊处理，直接返回成功
- **sfs_close**：关闭文件，调用 `vop_fsync` 将修改的内容写回磁盘，确保数据持久化
- **sfs_read / sfs_write**：读写文件，都调用 `sfs_io` 函数，最终通过硬盘驱动完成实际的数据读写
- **sfs_fsync**：强制将内存中修改的 inode 数据（脏数据）同步到磁盘

**核心 I/O 函数：**

```c
// sfs_read - 读文件
static int
sfs_read(struct inode *node, struct iobuf *iob) {
    return sfs_io(node, iob, 0);  // write = 0 表示读操作
}

// sfs_write - 写文件
static int
sfs_write(struct inode *node, struct iobuf *iob) {
    return sfs_io(node, iob, 1);  // write = 1 表示写操作
}

// sfs_close - 关闭文件
static int
sfs_close(struct inode *node) {
    return vop_fsync(node);  // 将修改写回磁盘
}
```

### 目录操作（Directory Operations）

SFS 为目录类型的 inode 定义了一组操作函数，目录本质上也是一种特殊的文件。

```c
// kern/fs/sfs/sfs_inode.c
static const struct inode_ops sfs_node_dirops = {
    .vop_magic                      = VOP_MAGIC,
    .vop_open                       = sfs_opendir,      // 打开目录
    .vop_close                      = sfs_close,        // 关闭目录
    .vop_fstat                      = sfs_fstat,        // 获取目录状态
    .vop_fsync                      = sfs_fsync,        // 同步目录
    .vop_namefile                   = sfs_namefile,     // 获取文件路径名
    .vop_getdirentry                = sfs_getdirentry,  // 读取目录项
    .vop_reclaim                    = sfs_reclaim,      // 回收目录 inode
    .vop_gettype                    = sfs_gettype,      // 获取类型
    .vop_lookup                     = sfs_lookup,       // 查找文件
};
```

**主要操作说明：**

- **sfs_opendir**：打开目录，主要检查 `open_flags` 参数（目录只支持只读打开）
- **sfs_close**：关闭目录，与文件的 close 操作相同，同步修改到磁盘
- **sfs_getdirentry**：读取目录项，获取目录下文件的 inode 信息，用于实现 `ls` 等命令
- **sfs_lookup**：在目录中查找指定名称的文件，返回对应的 inode

**核心目录函数：**

```c
// sfs_opendir - 打开目录，检查打开标志
static int
sfs_opendir(struct inode *node, uint32_t open_flags) {
    switch (open_flags & O_ACCMODE) {
    case O_RDONLY:
        break;  // 目录只支持只读
    case O_WRONLY:
    case O_RDWR:
    default:
        return -E_ISDIR;  // 不能以写方式打开目录
    }
    if (open_flags & O_APPEND) {
        return -E_ISDIR;  // 目录不支持追加模式
    }
    return 0;
}

// sfs_lookup - 在目录中查找文件
static int
sfs_lookup(struct inode *node, char *path, struct inode **node_store) {
    struct sfs_fs *sfs = fsop_info(vop_fs(node), sfs);
    assert(*path != '\0' && *path != '/');
    
    struct sfs_inode *sin = vop_info(node, sfs_inode);
    if (sin->din->type != SFS_TYPE_DIR) {
        return -E_NOTDIR;  // 必须是目录类型
    }
    
    struct inode *subnode;
    // 调用 sfs_lookup_once 在目录中查找文件
    int ret = sfs_lookup_once(sfs, sin, path, &subnode, NULL);
    if (ret != 0) {
        return ret;
    }
    *node_store = subnode;
    return 0;
}
```

**文件与目录操作对比：**

| 操作 | 文件操作 | 目录操作 | 说明 |
| --- | --- | --- | --- |
| open | sfs_openfile | sfs_opendir | 目录需检查只读标志 |
| close | sfs_close | sfs_close | 完全相同，同步到磁盘 |
| read/write | sfs_read/sfs_write | - | 目录不支持直接读写 |
| 读取内容 | - | sfs_getdirentry | 读取目录项信息 |
| 查找 | - | sfs_lookup | 在目录中查找文件 |

## SFS 数据结构关系图

### 1. 磁盘布局结构

```
┌─────────────────────────────────────────────────────────────────────┐
│                         SFS 磁盘布局                                 │
├──────────┬──────────┬──────────┬──────────────────────────────────┤
│  Block 0 │ Block 1  │ Block 2  │  Block 3 ~ N                     │
│          │          │   ...    │                                  │
│superblock│root-inode│ freemap  │ inode/file data/dir data blocks  │
│          │          │          │                                  │
└──────────┴──────────┴──────────┴──────────────────────────────────┘
     │           │          │                    │
     ▼           ▼          ▼                    ▼
┌─────────┐ ┌─────────┐ ┌──────┐      ┌─────────────────┐
│sfs_super│ │disk_inode│ │bitmap│      │ 数据块/目录块    │
│  magic  │ │  size   │ │ ... │      │                 │
│  blocks │ │  type   │ └──────┘      │ sfs_disk_entry  │
│ unused  │ │ nlinks  │               │ sfs_disk_inode  │
│  info   │ │ blocks  │               │ 文件数据        │
└─────────┘ │ direct[]│               └─────────────────┘
            │indirect │
            └─────────┘
```

### 2. 核心数据结构关系

```
                    ┌──────────────────────┐
                    │      sfs_fs          │
                    │  (文件系统总控结构)    │
                    ├──────────────────────┤
                    │ sfs_super super      │◄─────── 超级块
                    │ device *dev          │
                    │ bitmap *freemap      │◄─────── 空闲块位图
                    │ list inode_list      │◄─────┐
                    │ list *hash_list      │      │
                    └──────────┬───────────┘      │
                               │                  │
                               │ 管理             │
                               ▼                  │
                    ┌──────────────────────┐      │
                    │     sfs_inode        │      │
                    │   (内存inode)        │      │
                    ├──────────────────────┤      │
                    │ disk_inode *din      │──┐   │ 链表连接
                    │ uint32_t ino         │  │   │
                    │ bool dirty           │  │   │
                    │ int reclaim_count    │  │   │
                    │ semaphore_t sem      │  │   │
                    │ list inode_link      │──┼───┘
                    │ list hash_link       │  │
                    └──────────┬───────────┘  │
                               │              │
                               │ 指向          │ 读取磁盘
                               ▼              ▼
                    ┌────────────────────────────┐
                    │    sfs_disk_inode          │
                    │   (磁盘inode, 存于磁盘)     │
                    ├────────────────────────────┤
                    │ uint32_t size              │
                    │ uint16_t type              │◄── FILE/DIR/LINK
                    │ uint16_t nlinks            │
                    │ uint32_t blocks            │
                    │ uint32_t direct[12]        │─┐
                    │ uint32_t indirect          │ │ 指向数据块
                    └────────────────────────────┘ │
                                                   ▼
                        ┌───────────────────────────────────┐
                        │        数据块 / 目录块             │
                        ├───────────────────────────────────┤
                        │  如果是目录:                       │
                        │  ┌─────────────────────┐          │
                        │  │  sfs_disk_entry     │          │
                        │  ├─────────────────────┤          │
                        │  │ uint32_t ino        │──►指向文件│
                        │  │ char name[...]      │   inode   │
                        │  └─────────────────────┘          │
                        │                                   │
                        │  如果是文件:                       │
                        │  实际的文件内容数据                │
                        └───────────────────────────────────┘
```

### 3. 文件访问流程

```
用户进程: open("/dir/file.txt")
    │
    ▼
┌────────────────────────────────┐
│  1. 从根目录开始               │
│  root inode (ino=1)            │
└────────┬───────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│  2. 读取根目录的 disk_inode     │
│  - type = DIR                  │
│  - direct[0] → 目录数据块      │
└────────┬───────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│  3. 读取目录数据块              │
│  遍历 sfs_disk_entry[]         │
│  查找 name="dir"               │
└────────┬───────────────────────┘
         │
         ▼ 找到 entry.ino = 10
┌────────────────────────────────┐
│  4. 加载子目录 inode (ino=10)  │
│  sfs_load_inode()              │
└────────┬───────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│  5. 在子目录中查找 "file.txt"  │
│  sfs_dirent_search_nolock()    │
└────────┬───────────────────────┘
         │
         ▼ 找到 entry.ino = 25
┌────────────────────────────────┐
│  6. 加载文件 inode (ino=25)    │
│  创建 sfs_inode (内存)         │
└────────┬───────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│  7. 返回 inode 给用户进程       │
│  可以进行 read/write 操作      │
└────────────────────────────────┘
```

### 4. 读写文件数据流程

```
用户: read(fd, buf, size)
    │
    ▼
┌────────────────────────────────┐
│  1. sfs_read(inode, iobuf)     │
│     └─► sfs_io(write=0)        │
└────────┬───────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│  2. sfs_io_nolock()            │
│  计算逻辑块号 = offset/4KB     │
└────────┬───────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│  3. sfs_bmap_load_nolock()     │
│  逻辑块号 → 物理块号           │
└────────┬───────────────────────┘
         │
         ├─► index < 12? 
         │   └─► 使用 direct[index]
         │
         └─► index >= 12?
             └─► 使用 indirect 间接索引
                 1. 读取间接块
                 2. 获取数据块号
         │
         ▼
┌────────────────────────────────┐
│  4. sfs_rbuf/sfs_rblock()      │
│  从磁盘读取数据块               │
└────────┬───────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│  5. 复制数据到用户缓冲区        │
│  返回读取的字节数               │
└────────────────────────────────┘
```

**关键点总结：**
1. **磁盘布局**：superblock → root-inode → freemap → data blocks
2. **内存管理**：`sfs_fs` 管理整个文件系统，`sfs_inode` 缓存磁盘 inode
3. **目录结构**：目录的数据块存储 `sfs_disk_entry` 数组（文件名→inode映射）
4. **文件数据**：通过 inode 的 direct/indirect 索引定位数据块
5. **路径解析**：逐级查找目录项，最终定位到目标文件的 inode









