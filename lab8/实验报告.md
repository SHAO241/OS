# 扩展练习 Challenge1：完成基于"UNIX的PIPE机制"的设计方案

## 1. PIPE机制概述

UNIX管道是一种进程间通信(IPC)机制，允许一个进程的输出作为另一个进程的输入。管道分为匿名管道(pipe)和命名管道(FIFO)两种类型。

## 2. 数据结构设计

### 2.1 管道缓冲区结构
```c
#define PIPE_BUF_SIZE 4096  // 管道缓冲区大小

struct pipe_buffer {
    char data[PIPE_BUF_SIZE];    // 环形缓冲区
    int read_pos;                // 读指针位置
    int write_pos;               // 写指针位置
    int count;                   // 当前数据量
    semaphore_t mutex;           // 互斥访问缓冲区
    semaphore_t not_full;        // 缓冲区非满信号量
    semaphore_t not_empty;       // 缓冲区非空信号量
    int readers;                 // 读端引用计数
    int writers;                 // 写端引用计数
    bool closed_read;            // 读端是否关闭
    bool closed_write;           // 写端是否关闭
};
```

### 2.2 管道文件描述符结构
```c
struct pipe_inode {
    struct pipe_buffer *buffer;  // 指向管道缓冲区
    bool is_read_end;           // 是否为读端
    bool is_write_end;          // 是否为写端
};
```

### 2.3 扩展file结构
在现有的`struct file`基础上，需要添加管道类型支持：
```c
struct file {
    enum {
        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,
        FD_PIPE_READ, FD_PIPE_WRITE  // 新增管道类型
    } status;
    bool readable;
    bool writable;
    int fd;
    off_t pos;
    union {
        struct inode *node;          // 普通文件
        struct pipe_inode *pipe;     // 管道文件
    };
    int open_count;
};
```

## 3. 接口设计

### 3.1 系统调用接口
```c
// 创建匿名管道，返回读写文件描述符
int sys_pipe(int pipefd[2]);

// 创建命名管道(FIFO)
int sys_mkfifo(const char *pathname, mode_t mode);
```

### 3.2 内核接口
```c
// 管道缓冲区管理
struct pipe_buffer *pipe_buffer_create(void);
void pipe_buffer_destroy(struct pipe_buffer *buffer);

// 管道读写操作
int pipe_read(struct pipe_buffer *buffer, void *buf, size_t count);
int pipe_write(struct pipe_buffer *buffer, const void *buf, size_t count);

// 管道文件操作
int pipe_open(struct pipe_inode *pipe, uint32_t flags);
int pipe_close(struct pipe_inode *pipe);
```

## 4. 同步互斥处理

### 4.1 缓冲区访问同步
- 使用`mutex`信号量保证对缓冲区的互斥访问
- 使用`not_full`信号量控制写操作，当缓冲区满时阻塞写进程
- 使用`not_empty`信号量控制读操作，当缓冲区空时阻塞读进程

### 4.2 管道生命周期管理
- 通过引用计数`readers`和`writers`管理管道的生命周期
- 当所有写端关闭时，读操作返回EOF
- 当所有读端关闭时，写操作产生SIGPIPE信号

### 4.3 死锁避免
- 读写操作使用非阻塞方式获取信号量，避免死锁
- 实现超时机制，防止进程无限期等待

## 5. 实现要点

### 5.1 环形缓冲区实现
```c
int pipe_write_internal(struct pipe_buffer *buffer, const void *buf, size_t count) {
    down(&buffer->mutex);
    
    while (buffer->count == PIPE_BUF_SIZE && !buffer->closed_read) {
        up(&buffer->mutex);
        down(&buffer->not_full);  // 等待缓冲区有空间
        down(&buffer->mutex);
    }
    
    if (buffer->closed_read) {
        up(&buffer->mutex);
        return -EPIPE;  // 读端已关闭
    }
    
    // 写入数据到环形缓冲区
    int written = 0;
    while (written < count && buffer->count < PIPE_BUF_SIZE) {
        buffer->data[buffer->write_pos] = ((char*)buf)[written];
        buffer->write_pos = (buffer->write_pos + 1) % PIPE_BUF_SIZE;
        buffer->count++;
        written++;
    }
    
    up(&buffer->mutex);
    up(&buffer->not_empty);  // 通知有数据可读
    return written;
}
```

### 5.2 进程fork时的管道处理
- 子进程继承父进程的文件描述符表
- 管道的引用计数需要相应增加
- 实现写时复制(COW)机制优化性能


# 扩展练习 Challenge2：完成基于"UNIX的软连接和硬连接机制"的设计方案

## 1. 链接机制概述

UNIX文件系统支持两种链接类型：
- **硬链接(Hard Link)**：多个文件名指向同一个inode，共享相同的数据块
- **软链接(Symbolic Link)**：包含指向另一个文件路径的特殊文件

## 2. 数据结构设计

### 2.1 扩展inode结构
```c
struct sfs_inode {
    struct sfs_disk_inode *din;     // 磁盘inode
    uint32_t ino;                   // inode编号
    bool dirty;                     // 是否需要写回磁盘
    int reclaim_count;              // 回收计数
    semaphore_t sem;                // inode信号量
    list_entry_t inode_link;        // inode链表
    list_entry_t hash_link;         // hash链表
    
    // 新增字段
    uint32_t nlinks;                // 硬链接计数
    uint32_t type;                  // 文件类型(普通文件/目录/符号链接)
};
```

### 2.2 磁盘inode结构扩展
```c
struct sfs_disk_inode {
    uint32_t size;                  // 文件大小
    uint16_t type;                  // 文件类型
    uint16_t nlinks;                // 硬链接计数
    uint32_t blocks;                // 数据块数量
    uint32_t direct[SFS_NDIRECT];   // 直接数据块索引
    uint32_t indirect;              // 间接数据块索引
    
    // 新增字段用于符号链接
    char symlink_target[SFS_MAX_SYMLINK_LEN];  // 符号链接目标路径
};
```

### 2.3 目录项结构
```c
struct sfs_disk_entry {
    uint32_t ino;                   // inode编号
    char name[SFS_MAX_FNAME_LEN + 1]; // 文件名
    uint8_t file_type;              // 文件类型标识
};
```

### 2.4 文件类型定义
```c
#define SFS_TYPE_INVAL    0         // 无效类型
#define SFS_TYPE_FILE     1         // 普通文件
#define SFS_TYPE_DIR      2         // 目录
#define SFS_TYPE_LINK     3         // 符号链接
#define SFS_MAX_SYMLINK_LEN 256     // 符号链接最大长度
```

## 3. 接口设计

### 3.1 系统调用接口
```c
// 创建硬链接
int sys_link(const char *oldpath, const char *newpath);

// 创建符号链接
int sys_symlink(const char *target, const char *linkpath);

// 读取符号链接内容
ssize_t sys_readlink(const char *pathname, char *buf, size_t bufsiz);

// 删除链接
int sys_unlink(const char *pathname);
```

### 3.2 VFS层接口
```c
// inode操作扩展
int vop_link(struct inode *old_node, struct inode *dir_node, const char *name);
int vop_symlink(struct inode *dir_node, const char *name, const char *target);
int vop_readlink(struct inode *node, struct iobuf *iob);
```

### 3.3 SFS文件系统接口
```c
// 硬链接操作
int sfs_link(struct inode *old_node, struct inode *dir_node, const char *name);
int sfs_unlink(struct inode *dir_node, const char *name);

// 符号链接操作
int sfs_symlink(struct inode *dir_node, const char *name, const char *target);
int sfs_readlink(struct inode *node, char *buf, size_t len);

// 链接计数管理
int sfs_nlinks_inc(struct inode *node);
int sfs_nlinks_dec(struct inode *node);
```

## 4. 同步互斥处理

### 4.1 inode级别同步
```c
// inode操作需要获取inode信号量
int sfs_link_safe(struct inode *old_node, struct inode *dir_node, const char *name) {
    down(&old_node->sem);
    down(&dir_node->sem);
    
    int ret = sfs_link_internal(old_node, dir_node, name);
    
    up(&dir_node->sem);
    up(&old_node->sem);
    return ret;
}
```

### 4.2 目录操作同步
- 目录修改操作需要获取目录的写锁
- 多个进程同时创建/删除链接时需要序列化
- 使用读写锁提高并发性能

### 4.3 引用计数同步
```c
// 原子操作管理链接计数
static inline void sfs_nlinks_inc_atomic(struct sfs_inode *sin) {
    atomic_inc(&sin->nlinks);
    sin->dirty = true;
}

static inline int sfs_nlinks_dec_atomic(struct sfs_inode *sin) {
    int nlinks = atomic_dec_return(&sin->nlinks);
    sin->dirty = true;
    return nlinks;
}
```

## 5. 实现要点

### 5.1 硬链接实现
```c
int sfs_link(struct inode *old_node, struct inode *dir_node, const char *name) {
    // 检查文件类型，目录不能创建硬链接
    if (sfs_get_type(old_node) == SFS_TYPE_DIR) {
        return -EPERM;
    }
    
    // 在目录中创建新的目录项
    struct sfs_disk_entry entry;
    entry.ino = sfs_get_ino(old_node);
    strncpy(entry.name, name, SFS_MAX_FNAME_LEN);
    entry.file_type = SFS_TYPE_FILE;
    
    int ret = sfs_add_direntry(dir_node, &entry);
    if (ret == 0) {
        // 增加硬链接计数
        sfs_nlinks_inc_atomic(vop_info(old_node, sfs_inode));
    }
    
    return ret;
}
```

### 5.2 符号链接实现
```c
int sfs_symlink(struct inode *dir_node, const char *name, const char *target) {
    // 创建新的inode
    struct inode *link_node;
    int ret = sfs_create_inode(dir_node, name, SFS_TYPE_LINK, &link_node);
    if (ret != 0) {
        return ret;
    }
    
    // 将目标路径写入inode
    struct sfs_inode *sin = vop_info(link_node, sfs_inode);
    strncpy(sin->din->symlink_target, target, SFS_MAX_SYMLINK_LEN);
    sin->din->size = strlen(target);
    sin->dirty = true;
    
    vop_ref_dec(link_node);
    return 0;
}
```

### 5.3 路径解析处理
```c
int sfs_lookup_follow_links(struct inode *node, char *path, 
                           struct inode **node_store, int max_depth) {
    if (max_depth <= 0) {
        return -ELOOP;  // 防止符号链接循环
    }
    
    struct inode *current = node;
    vop_ref_inc(current);
    
    // 解析路径中的每个组件
    char *component = strtok(path, "/");
    while (component != NULL) {
        struct inode *next;
        int ret = vop_lookup(current, component, &next);
        if (ret != 0) {
            vop_ref_dec(current);
            return ret;
        }
        
        // 检查是否为符号链接
        uint32_t type;
        vop_gettype(next, &type);
        if (type == SFS_TYPE_LINK) {
            // 读取符号链接目标
            char target[SFS_MAX_SYMLINK_LEN];
            ret = sfs_readlink(next, target, sizeof(target));
            if (ret < 0) {
                vop_ref_dec(current);
                vop_ref_dec(next);
                return ret;
            }
            
            vop_ref_dec(next);
            
            // 递归解析符号链接
            if (target[0] == '/') {
                // 绝对路径，从根目录开始
                ret = sfs_lookup_follow_links(sfs_get_root(), target, 
                                            &next, max_depth - 1);
            } else {
                // 相对路径，从当前目录开始
                ret = sfs_lookup_follow_links(current, target, 
                                            &next, max_depth - 1);
            }
            
            if (ret != 0) {
                vop_ref_dec(current);
                return ret;
            }
        }
        
        vop_ref_dec(current);
        current = next;
        component = strtok(NULL, "/");
    }
    
    *node_store = current;
    return 0;
}
```

### 5.4 文件删除处理
```c
int sfs_unlink(struct inode *dir_node, const char *name) {
    struct inode *node;
    int ret = vop_lookup(dir_node, (char *)name, &node);
    if (ret != 0) {
        return ret;
    }
    
    // 从目录中删除条目
    ret = sfs_remove_direntry(dir_node, name);
    if (ret != 0) {
        vop_ref_dec(node);
        return ret;
    }
    
    // 减少硬链接计数
    struct sfs_inode *sin = vop_info(node, sfs_inode);
    int nlinks = sfs_nlinks_dec_atomic(sin);
    
    // 如果链接计数为0，释放inode和数据块
    if (nlinks == 0) {
        sfs_free_inode(node);
    }
    
    vop_ref_dec(node);
    return 0;
}
```

## 6. 错误处理和边界情况

### 6.1 符号链接循环检测
- 限制符号链接解析深度(如40层)
- 检测路径解析过程中的循环引用

### 6.2 权限检查
- 创建链接需要对目标目录有写权限
- 符号链接的权限检查在目标文件上进行

### 6.3 跨文件系统链接
- 硬链接不能跨文件系统
- 符号链接可以指向任意路径