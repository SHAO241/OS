# sched_test.c 测试使用说明

## 一、编译和运行测试

### 方法1：直接运行（推荐）

在项目根目录下执行：

```bash
make run-nox-sched_test
```

或者：

```bash
make run-sched_test
```

这个命令会：
1. 自动编译 `user/sched_test.c` 为二进制文件
2. 将二进制文件链接到内核中
3. 启动 QEMU 运行测试程序

### 方法2：分步执行

1. **编译测试程序**：
```bash
make build-sched_test
```

2. **运行 QEMU**：
```bash
make qemu
```

## 二、切换调度算法

在运行测试之前，需要先选择要测试的调度算法。

### 步骤：

1. **编辑调度器初始化文件**：
```bash
vim kern/schedule/sched.c
```

2. **修改 `sched_init()` 函数**（约第55行）：

```c
void sched_init(void)
{
    list_init(&timer_list);

    // 选择要测试的调度算法（取消注释其中一个）
    // sched_class = &default_sched_class;  // RR调度（默认）
    sched_class = &fifo_sched_class;       // FIFO调度
    // sched_class = &sjf_sched_class;     // SJF调度

    rq = &__rq;
    rq->max_time_slice = MAX_TIME_SLICE;
    sched_class->init(rq);

    cprintf("sched class: %s\n", sched_class->name);
}
```

3. **重新编译**：
```bash
make clean
make run-nox-sched_test
```

## 三、测试流程示例

### 测试 FIFO 调度算法：

```bash
# 1. 修改 sched.c，设置 sched_class = &fifo_sched_class;
# 2. 编译并运行
make clean
make run-nox-sched_test
```

### 测试 SJF 调度算法：

```bash
# 1. 修改 sched.c，设置 sched_class = &sjf_sched_class;
# 2. 编译并运行
make clean
make run-nox-sched_test
```

### 测试 RR 调度算法：

```bash
# 1. 修改 sched.c，设置 sched_class = &default_sched_class;
# 2. 编译并运行
make clean
make run-nox-sched_test
```

## 四、测试输出说明

测试程序会输出以下信息：

1. **进程信息**：每个进程的启动时间、完成时间、执行时间
2. **调度指标表格**：
   - Burst: 预期执行时间
   - Finish: 完成时间
   - Wait: 等待时间
   - Turnaround: 周转时间
   - Response: 响应时间
3. **平均指标**：
   - Average Wait Time: 平均等待时间
   - Average Turnaround Time: 平均周转时间
   - Average Response Time: 平均响应时间
4. **完成顺序**：进程完成的顺序

## 五、完整测试流程

为了全面比较三种调度算法，建议按以下步骤进行：

### 步骤1：测试 FIFO
```bash
# 编辑 kern/schedule/sched.c，设置 sched_class = &fifo_sched_class;
make clean
make run-nox-sched_test > fifo_result.txt 2>&1
```

### 步骤2：测试 SJF
```bash
# 编辑 kern/schedule/sched.c，设置 sched_class = &sjf_sched_class;
make clean
make run-nox-sched_test > sjf_result.txt 2>&1
```

### 步骤3：测试 RR
```bash
# 编辑 kern/schedule/sched.c，设置 sched_class = &default_sched_class;
make clean
make run-nox-sched_test > rr_result.txt 2>&1
```

### 步骤4：对比结果
```bash
# 查看各算法的测试结果
cat fifo_result.txt
cat sjf_result.txt
cat rr_result.txt
```

## 六、注意事项

1. **SJF 算法**：测试程序会自动通过 `lab6_setpriority()` 设置每个进程的 burst time（预期执行时间）

2. **时间精度**：由于是模拟环境，时间可能不够精确，重点关注相对比较和完成顺序

3. **进程主动让出CPU**：
   - FIFO 和 SJF 算法依赖进程主动退出（通过 `exit()`）
   - 如果进程不主动退出，会一直占用 CPU

4. **编译错误**：如果遇到编译错误，确保：
   - `kern/schedule/fifo_sched.c` 和 `kern/schedule/sjf_sched.c` 已正确创建
   - `kern/schedule/default_sched.h` 已更新
   - `CMakeLists.txt` 或 `Makefile` 已包含新文件

## 七、快速命令参考

```bash
# 清理并编译运行 FIFO 测试
make clean && make run-nox-sched_test

# 清理并编译运行 SJF 测试  
make clean && make run-nox-sched_test

# 清理并编译运行 RR 测试
make clean && make run-nox-sched_test

# 只编译不运行
make build-sched_test

# 只运行（需要先编译）
make qemu
```

## 八、预期结果

根据调度算法的特点，预期结果应该是：

- **FIFO**: 进程按创建顺序完成，平均等待时间中等
- **SJF**: 短作业先完成，平均等待时间和周转时间应该最小
- **RR**: 进程轮流执行，响应时间应该较好

通过对比三种算法的输出，可以定量分析各算法的优缺点。

