# FIFO和SJF调度算法实现详解

## 调度框架概述

### 调度器框架设计

ucore的调度系统采用了**策略与机制分离**的设计思想，通过`struct sched_class`结构体实现了可插拔的调度算法框架。这种设计使得不同的调度算法可以无缝切换，而无需修改核心调度代码。

### 核心数据结构

#### 1. 调度类结构 (`struct sched_class`)

定义在`kern/schedule/sched.h`中：

```c
struct sched_class
{
    const char *name;                                    // 调度器名称
    void (*init)(struct run_queue *rq);                 // 初始化运行队列
    void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);  // 进程入队
    void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);  // 进程出队
    struct proc_struct *(*pick_next)(struct run_queue *rq);          // 选择下一个进程
    void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc); // 时钟中断处理
};
```

#### 2. 运行队列结构 (`struct run_queue`)

```c
struct run_queue
{
    list_entry_t run_list;      // 就绪进程链表头
    unsigned int proc_num;      // 队列中进程数量
    int max_time_slice;         // 最大时间片
    skew_heap_entry_t *lab6_run_pool;  // 用于其他调度算法（如Stride）
};
```

### 调度流程

调度器的核心流程在`kern/schedule/sched.c`的`schedule()`函数中：

```c
void schedule(void)
{
    bool intr_flag;
    struct proc_struct *next;
    local_intr_save(intr_flag);  // 关中断，保证原子性
    {
        current->need_resched = 0;
        // 如果当前进程仍可运行，将其重新入队
        if (current->state == PROC_RUNNABLE)
        {
            sched_class_enqueue(current);
        }
        // 选择下一个要运行的进程
        if ((next = sched_class_pick_next()) != NULL)
        {
            sched_class_dequeue(next);
        }
        if (next == NULL)
        {
            next = idleproc;  // 如果没有就绪进程，运行idle进程
        }
        next->runs++;
        if (next != current)
        {
            proc_run(next);  // 切换到新进程
        }
    }
    local_intr_restore(intr_flag);  // 恢复中断
}
```

---

## FIFO调度算法实现

### 算法原理

**FIFO (First In First Out)**，即先来先服务调度算法，是最简单的调度策略：
- 进程按照到达就绪队列的顺序执行
- 先到达的进程先执行，后到达的进程后执行
- 进程一旦开始执行，会一直运行直到完成或主动让出CPU

### 代码实现分析

#### 1. 初始化函数 (`FIFO_init`)

**文件位置**: `kern/schedule/fifo_sched.c:15-21`

```c
static void
FIFO_init(struct run_queue *rq)
{
    list_init(&rq->run_list);    // 初始化双向循环链表
    rq->proc_num = 0;            // 进程数量初始化为0
    rq->lab6_run_pool = NULL;    // 不使用斜堆
}
```

**功能说明**:
- 初始化运行队列的链表头，使其成为一个空的双向循环链表
- 将进程计数器置为0
- 由于FIFO使用链表而非堆，`lab6_run_pool`设为NULL

**关键点**: `list_init`会将链表的`prev`和`next`指针都指向自身，形成一个空的双向循环链表。

#### 2. 入队函数 (`FIFO_enqueue`)

**文件位置**: `kern/schedule/fifo_sched.c:33-41`

```c
static void
FIFO_enqueue(struct run_queue *rq, struct proc_struct *proc)
{
    // FIFO: 先来先服务，添加到队列尾部
    proc->time_slice = rq->max_time_slice;  // 设置时间片（虽然FIFO不使用）
    proc->rq = rq;                          // 记录所属队列
    list_add_before(&rq->run_list, &proc->run_link);  // 添加到队尾
    rq->proc_num++;                         // 进程数加1
}
```

**功能说明**:
- **设置时间片**: 虽然FIFO不使用时间片强制切换，但为了兼容框架，仍然设置时间片值
- **记录队列**: 将进程的`rq`指针指向当前运行队列
- **添加到队尾**: 使用`list_add_before(&rq->run_list, &proc->run_link)`将进程添加到链表尾部
  - 在双向循环链表中，`run_list`是链表头，`list_add_before`在头节点之前插入，即添加到尾部
- **更新计数**: 增加队列中的进程数量

**关键点**: 
- `list_add_before`是双向链表的插入操作，时间复杂度O(1)
- FIFO的入队操作非常简单，只需要添加到队尾，不需要排序

#### 3. 出队函数 (`FIFO_dequeue`)

**文件位置**: `kern/schedule/fifo_sched.c:48-57`

```c
static void
FIFO_dequeue(struct run_queue *rq, struct proc_struct *proc)
{
    list_del_init(&proc->run_link);  // 从链表中删除并重新初始化节点
    if (rq->proc_num > 0)
    {
        rq->proc_num--;              // 进程数减1
    }
    proc->rq = NULL;                 // 清除队列指针
}
```

**功能说明**:
- **删除节点**: `list_del_init`从链表中删除进程节点，并将节点的`prev`和`next`重新初始化为指向自身
- **更新计数**: 减少队列中的进程数量（需要检查避免下溢）
- **清除关联**: 将进程的`rq`指针设为NULL，表示进程不再属于任何队列

**关键点**: `list_del_init`不仅删除节点，还重新初始化，确保节点可以安全地再次使用。

#### 4. 选择下一个进程 (`FIFO_pick_next`)

**文件位置**: `kern/schedule/fifo_sched.c:64-73`

```c
static struct proc_struct *
FIFO_pick_next(struct run_queue *rq)
{
    if (list_empty(&rq->run_list))  // 检查队列是否为空
    {
        return NULL;
    }
    list_entry_t *le = list_next(&rq->run_list);  // 获取队列头部节点
    return le2proc(le, run_link);                  // 转换为进程结构体指针
}
```

**功能说明**:
- **检查空队列**: 如果队列为空，返回NULL
- **获取队首**: `list_next(&rq->run_list)`获取链表头节点的下一个节点，即队列的第一个进程
- **类型转换**: `le2proc`宏将链表节点指针转换为进程结构体指针
  - `le2proc(le, run_link)` = `to_struct(le, struct proc_struct, run_link)`
  - 通过计算`run_link`在`proc_struct`中的偏移量，从链表节点地址反推出进程结构体地址

**关键点**: 
- FIFO总是选择队列头部的进程，即最早入队的进程
- 时间复杂度O(1)

#### 5. 时钟中断处理 (`FIFO_proc_tick`)

**文件位置**: `kern/schedule/fifo_sched.c:84-94`

```c
static void
FIFO_proc_tick(struct run_queue *rq, struct proc_struct *proc)
{
    // FIFO调度算法不使用时间片限制，进程运行直到完成
    // 但为了兼容框架，仍然更新时间片计数
    if (proc->time_slice > 0)
    {
        proc->time_slice--;
    }
    // FIFO不使用时间片强制切换，只依赖进程主动让出CPU
}
```

**功能说明**:
- **更新时间片**: 虽然FIFO不使用时间片强制切换，但为了兼容框架，仍然递减时间片计数
- **不强制切换**: FIFO不会在时间片用完时设置`need_resched`标志
- **依赖主动让出**: 进程必须主动调用`yield()`或`exit()`来让出CPU

**关键点**: 与RR算法不同，FIFO不会因为时间片用完而强制切换进程。

### FIFO算法特点总结

1. **实现简单**: 只需要简单的链表操作，时间复杂度低
2. **公平性**: 先来先服务，对所有进程公平
3. **无抢占**: 进程一旦开始运行，会一直运行直到完成
4. **护航效应**: 如果长作业先到达，短作业需要等待很长时间

---

## SJF调度算法实现

### 算法原理

**SJF (Shortest Job First)**，即最短作业优先调度算法：
- 优先执行预期执行时间（burst time）最短的进程
- 通过最小化短作业的等待时间，可以最小化平均等待时间和平均周转时间
- 需要预先知道每个进程的执行时间

### 代码实现分析

#### 1. 初始化函数 (`SJF_init`)

**文件位置**: `kern/schedule/sjf_sched.c:15-21`

```c
static void
SJF_init(struct run_queue *rq)
{
    list_init(&rq->run_list);    // 初始化双向循环链表
    rq->proc_num = 0;            // 进程数量初始化为0
    rq->lab6_run_pool = NULL;    // 不使用斜堆
}
```

**功能说明**: 与FIFO相同，初始化一个空的运行队列。

#### 2. 入队函数 (`SJF_enqueue`)

**文件位置**: `kern/schedule/sjf_sched.c:35-82`

这是SJF算法的核心函数，实现了按burst time排序插入：

```c
static void
SJF_enqueue(struct run_queue *rq, struct proc_struct *proc)
{
    // SJF: 最短作业优先，按照burst time（存储在lab6_priority中）排序插入
    proc->time_slice = rq->max_time_slice;
    
    // 如果进程已经在队列中，先将其移除（防止重复插入导致链表破坏）
    if (proc->rq != NULL && proc->rq == rq)
    {
        list_del_init(&proc->run_link);
        if (rq->proc_num > 0)
        {
            rq->proc_num--;
        }
    }
    
    proc->rq = rq;
    
    // 如果队列为空，直接添加
    if (list_empty(&rq->run_list))
    {
        list_add_before(&rq->run_list, &proc->run_link);
    }
    else
    {
        // 找到合适的位置插入，保持按burst time从小到大排序
        list_entry_t *le = list_next(&rq->run_list);
        bool inserted = 0;
        while (le != &rq->run_list)
        {
            struct proc_struct *p = le2proc(le, run_link);
            // 如果当前进程的burst time小于等于队列中进程的burst time，插入到它之前
            if (proc->lab6_priority <= p->lab6_priority)
            {
                list_add_before(le, &proc->run_link);
                inserted = 1;
                break;
            }
            le = list_next(le);
        }
        // 如果遍历完整个队列还没插入，说明应该插入到队尾
        if (!inserted)
        {
            list_add_before(&rq->run_list, &proc->run_link);
        }
    }
    rq->proc_num++;
}
```

**功能说明**:

1. **设置基本属性**:
   - 设置时间片和队列指针

2. **防止重复插入**:
   ```c
   if (proc->rq != NULL && proc->rq == rq)
   {
       list_del_init(&proc->run_link);
       // ...
   }
   ```
   - 如果进程已经在队列中，先将其移除
   - 这防止了重复插入导致链表结构破坏的问题

3. **空队列处理**:
   - 如果队列为空，直接添加到队尾

4. **有序插入**（核心逻辑）:
   ```c
   list_entry_t *le = list_next(&rq->run_list);
   bool inserted = 0;
   while (le != &rq->run_list)
   {
       struct proc_struct *p = le2proc(le, run_link);
       if (proc->lab6_priority <= p->lab6_priority)
       {
           list_add_before(le, &proc->run_link);
           inserted = 1;
           break;
       }
       le = list_next(le);
   }
   ```
   - 遍历队列，找到第一个burst time大于等于当前进程的位置
   - 使用`proc->lab6_priority`存储burst time（预期执行时间）
   - 插入到该位置之前，保持队列按burst time从小到大排序

5. **队尾插入**:
   - 如果遍历完整个队列还没找到合适位置，说明当前进程的burst time最大，插入到队尾

**关键点**:
- **时间复杂度**: O(n)，其中n是队列中的进程数
- **排序策略**: 使用插入排序的思想，保持队列有序
- **burst time存储**: 使用`proc->lab6_priority`字段存储，通过`lab6_setpriority()`设置

#### 3. 出队函数 (`SJF_dequeue`)

**文件位置**: `kern/schedule/sjf_sched.c:89-98`

```c
static void
SJF_dequeue(struct run_queue *rq, struct proc_struct *proc)
{
    list_del_init(&proc->run_link);
    if (rq->proc_num > 0)
    {
        rq->proc_num--;
    }
    proc->rq = NULL;
}
```

**功能说明**: 与FIFO完全相同，从链表中删除进程节点。

#### 4. 选择下一个进程 (`SJF_pick_next`)

**文件位置**: `kern/schedule/sjf_sched.c:106-116`

```c
static struct proc_struct *
SJF_pick_next(struct run_queue *rq)
{
    if (list_empty(&rq->run_list))
    {
        return NULL;
    }
    // 由于enqueue时已经按burst time排序，队列头部就是最短作业
    list_entry_t *le = list_next(&rq->run_list);
    return le2proc(le, run_link);
}
```

**功能说明**:
- **选择队首**: 由于`enqueue`时已经按burst time排序，队列头部就是burst time最短的进程
- **时间复杂度**: O(1)，因为不需要遍历查找

**关键点**: SJF的`pick_next`非常简单，因为队列已经是有序的，队首就是最短作业。

#### 5. 时钟中断处理 (`SJF_proc_tick`)

**文件位置**: `kern/schedule/sjf_sched.c:127-137`

```c
static void
SJF_proc_tick(struct run_queue *rq, struct proc_struct *proc)
{
    // SJF调度算法不使用时间片限制，进程运行直到完成
    // 但为了兼容框架，仍然更新时间片计数
    if (proc->time_slice > 0)
    {
        proc->time_slice--;
    }
    // SJF不使用时间片强制切换，只依赖进程主动让出CPU
}
```

**功能说明**: 与FIFO相同，不使用时间片强制切换。

### SJF算法特点总结

1. **最优平均等待时间**: 理论上可以最小化平均等待时间和平均周转时间
2. **需要预知执行时间**: 必须预先知道每个进程的burst time
3. **可能饥饿**: 如果不断有短作业到达，长作业可能永远得不到执行
4. **实现复杂度**: 入队时需要排序，时间复杂度O(n)

---

## 两种算法对比

### 实现对比表

| 特性 | FIFO | SJF |
|------|------|-----|
| **入队操作** | O(1) - 直接添加到队尾 | O(n) - 需要找到合适位置插入 |
| **出队操作** | O(1) - 从队首删除 | O(1) - 从队首删除 |
| **选择进程** | O(1) - 直接选择队首 | O(1) - 直接选择队首（已排序） |
| **时间片** | 不使用 | 不使用 |
| **抢占** | 非抢占 | 非抢占 |
| **公平性** | 公平（先来先服务） | 不公平（短作业优先） |
| **平均等待时间** | 中等 | 最优（理论上） |
| **实现复杂度** | 简单 | 中等 |

### 代码差异分析

#### 1. 入队操作的差异

**FIFO**:
```c
// 简单添加到队尾
list_add_before(&rq->run_list, &proc->run_link);
```

**SJF**:
```c
// 需要遍历队列找到合适位置
while (le != &rq->run_list)
{
    struct proc_struct *p = le2proc(le, run_link);
    if (proc->lab6_priority <= p->lab6_priority)
    {
        list_add_before(le, &proc->run_link);
        inserted = 1;
        break;
    }
    le = list_next(le);
}
```

**关键差异**: SJF需要遍历队列进行排序，而FIFO直接添加。

#### 2. 数据结构使用

两种算法都使用相同的双向循环链表，但使用方式不同：
- **FIFO**: 链表仅作为队列使用，不维护顺序
- **SJF**: 链表作为有序队列使用，始终保持按burst time排序

#### 3. 进程属性使用

- **FIFO**: 不使用`lab6_priority`字段
- **SJF**: 使用`lab6_priority`存储burst time（预期执行时间）

### 使用场景

**FIFO适用于**:
- 简单系统
- 进程执行时间相近
- 需要公平性的场景

**SJF适用于**:
- 批处理系统
- 可以预先知道进程执行时间
- 需要最小化平均等待时间的场景

---

## 关键数据结构

### 进程结构体相关字段

在`kern/process/proc.h`中定义的`struct proc_struct`包含以下调度相关字段：

```c
struct proc_struct
{
    // ... 其他字段 ...
    struct run_queue *rq;           // 指向所属的运行队列
    list_entry_t run_link;         // 用于链接到运行队列的链表节点
    int time_slice;                // 剩余时间片
    uint32_t lab6_priority;        // 优先级（SJF中用作burst time）
    // ... 其他字段 ...
};
```

### 链表操作宏

在`libs/list.h`中定义的关键宏：

- `list_init(elm)`: 初始化链表节点
- `list_add_before(listelm, elm)`: 在指定节点之前插入
- `list_del_init(listelm)`: 删除节点并重新初始化
- `list_empty(list)`: 检查链表是否为空
- `list_next(listelm)`: 获取下一个节点

### 类型转换宏

在`kern/process/proc.h`中定义：

```c
#define le2proc(le, member) \
    to_struct((le), struct proc_struct, member)
```

这个宏将链表节点指针转换为进程结构体指针，通过计算成员在结构体中的偏移量实现。

---

## 总结

### 实现要点

1. **FIFO**: 实现简单，使用链表作为队列，O(1)时间复杂度
2. **SJF**: 使用有序链表，入队时排序，保持队列有序
3. **非抢占**: 两种算法都不使用时间片强制切换，依赖进程主动让出CPU

---

## 测试结果
### RR
```
=== Scheduling Metrics ===
Process | Burst | Finish | Wait | Turnaround | Response
--------|-------|--------|------|------------|---------
  P1   |  1000 |   1230 |  220 |      1220   |     10
  P2   |   500 |   1230 |  720 |      1220   |     10
  P3   |  2000 |   2120 |  110 |      2110   |     10
  P4   |   300 |   2130 | 1820 |      2120   |     10
  P5   |  1500 |   2130 |  620 |      2120   |     10

=== Average Metrics ===
Average Wait Time:      698 ms
Average Turnaround Time: 1758 ms
Average Response Time:   10 ms

=== Completion Order ===
Processes completed in order: P1 P2 P3 P4 P5 

=== Test Completed ===
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:553:
    initproc exit.
```
### FIFO
```
=== Scheduling Metrics ===
Process | Burst | Finish | Wait | Turnaround | Response
--------|-------|--------|------|------------|---------
  P1   |  1000 |   5340 | 4340 |      5340   |     20
  P2   |   500 |   5350 | 4840 |      5340   |     10
  P3   |  2000 |   5350 | 3340 |      5340   |     10
  P4   |   300 |   5350 | 5040 |      5340   |     10
  P5   |  1500 |   5360 | 3850 |      5350   |     10

=== Average Metrics ===
Average Wait Time:      4282 ms
Average Turnaround Time: 5342 ms
Average Response Time:   12 ms

=== Completion Order ===
Processes completed in order: P1 P2 P3 P4 P5 

=== Test Completed ===
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:553:
    initproc exit.
```
### SJF
```
sched class: SJF_scheduler
++ setup timer interrupts
kernel_execve: pid = 2, name = "sched_test".
set priority to 6
=== Scheduler Test Started at 10 ===
Process burst times: 1000 500 2000 300 1500 
Main: All 5 processes forked, waiting for completion...
set priority to 300
Process 6: started at 30, burst_time=300
Process 6: finished at 367, acc=144000, elapsed=337
set priority to 500
Process 4: started at 377, burst_time=500
100 ticks
Process 4: finished at 902, acc=244000, elapsed=525
set priority to 1000
Process 3: started at 902, burst_time=1000
100 ticks
Process 3: finished at 2005, acc=500000, elapsed=1103
set priority to 1500
Process 7: started at 2005, burst_time=1500
100 ticks
Process 7: finished at 3567, acc=752000, elapsed=1562
set priority to 2000
Process 5: started at 3567, burst_time=2000
100 ticks
100 ticks
Process 5: finished at 5688, acc=992000, elapsed=2121

=== Scheduling Metrics ===
Process | Burst | Finish | Wait | Turnaround | Response
--------|-------|--------|------|------------|---------
  P1   |  1000 |   2005  | 902  |      5320   |     10
  P2   |   500 |   902   | 377  |      5320   |     10
  P3   |  2000 |   5688  | 3567 |      5330   |     10
  P4   |   300 |   367   | 30   |      5330   |     10
  P5   |  1500 |   3567  | 2005 |      5340   |     10

=== Average Metrics ===
Average Wait Time:      4268 ms
Average Response Time:   10 ms

=== Completion Order ===
Processes completed in order: P4 P2 P1 P5 P3 

=== Test Completed ===
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:553:
    initproc exit.
```
### 实验结果
- **FIFO**: 进程按创建顺序完成，平均等待时间中等
- **SJF**: 短作业先完成
- **RR**: 进程轮流执行，响应时间较好
