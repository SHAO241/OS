# Lab5 实验报告：用户进程管理

# 练习1: 加载应用程序并执行（需要编码）

## 设计实现过程

`load_icode` 函数的主要功能是将一个 ELF 格式的二进制程序加载到当前进程的内存空间中，并准备好执行环境。在完成了内存空间的建立（创建 mm、页表、加载 ELF 段、建立用户栈）之后，关键的一步是设置 `trapframe`，以便内核在返回用户态时能够正确地跳转到应用程序的入口点并设置正确的处理器状态。

具体实现如下：
1.  **设置栈指针 (`tf->gpr.sp`)**: 将其设置为用户栈的顶部 `USTACKTOP`。用户栈在之前的步骤中已经分配并映射到了 `USTACKTOP` 以下的区域。
2.  **设置程序计数器 (`tf->epc`)**: 将其设置为 ELF 头中指定的入口点 `elf->e_entry`。当执行 `sret` 指令返回用户态时，CPU 会跳转到这个地址开始执行。
3.  **设置处理器状态 (`tf->status`)**:
    *   我们需要清除 `SSTATUS_SPP` 位（设置为 0），表示之前的特权级（Previous Privilege）是 User Mode。这样 `sret` 后 CPU 会切换到用户模式。
    *   我们需要设置 `SSTATUS_SPIE` 位（设置为 1），表示之前的终端使能（Previous Interrupt Enable）是开启的。这样返回用户态后，中断会被允许。

### 代码实现

在 `kern/process/proc.c` 的 `load_icode` 函数第 6 步中补充如下代码：

```c
//(6) setup trapframe for user environment
struct trapframe *tf = current->tf;
// Keep sstatus
uintptr_t sstatus = tf->status;
memset(tf, 0, sizeof(struct trapframe));
/* LAB5:EXERCISE1 YOUR CODE
 * should set tf->gpr.sp, tf->epc, tf->status
 * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So
 *          tf->gpr.sp should be user stack top (the value of sp)
 *          tf->epc should be entry point of user program (the value of sepc)
 *          tf->status should be appropriate for user program (the value of sstatus)
 *          hint: check meaning of SPP, SPIE in SSTATUS, use them by SSTATUS_SPP, SSTATUS_SPIE(defined in risv.h)
 */
tf->gpr.sp = USTACKTOP;                                      // 设置用户栈顶
tf->epc = elf->e_entry;                                      // 设置程序入口点
tf->status = (read_csr(sstatus) & ~SSTATUS_SPP) | SSTATUS_SPIE;  // 设置用户模式，开启中断
```

同时，需要更新 `alloc_proc` 函数，初始化 Lab5 新增的成员变量：

```c
static struct proc_struct *
alloc_proc(void)
{
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL)
    {
        // LAB4:EXERCISE1 YOUR CODE
        proc->state = PROC_UNINIT;                     // 设置进程为未初始化状态
        proc->pid = -1;                                // 未分配PID
        proc->runs = 0;                                // 运行次数初始化为0
        proc->kstack = 0;                              // 内核栈地址初始化为0
        proc->need_resched = 0;                        // 不需要调度
        proc->parent = NULL;                           // 父进程为空
        proc->mm = NULL;                               // 内存管理结构为空
        memset(&(proc->context), 0, sizeof(struct context)); // 初始化上下文
        proc->tf = NULL;                               // 中断帧指针为空
        proc->pgdir = boot_pgdir_pa;                   // 页目录为内核页目录的物理地址
        proc->flags = 0;                               // 标志位为0
        memset(proc->name, 0, PROC_NAME_LEN + 1);      // 进程名初始化为0
        // LAB5 YOUR CODE : (update LAB4 steps)
        proc->wait_state = 0;                          // 初始化等待状态
        proc->cptr = proc->optr = proc->yptr = NULL;   // 初始化进程关系指针
    }
    return proc;
}
```

## 执行流程描述

从用户态进程被 ucore 选择占用 CPU 执行（RUNNING 态）到具体执行应用程序第一条指令的经过如下：

1.  **调度**: 内核调度器 `schedule()` 函数决定运行当前进程，调用 `proc_run(current)`。
2.  **上下文切换**: `proc_run` 调用 `switch_to`，保存当前进程（或调度器线程）的上下文，并恢复目标进程的上下文（包括寄存器 `ra`, `sp`, `s0`-`s11` 等）。
3.  **内核入口**: `switch_to` 返回后，CPU 开始执行目标进程的代码。对于新创建的进程，`ra` 指向 `forkret` 函数。
4.  **Trap 返回准备**: `forkret` 调用 `forkrets(current->tf)`。`forkrets` 是汇编代码（位于 `trapentry.S`），它将 `current->tf`（即我们在 `load_icode` 中设置的 `trapframe`）作为参数。
5.  **恢复寄存器**: `forkrets` 跳转到 `__trapret`，该段汇编代码从 `trapframe` 中恢复所有通用寄存器（包括 `sp`）和 CSR 寄存器（`sstatus`, `sepc`）。
    *   `sp` 被恢复为 `USTACKTOP`。
    *   `sepc` 被恢复为应用程序入口地址。
    *   `sstatus` 被恢复为用户模式且开启中断的状态。
6.  **切换到用户态**: 执行 `sret` 指令。CPU 根据 `sstatus.SPP` 切换到用户模式，根据 `sstatus.SPIE` 开启中断，并跳转到 `sepc` 指向的地址。
7.  **执行**: CPU 开始执行应用程序的第一条指令。

---

# 练习2: 父进程复制自己的内存空间给子进程（需要编码）

## 设计实现过程

`do_fork` 函数在创建子进程时，如果需要复制父进程的内存空间（即不是共享内存的线程），会调用 `copy_mm` -> `dup_mmap` -> `copy_range`。`copy_range` 的任务是将父进程的一段内存空间（从 `start` 到 `end`）的内容复制给子进程。

具体实现如下：
1.  **遍历页表**: 循环遍历指定范围内的每一个页面。
2.  **获取源页面**: 使用 `get_pte` 获取父进程对应地址的页表项，并用 `pte2page` 找到对应的物理页结构 `page`。
3.  **分配目标页面**: 为子进程分配一个新的物理页 `npage`。
4.  **复制内容**:
    *   使用 `page2kva(page)` 获取源页面的内核虚拟地址。
    *   使用 `page2kva(npage)` 获取目标页面的内核虚拟地址。
    *   使用 `memcpy` 将源页面的内容（`PGSIZE` 字节）完全复制到目标页面。
5.  **建立映射**: 调用 `page_insert` 将新的物理页 `npage` 映射到子进程的页表中，线性地址为 `start`，权限与父进程保持一致。

### 代码实现

在 `kern/mm/pmm.c` 的 `copy_range` 函数中补充如下代码：

```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end,
               bool share)
{
    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
    assert(USER_ACCESS(start, end));
    // copy content by page unit.
    do
    {
        // call get_pte to find process A's pte according to the addr start
        pte_t *ptep = get_pte(from, start, 0), *nptep;
        if (ptep == NULL)
        {
            start = ROUNDDOWN(start + PTSIZE, PTSIZE);
            continue;
        }
        // call get_pte to find process B's pte according to the addr start. If
        // pte is NULL, just alloc a PT
        if (*ptep & PTE_V)
        {
            if ((nptep = get_pte(to, start, 1)) == NULL)
            {
                return -E_NO_MEM;
            }
            uint32_t perm = (*ptep & PTE_USER);
            // get page from ptep
            struct Page *page = pte2page(*ptep);
            // alloc a page for process B
            struct Page *npage = alloc_page();
            assert(page != NULL);
            assert(npage != NULL);
            int ret = 0;
            /* LAB5:EXERCISE2 YOUR CODE */
            // (1) find src_kvaddr: the kernel virtual address of page
            void *src_kvaddr = page2kva(page);
            // (2) find dst_kvaddr: the kernel virtual address of npage
            void *dst_kvaddr = page2kva(npage);
            // (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE
            memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
            // (4) build the map of phy addr of nage with the linear addr start
            ret = page_insert(to, npage, start, perm);

            assert(ret == 0);
        }
        start += PGSIZE;
    } while (start != 0 && start < end);
    return 0;
}
```

同时，需要更新 `do_fork` 函数中的第 5 步，使用 `set_links` 设置进程关系：

```c
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS)
    {
        goto fork_out;
    }
    ret = -E_NO_MEM;

    // 1. 调用alloc_proc分配一个proc_struct
    if ((proc = alloc_proc()) == NULL) {
        goto fork_out;
    }
    
    // 设置父进程
    proc->parent = current;
    assert(current->wait_state == 0);  // LAB5: 确保当前进程不在等待状态
    
    // 2. 调用setup_kstack为子进程分配内核栈
    if (setup_kstack(proc) != 0) {
        goto bad_fork_cleanup_proc;
    }
    
    // 3. 调用copy_mm根据clone_flag复制或共享内存管理信息
    if (copy_mm(clone_flags, proc) != 0) {
        goto bad_fork_cleanup_kstack;
    }
    
    // 4. 调用copy_thread在proc_struct中设置tf和context
    copy_thread(proc, stack, tf);

    // 5. 将proc_struct插入hash_list和proc_list
    bool intr_flag;
    local_intr_save(intr_flag);  // 关中断，保证原子操作
    {
        proc->pid = get_pid();     // 分配PID
        hash_proc(proc);           // 加入hash表
        set_links(proc);           // LAB5: 使用set_links设置进程关系链接
    }
    local_intr_restore(intr_flag); // 开中断
    
    // 6. 调用wakeup_proc使新进程变为RUNNABLE
    wakeup_proc(proc);
    
    // 7. 使用子进程的pid设置返回值
    ret = proc->pid;

fork_out:
    return ret;
    // ... error handling ...
}
```

## Copy on Write (COW) 机制设计

**概要设计**:
Copy-on-Write (COW) 是一种推迟甚至避免内存复制的技术。在 `fork` 时，不立即复制父进程的物理内存，而是让父子进程共享同一份物理内存，并将这些页面标记为"只读"。只有当任一进程尝试写入这些页面时，才触发异常，进行实际的物理内存复制。

**详细设计**:

1.  **修改 `copy_range`**:
    *   不再分配新页面 (`alloc_page`) 和复制内容 (`memcpy`)。
    *   直接将子进程的页表项指向父进程的物理页。
    *   将父进程和子进程的该页表项的写权限 (`PTE_W`) 都清除，标记为只读。
    *   增加物理页的引用计数（`page_ref_inc`），表示有两个进程在使用它。
    *   可能需要利用页表项中的保留位（如 `PTE_RSW`）来标记这是一个 COW 页面，以便区分"真正的只读页面"和"COW 只读页面"。

2.  **Page Fault 处理 (`do_pgfault`)**:
    *   当程序尝试写入这些只读页面时，CPU 触发 Store/AMO Page Fault。
    *   在缺页异常处理函数中，检查异常原因是否为写权限违规，且该页面是否被标记为 COW。
    *   如果是 COW 页面：
        *   分配一个新的物理页。
        *   将共享页面的内容复制到新页面。
        *   修改当前进程的页表项，使其指向新页面，并设置写权限 (`PTE_W`)。
        *   减少原共享页面的引用计数。
        *   如果原共享页面的引用计数减为 1，说明只剩下一个拥有者，可以将该拥有者的页表项恢复为可写（这一步是优化，非必须）。
    *   刷新 TLB。
    *   返回用户态，重新执行导致异常的指令。

---

# 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

## fork/exec/wait/exit 执行流程分析

### 1. fork

*   **用户态**: 调用 `fork()` 库函数，触发 `ecall` 进入内核态。
*   **内核态**: `sys_fork` -> `do_fork`。
    *   分配 `proc_struct`。
    *   分配内核栈。
    *   复制内存空间 (`copy_mm`)。
    *   设置 `trapframe` (`copy_thread`)，子进程的返回值（a0）设为 0。
    *   将子进程加入进程列表，状态设为 `PROC_RUNNABLE`。
    *   返回子进程 PID 给父进程。
*   **返回**: 父进程返回 PID，子进程被调度后返回 0。

### 2. exec

*   **用户态**: 调用 `exec()`，触发 `ecall`。
*   **内核态**: `sys_exec` -> `do_execve`。
    *   检查并获取应用程序名。
    *   清理当前进程的内存空间 (`exit_mmap`, `put_pgdir`)。
    *   调用 `load_icode` 加载新程序，建立新内存映射，重置 `trapframe`。
*   **返回**: 通过 `sret` 跳转到新程序的入口点，看起来像是函数调用没有返回，而是直接变身成了新程序。

### 3. wait

*   **用户态**: 调用 `wait()`。
*   **内核态**: `sys_wait` -> `do_wait`。
    *   查找是否有状态为 `PROC_ZOMBIE` 的子进程。
    *   如果有，释放该子进程剩余的资源（内核栈、`proc_struct`），返回其 PID 和退出码。
    *   如果没有僵尸子进程但有运行中的子进程，将当前进程状态设为 `PROC_SLEEPING`，`wait_state` 设为 `WT_CHILD`，调用 `schedule()` 让出 CPU。
    *   当子进程退出时，会唤醒父进程。

### 4. exit

*   **用户态**: 调用 `exit()`。
*   **内核态**: `sys_exit` -> `do_exit`。
    *   释放大部分内存资源 (`mm_destroy`)。
    *   将状态设为 `PROC_ZOMBIE`。
    *   设置退出码。
    *   如果有父进程在等待，唤醒父进程。
    *   如果有子进程，将它们过继给 `init` 进程。
    *   调用 `schedule()`，不再返回。

## 内核态与用户态交错执行

用户程序运行在用户态，当需要操作系统服务（如 `fork`）或发生中断/异常时，通过 `ecall` 或硬件中断机制切换到内核态。内核处理完后，通过 `sret` 指令恢复上下文并返回用户态。

**内核态执行结果返回给用户程序的方式**：
- 系统调用的返回值通过 `a0` 寄存器返回
- 在 `trapframe` 中设置 `gpr.a0` 的值，当执行 `sret` 返回用户态时，该值自动恢复到 `a0` 寄存器

## 用户态进程生命周期图

```
       (alloc_proc)
      PROC_UNINIT
           |
           | proc_init / wakeup_proc
           V
     PROC_RUNNABLE  <-------------------------+
           |                                  |
           | schedule / proc_run              |
           V                                  |
        RUNNING  -----------------------------+
           |     (Time slice used up / yield)
           |
           | do_wait / do_sleep
           V
     PROC_SLEEPING
           |
           | wakeup_proc (event happens / child exits)
           V
     PROC_RUNNABLE
           |
           | do_exit
           V
      PROC_ZOMBIE
           |
           | (Parent calls wait)
           V
      (Resource Reclaimed)
```

---

# 扩展练习 Challenge

## Copy-on-Write (COW) 机制实现

### 1. 设计概述

Copy-on-Write (COW) 是一种推迟甚至避免内存复制的优化技术。在 `fork` 时，不立即复制父进程的物理内存，而是让父子进程共享同一份物理内存页面，并将这些页面标记为"只读"。只有当任一进程尝试写入这些页面时，才触发页面错误异常，进行实际的物理内存复制。

### 2. 实现细节

#### 2.1 COW 标志位定义 (`kern/mm/mmu.h`)

使用页表项中的保留位（bit 8）作为 COW 标志：

```c
#define PTE_D 0x080    // Dirty
#define PTE_SOFT 0x300 // Reserved for Software
#define PTE_COW 0x100  // Copy-on-Write flag (use bit 8 of reserved bits)
```

#### 2.2 修改 copy_range 函数 (`kern/mm/pmm.c`)

当 `share=1` 时启用 COW 机制：

```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end,
               bool share)
{
    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
    assert(USER_ACCESS(start, end));
    do
    {
        pte_t *ptep = get_pte(from, start, 0), *nptep;
        if (ptep == NULL)
        {
            start = ROUNDDOWN(start + PTSIZE, PTSIZE);
            continue;
        }
        if (*ptep & PTE_V)
        {
            if ((nptep = get_pte(to, start, 1)) == NULL)
            {
                return -E_NO_MEM;
            }
            uint32_t perm = (*ptep & PTE_USER);
            struct Page *page = pte2page(*ptep);
            assert(page != NULL);
            int ret = 0;

            if (share)
            {
                // COW: 共享同一物理页面
                // 移除写权限，设置 COW 标志
                perm = (perm & ~PTE_W) | PTE_COW;
                
                // 更新父进程页表项
                *ptep = pte_create(page2ppn(page), perm);
                
                // 子进程映射到同一物理页
                page_ref_inc(page);
                *nptep = pte_create(page2ppn(page), perm);
                
                // 刷新 TLB
                tlb_invalidate(from, start);
                tlb_invalidate(to, start);
            }
            else
            {
                // 原始行为：分配新页面并复制内容
                struct Page *npage = alloc_page();
                assert(npage != NULL);
                void *src_kvaddr = page2kva(page);
                void *dst_kvaddr = page2kva(npage);
                memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
                ret = page_insert(to, npage, start, perm);
                assert(ret == 0);
            }
        }
        start += PGSIZE;
    } while (start != 0 && start < end);
    return 0;
}
```

#### 2.3 页面错误处理 (`kern/mm/vmm.c`)

```c
int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr)
{
    int ret = -E_INVAL;
    
    // 查找包含错误地址的 vma
    struct vma_struct *vma = find_vma(mm, addr);
    if (vma == NULL || vma->vm_start > addr)
    {
        goto failed;
    }
    
    // 检查 vma 是否可写
    if (!(vma->vm_flags & VM_WRITE))
    {
        goto failed;
    }
    
    // 获取页表项
    pte_t *ptep = get_pte(mm->pgdir, addr, 0);
    if (ptep == NULL || !(*ptep & PTE_V))
    {
        goto failed;
    }
    
    // 检查是否为 COW 页面
    if (!(*ptep & PTE_COW))
    {
        goto failed;
    }
    
    // 处理 COW
    struct Page *old_page = pte2page(*ptep);
    
    if (page_ref(old_page) == 1)
    {
        // 只有一个引用，直接恢复写权限
        uint32_t perm = (*ptep & PTE_USER) | PTE_W;
        perm &= ~PTE_COW;
        *ptep = pte_create(page2ppn(old_page), perm);
        tlb_invalidate(mm->pgdir, addr);
        ret = 0;
    }
    else
    {
        // 多个引用，需要复制
        struct Page *new_page = alloc_page();
        if (new_page == NULL)
        {
            ret = -E_NO_MEM;
            goto failed;
        }
        
        // 复制页面内容
        memcpy(page2kva(new_page), page2kva(old_page), PGSIZE);
        
        // 设置新权限
        uint32_t perm = (*ptep & PTE_USER) | PTE_W;
        perm &= ~PTE_COW;
        
        // 减少旧页面引用计数
        page_ref_dec(old_page);
        
        // 插入新页面
        ret = page_insert(mm->pgdir, new_page, ROUNDDOWN(addr, PGSIZE), perm);
    }
    
failed:
    return ret;
}
```

#### 2.4 启用 COW (`kern/mm/vmm.c`)

修改 `dup_mmap` 函数，设置 `share=1`：

```c
int dup_mmap(struct mm_struct *to, struct mm_struct *from)
{
    // ...
    bool share = 1;  // 启用 COW
    if (copy_range(to->pgdir, from->pgdir, vma->vm_start, vma->vm_end, share) != 0)
    {
        return -E_NO_MEM;
    }
    // ...
}
```

#### 2.5 异常处理 (`kern/trap/trap.c`)

```c
case CAUSE_STORE_PAGE_FAULT:
    cprintf("Store/AMO page fault at 0x%x\n", tf->tval);
    if (current != NULL && current->mm != NULL)
    {
        if (do_pgfault(current->mm, tf->cause, tf->tval) != 0)
        {
            print_trapframe(tf);
            panic("handle store page fault failed\n");
        }
    }
    else
    {
        print_trapframe(tf);
        panic("store page fault in kernel or without mm\n");
    }
    break;
```

### 3. COW 状态转换图

```
                    fork()
    ┌─────────────────────────────────────────┐
    │                                         │
    ▼                                         │
┌───────────────┐                      ┌──────┴──────┐
│  父进程页面   │                      │  子进程创建 │
│  (R/W权限)    │                      │             │
└───────┬───────┘                      └──────┬──────┘
        │                                     │
        │  copy_range (share=1)               │
        │                                     │
        ▼                                     ▼
┌───────────────────────────────────────────────────┐
│              共享物理页面状态                      │
│  父进程 PTE: 只读 + COW 标志                      │
│  子进程 PTE: 只读 + COW 标志                      │
│  页面引用计数: ref = 2                            │
└───────────────────────┬───────────────────────────┘
                        │
         ┌──────────────┴──────────────┐
         │                             │
    父进程写入                     子进程写入
         │                             │
         ▼                             ▼
┌─────────────────┐           ┌─────────────────┐
│ Store Page Fault│           │ Store Page Fault│
└────────┬────────┘           └────────┬────────┘
         │                             │
         ▼                             ▼
┌─────────────────┐           ┌─────────────────┐
│  do_pgfault()   │           │  do_pgfault()   │
│  检查 COW 标志  │           │  检查 COW 标志  │
└────────┬────────┘           └────────┬────────┘
         │                             │
         ▼                             ▼
┌─────────────────────────────────────────────────┐
│                  COW 处理逻辑                    │
│  if (page_ref == 1):                            │
│      直接恢复写权限，清除 COW 标志              │
│  else:                                          │
│      1. 分配新物理页                            │
│      2. 复制原页面内容                          │
│      3. 更新页表项指向新页面                    │
│      4. 设置写权限，清除 COW 标志               │
│      5. 减少原页面引用计数                      │
└─────────────────────────────────────────────────┘
         │                             │
         ▼                             ▼
┌─────────────────┐           ┌─────────────────┐
│ 父进程独立页面  │           │ 子进程独立页面  │
│ (R/W权限, 新页) │           │ (R/W权限, 新页) │
└─────────────────┘           └─────────────────┘
```

### 4. 测试用例 (`user/cowtest.c`)

```c
#include <stdio.h>
#include <ulib.h>

#define MAGIC_VALUE 0xDEADBEEF
#define MODIFIED_VALUE 0x12345678

volatile int shared_data = MAGIC_VALUE;
volatile int test_array[256];

int main(void)
{
    cprintf("COW Test Program Start\n");
    
    // 初始化测试数组
    for (int i = 0; i < 256; i++)
        test_array[i] = i;
    
    int pid = fork();
    
    if (pid == 0)
    {
        // 子进程：写入数据（触发 COW）
        cprintf("[Child] Writing to shared_data...\n");
        shared_data = MODIFIED_VALUE;
        cprintf("[Child] shared_data = 0x%x\n", shared_data);
        exit(0);
    }
    else
    {
        // 父进程：等待子进程并验证数据未被修改
        waitpid(pid, NULL);
        cprintf("[Parent] shared_data = 0x%x (should be 0x%x)\n", 
                shared_data, MAGIC_VALUE);
        
        if (shared_data == MAGIC_VALUE)
            cprintf("COW Test PASSED!\n");
        else
            cprintf("COW Test FAILED!\n");
    }
    return 0;
}
```

### 5. Dirty COW 漏洞分析

#### 5.1 漏洞背景

Dirty COW (CVE-2016-5195) 是 Linux 内核中的一个严重漏洞，存在于 COW 实现中。该漏洞允许非特权用户获得对只读内存映射的写权限。

#### 5.2 漏洞原理

漏洞发生在以下竞争条件中：
1. 线程 A 尝试写入一个 COW 映射的只读页面
2. 内核开始处理 COW：分配新页面，准备复制内容
3. 线程 B 同时调用 `madvise(MADV_DONTNEED)` 丢弃该页面
4. 由于竞争，内核可能将写入操作应用到原始只读页面而非 COW 副本

#### 5.3 在 uCore 中的模拟

在我们的 uCore 实现中，可能存在类似的风险点：

```c
// 潜在竞争条件
int do_pgfault(...)
{
    struct Page *old_page = pte2page(*ptep);
    
    // 在此处，如果另一个线程修改了页表项...
    
    if (page_ref(old_page) == 1)
    {
        // 可能错误地认为是唯一引用
        *ptep = pte_create(...);  // 危险！
    }
}
```

#### 5.4 解决方案

1. **加锁保护**：在 COW 处理过程中持有页表锁
```c
int do_pgfault(struct mm_struct *mm, ...)
{
    lock_mm(mm);
    // COW 处理逻辑
    unlock_mm(mm);
}
```

2. **原子操作**：使用原子比较交换确保页表项未被修改
```c
pte_t old_pte = *ptep;
// 处理 COW
if (!atomic_cmpxchg(ptep, old_pte, new_pte))
{
    // 页表项已被修改，重试
}
```

3. **引用计数保护**：在检查引用计数前增加引用，防止页面被意外释放

### 6. COW 优缺点

**优点：**
- 减少 fork 时的内存开销和时间消耗
- 如果子进程执行 exec，可以完全避免复制
- 适合 fork-exec 模式的程序

**缺点：**
- 实现复杂度增加
- 写入时有额外的页面错误开销
- 需要处理竞争条件以确保安全

---

# 重要知识点总结

## 本实验中重要的知识点

1. **进程创建与内存复制**：通过 `do_fork` 创建子进程，使用 `copy_range` 复制父进程的内存空间。
2. **ELF 程序加载**：`load_icode` 函数解析 ELF 格式，建立用户内存空间。
3. **用户态与内核态切换**：通过设置 `trapframe` 中的 `sstatus`、`sepc` 等寄存器实现特权级切换。
4. **进程状态管理**：`PROC_UNINIT` -> `PROC_RUNNABLE` -> `RUNNING` -> `PROC_ZOMBIE` 的生命周期管理。
5. **系统调用机制**：用户程序通过 `ecall` 进入内核态，内核通过 `sret` 返回用户态。

## 与 OS 原理对应的知识点

| 实验知识点 | OS原理知识点 | 说明 |
|-----------|-------------|------|
| `do_fork` | 进程创建 | 实现了进程的复制创建机制 |
| `copy_range` | 内存空间复制 | 父子进程内存隔离的实现 |
| `load_icode` | 程序加载 | ELF格式解析与内存映射 |
| `trapframe` 设置 | 上下文切换 | 保存/恢复处理器状态 |
| COW 机制 | 写时复制 | 延迟复制优化技术 |

## OS 原理中重要但实验中未涉及的知识点

1. **进程间通信（IPC）**：如管道、消息队列、共享内存等
2. **信号机制**：进程间的异步通知
3. **线程的完整实现**：包括用户级线程和内核级线程
4. **进程优先级调度**：更复杂的调度算法
