# Lab5 Challenge: Copy-on-Write (COW) 机制设计与实现

## 一、设计目标

实现 Copy-on-Write 机制，优化 `fork()` 系统调用的性能：
- **传统 fork**：完整复制父进程的所有内存页面，开销大
- **COW fork**：父子进程共享物理页面，仅在写入时才复制，节省内存和时间

## 二、设计思路

### 2.1 核心原理

```
┌─────────────────────────────────────────────────────────────┐
│                     传统 Fork                                │
├─────────────────────────────────────────────────────────────┤
│  父进程页面 ───复制───> 子进程页面                           │
│  [Page A]              [Page A']  (独立的物理页)            │
│  [Page B]              [Page B']                            │
│  [Page C]              [Page C']                            │
│                                                             │
│  问题：fork 后立即 exec 的场景下，复制完全浪费               │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                     COW Fork                                 │
├─────────────────────────────────────────────────────────────┤
│  父进程 PTE ──────┐                                         │
│  (只读+COW)       ├───> [共享 Page] <───┤ 子进程 PTE        │
│                   │     ref_count=2     │ (只读+COW)        │
│                                                             │
│  写入时触发 Page Fault，才进行实际复制                       │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 实现要点

1. **标记 COW 页面**：使用页表项的保留位
2. **共享物理页面**：fork 时不复制，增加引用计数
3. **写时复制**：Page Fault 时分配新页面并复制
4. **引用计数管理**：确保页面在最后一个引用释放时才回收

## 三、详细实现

### 3.1 定义 COW 标志位

**文件**: `kern/mm/mmu.h`

RISC-V 页表项结构：
```
63    54 53    28 27    19 18    10 9   8 7 6 5 4 3 2 1 0
┌───────┬────────┬────────┬────────┬─────┬─┬─┬─┬─┬─┬─┬─┬─┐
│Reserved│ PPN[2] │ PPN[1] │ PPN[0] │ RSW │D│A│G│U│X│W│R│V│
└───────┴────────┴────────┴────────┴─────┴─┴─┴─┴─┴─┴─┴─┴─┘
                                    ↑
                              Reserved for Software (bit 8-9)
```

**修改代码**：
```c
// 原有定义
#define PTE_D 0x080    // Dirty
#define PTE_SOFT 0x300 // Reserved for Software

// 新增 COW 标志，使用 bit 8
#define PTE_COW 0x100  // Copy-on-Write flag (use bit 8 of reserved bits)
```

**设计说明**：
- RISC-V 页表项的 bit 8-9 是保留给软件使用的 (RSW)
- 我们使用 bit 8 作为 COW 标志
- 当 `PTE_COW=1` 且 `PTE_W=0` 时，表示这是一个 COW 页面

### 3.2 修改 copy_range 函数

**文件**: `kern/mm/pmm.c`

**原始代码**（直接复制）：
```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end,
               bool share)
{
    // ...
    if (*ptep & PTE_V)
    {
        // 分配新页面
        struct Page *npage = alloc_page();
        
        // 复制内容
        void *src_kvaddr = page2kva(page);
        void *dst_kvaddr = page2kva(npage);
        memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
        
        // 建立映射
        ret = page_insert(to, npage, start, perm);
    }
    // ...
}
```

**修改后代码**（支持 COW）：
```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end,
               bool share)
{
    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
    assert(USER_ACCESS(start, end));
    
    do
    {
        pte_t *ptep = get_pte(from, start, 0), *nptep;
        if (ptep == NULL)
        {
            start = ROUNDDOWN(start + PTSIZE, PTSIZE);
            continue;
        }
        
        if (*ptep & PTE_V)
        {
            if ((nptep = get_pte(to, start, 1)) == NULL)
            {
                return -E_NO_MEM;
            }
            uint32_t perm = (*ptep & PTE_USER);
            struct Page *page = pte2page(*ptep);
            assert(page != NULL);
            int ret = 0;

            if (share)  // COW 模式
            {
                // 步骤1：移除写权限，添加 COW 标志
                perm = (perm & ~PTE_W) | PTE_COW;
                
                // 步骤2：更新父进程的页表项（也变成只读+COW）
                *ptep = pte_create(page2ppn(page), perm);
                
                // 步骤3：子进程映射到同一物理页
                page_ref_inc(page);  // 增加引用计数
                *nptep = pte_create(page2ppn(page), perm);
                
                // 步骤4：刷新 TLB
                tlb_invalidate(from, start);
                tlb_invalidate(to, start);
            }
            else  // 传统复制模式
            {
                struct Page *npage = alloc_page();
                assert(npage != NULL);
                
                void *src_kvaddr = page2kva(page);
                void *dst_kvaddr = page2kva(npage);
                memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
                ret = page_insert(to, npage, start, perm);
                assert(ret == 0);
            }
        }
        start += PGSIZE;
    } while (start != 0 && start < end);
    return 0;
}
```

**关键点说明**：
1. **为什么父进程也要设置只读？** 
   - 如果只设置子进程只读，父进程写入不会触发 COW
   - 父子进程共享同一物理页，任一方写入都需要触发 COW
   
2. **为什么要刷新 TLB？**
   - 修改了父进程的页表项权限
   - TLB 中可能缓存了旧的权限信息

### 3.3 实现页面错误处理

**文件**: `kern/mm/vmm.c`

**新增函数 do_pgfault**：
```c
/* do_pgfault - handle page fault exception for COW
 * @mm:         the mm_struct related to the fault address
 * @error_code: the error code recorded in trapframe->cause
 * @addr:       the fault address (from trapframe->tval)
 */
int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr)
{
    int ret = -E_INVAL;
    
    // 步骤1：查找包含错误地址的 VMA
    struct vma_struct *vma = find_vma(mm, addr);
    if (vma == NULL || vma->vm_start > addr)
    {
        cprintf("do_pgfault: invalid addr 0x%x, no vma found\n", addr);
        goto failed;
    }
    
    // 步骤2：检查 VMA 是否允许写入
    // （如果 VMA 本身就不可写，那不是 COW 问题，是真的权限错误）
    if (!(vma->vm_flags & VM_WRITE))
    {
        cprintf("do_pgfault: addr 0x%x is not writable\n", addr);
        goto failed;
    }
    
    // 步骤3：获取页表项
    pte_t *ptep = get_pte(mm->pgdir, addr, 0);
    if (ptep == NULL || !(*ptep & PTE_V))
    {
        cprintf("do_pgfault: page not present at 0x%x\n", addr);
        goto failed;
    }
    
    // 步骤4：检查是否为 COW 页面
    if (!(*ptep & PTE_COW))
    {
        cprintf("do_pgfault: not a COW page at 0x%x\n", addr);
        goto failed;
    }
    
    // 步骤5：处理 COW
    struct Page *old_page = pte2page(*ptep);
    struct Page *new_page = NULL;
    
    // 情况A：只有一个引用（其他进程已经退出或已经 COW 过）
    if (page_ref(old_page) == 1)
    {
        // 直接恢复写权限，无需复制
        uint32_t perm = (*ptep & PTE_USER) | PTE_W;
        perm &= ~PTE_COW;  // 清除 COW 标志
        *ptep = pte_create(page2ppn(old_page), perm);
        tlb_invalidate(mm->pgdir, addr);
        ret = 0;
    }
    // 情况B：多个引用，需要实际复制
    else
    {
        // 分配新页面
        new_page = alloc_page();
        if (new_page == NULL)
        {
            cprintf("do_pgfault: failed to allocate new page\n");
            ret = -E_NO_MEM;
            goto failed;
        }
        
        // 复制页面内容
        void *src = page2kva(old_page);
        void *dst = page2kva(new_page);
        memcpy(dst, src, PGSIZE);
        
        // 设置新权限：可写，清除 COW 标志
        uint32_t perm = (*ptep & PTE_USER) | PTE_W;
        perm &= ~PTE_COW;
        
        // 减少旧页面引用计数
        page_ref_dec(old_page);
        
        // 将新页面映射到当前进程
        ret = page_insert(mm->pgdir, new_page, ROUNDDOWN(addr, PGSIZE), perm);
        if (ret != 0)
        {
            free_page(new_page);
            goto failed;
        }
    }
    
    ret = 0;
failed:
    return ret;
}
```

**流程图**：
```
              Page Fault (Store/AMO)
                      │
                      ▼
            ┌─────────────────┐
            │ find_vma(addr)  │
            └────────┬────────┘
                     │
              VMA 存在且可写？
                     │
            ┌────────┴────────┐
            │ No              │ Yes
            ▼                 ▼
         返回错误      ┌─────────────┐
                      │ get_pte()   │
                      └──────┬──────┘
                             │
                      是 COW 页面？
                             │
                    ┌────────┴────────┐
                    │ No              │ Yes
                    ▼                 ▼
                 返回错误      ┌─────────────┐
                              │ page_ref=1? │
                              └──────┬──────┘
                                     │
                         ┌───────────┴───────────┐
                         │ Yes                   │ No
                         ▼                       ▼
                 ┌───────────────┐      ┌───────────────────┐
                 │ 直接恢复写权限│      │ 1. alloc_page()   │
                 │ 清除COW标志   │      │ 2. memcpy()       │
                 └───────────────┘      │ 3. page_ref_dec() │
                                        │ 4. page_insert()  │
                                        └───────────────────┘
```

### 3.4 修改异常处理

**文件**: `kern/trap/trap.c`

**添加头文件**：
```c
#include <proc.h>  // 需要访问 current
```

**修改 exception_handler**：
```c
case CAUSE_STORE_PAGE_FAULT:
    cprintf("Store/AMO page fault at 0x%x\n", tf->tval);
    if (current != NULL && current->mm != NULL)
    {
        if (do_pgfault(current->mm, tf->cause, tf->tval) != 0)
        {
            print_trapframe(tf);
            panic("handle store page fault failed\n");
        }
    }
    else
    {
        print_trapframe(tf);
        panic("store page fault in kernel or without mm\n");
    }
    break;
```

**说明**：
- `tf->tval`：RISC-V 中保存引起异常的地址
- `tf->cause`：异常原因码
- 只处理用户进程（`current->mm != NULL`）的页面错误

### 3.5 启用 COW

**文件**: `kern/mm/vmm.c`

**修改 dup_mmap 函数**：
```c
int dup_mmap(struct mm_struct *to, struct mm_struct *from)
{
    assert(to != NULL && from != NULL);
    list_entry_t *list = &(from->mmap_list), *le = list;
    while ((le = list_prev(le)) != list)
    {
        struct vma_struct *vma, *nvma;
        vma = le2vma(le, list_link);
        nvma = vma_create(vma->vm_start, vma->vm_end, vma->vm_flags);
        if (nvma == NULL)
        {
            return -E_NO_MEM;
        }

        insert_vma_struct(to, nvma);

        // 关键修改：share=1 启用 COW
        bool share = 1;  // 原来是 share = 0
        if (copy_range(to->pgdir, from->pgdir, vma->vm_start, vma->vm_end, share) != 0)
        {
            return -E_NO_MEM;
        }
    }
    return 0;
}
```

### 3.6 声明函数

**文件**: `kern/mm/vmm.h`

```c
// COW page fault handler
int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr);
```

## 四、测试用例设计

**文件**: `user/cowtest.c`

```c
/*
 * cowtest.c - Test Copy-on-Write mechanism
 * 
 * 测试目标：
 * 1. 父子进程初始共享相同物理页面
 * 2. 子进程写入时触发 COW，分配新页面
 * 3. 子进程的修改对父进程不可见
 */

#include <stdio.h>
#include <ulib.h>

#define MAGIC_VALUE 0xDEADBEEF
#define MODIFIED_VALUE 0x12345678

// 全局变量测试 COW
volatile int shared_data = MAGIC_VALUE;

// 数组测试多页 COW
#define ARRAY_SIZE 256
volatile int test_array[ARRAY_SIZE];

int main(void)
{
    int i;
    
    cprintf("COW Test Program Start\n");
    cprintf("Initial shared_data = 0x%x (expect 0x%x)\n", shared_data, MAGIC_VALUE);
    
    // 初始化测试数组
    for (i = 0; i < ARRAY_SIZE; i++)
    {
        test_array[i] = i;
    }
    
    cprintf("Test array initialized\n");
    
    int pid = fork();
    
    if (pid < 0)
    {
        panic("fork failed!\n");
    }
    else if (pid == 0)
    {
        // 子进程
        cprintf("\n[Child] PID = %d\n", getpid());
        cprintf("[Child] Before write: shared_data = 0x%x\n", shared_data);
        
        // 验证初始值
        if (shared_data != MAGIC_VALUE)
        {
            cprintf("[Child] ERROR: shared_data should be 0x%x, got 0x%x\n", 
                    MAGIC_VALUE, shared_data);
        }
        
        // 写入 shared_data - 这里应该触发 COW
        cprintf("[Child] Writing to shared_data (COW should trigger)...\n");
        shared_data = MODIFIED_VALUE;
        cprintf("[Child] After write: shared_data = 0x%x\n", shared_data);
        
        if (shared_data != MODIFIED_VALUE)
        {
            cprintf("[Child] ERROR: write failed!\n");
        }
        
        // 修改数组元素
        cprintf("[Child] Modifying test_array[0] and test_array[100]...\n");
        test_array[0] = 9999;
        test_array[100] = 8888;
        
        cprintf("[Child] test_array[0] = %d, test_array[100] = %d\n", 
                test_array[0], test_array[100]);
        
        cprintf("[Child] COW Test in child completed\n");
        exit(0);
    }
    else
    {
        // 父进程
        cprintf("\n[Parent] PID = %d, Child PID = %d\n", getpid(), pid);
        
        // 等待子进程完成
        int child_pid = waitpid(pid, NULL);
        
        cprintf("\n[Parent] Child (PID %d) exited\n", child_pid);
        
        // 验证父进程数据未被修改
        cprintf("[Parent] shared_data = 0x%x (should still be 0x%x)\n", 
                shared_data, MAGIC_VALUE);
        
        if (shared_data != MAGIC_VALUE)
        {
            cprintf("[Parent] ERROR: COW failed! Parent data was modified!\n");
            cprintf("COW Test FAILED!\n");
        }
        else
        {
            cprintf("[Parent] SUCCESS: Parent data unchanged after child write\n");
        }
        
        // 检查数组值
        cprintf("[Parent] test_array[0] = %d (should be 0)\n", test_array[0]);
        cprintf("[Parent] test_array[100] = %d (should be 100)\n", test_array[100]);
        
        if (test_array[0] != 0 || test_array[100] != 100)
        {
            cprintf("[Parent] ERROR: Array values corrupted!\n");
            cprintf("COW Test FAILED!\n");
        }
        else
        {
            cprintf("[Parent] SUCCESS: Array values unchanged\n");
            cprintf("\n*** COW Test PASSED! ***\n");
        }
    }
    
    cprintf("COW Test Program End\n");
    return 0;
}
```

## 五、Debug 过程记录

### 5.1 编译错误 #1：wait 函数参数错误

**错误信息**：
```
user/cowtest.c:85:25: error: too many arguments to function 'wait'
   85 |         int child_pid = wait(&exit_code);
```

**原因分析**：
查看 `user/libs/ulib.h`，发现 uCore 的 `wait` 函数定义：
```c
int wait(void);  // 无参数
int waitpid(int pid, int *store);  // 有参数
```

**解决方案**：
```c
// 错误写法
int child_pid = wait(&exit_code);

// 正确写法
int child_pid = waitpid(pid, NULL);
```

### 5.2 编译警告：'page' may be used uninitialized

**警告信息**：
```
kern/mm/pmm.h:91:17: warning: 'page' may be used uninitialized
kern/process/proc.c:613:18: note: 'page' was declared here
```

**原因分析**：
在 `load_icode` 函数中，`page` 变量在某些代码路径下可能未初始化就被使用。

**说明**：
这是一个编译器警告，实际运行中不会出现问题，因为 `page` 只在成功分配后才被使用。可以通过初始化为 NULL 来消除警告：
```c
struct Page *page = NULL;
```

### 5.3 潜在问题：TLB 一致性

**问题描述**：
修改页表项后，TLB 中可能缓存了旧的映射信息。

**解决方案**：
在 `copy_range` 和 `do_pgfault` 中都调用 `tlb_invalidate`：
```c
tlb_invalidate(mm->pgdir, addr);
```

### 5.4 潜在问题：引用计数竞争

**问题描述**：
在多核或抢占式系统中，`page_ref` 的检查和后续操作之间可能存在竞争。

**当前实现的限制**：
uCore Lab5 是单核非抢占内核，因此不存在此问题。但在实际操作系统中需要：
1. 使用原子操作
2. 或持有适当的锁

## 六、COW 状态机

```
                            ┌──────────────────┐
                            │   初始状态       │
                            │  Page: R/W       │
                            │  ref_count: 1    │
                            └────────┬─────────┘
                                     │
                                  fork()
                                     │
                                     ▼
                    ┌────────────────────────────────┐
                    │         COW 共享状态            │
                    │  父进程 PTE: R + COW           │
                    │  子进程 PTE: R + COW           │
                    │  共享 Page ref_count: 2       │
                    └───────────────┬────────────────┘
                                    │
                    ┌───────────────┴───────────────┐
                    │                               │
              子进程写入                       父进程写入
            (Store Fault)                    (Store Fault)
                    │                               │
                    ▼                               ▼
        ┌───────────────────────┐     ┌───────────────────────┐
        │   COW 处理 (子)        │     │   COW 处理 (父)        │
        │ 1. alloc new page     │     │ 1. alloc new page     │
        │ 2. copy content       │     │ 2. copy content       │
        │ 3. update child PTE   │     │ 3. update parent PTE  │
        │    to new page (R/W)  │     │    to new page (R/W)  │
        │ 4. dec old page ref   │     │ 4. dec old page ref   │
        └───────────┬───────────┘     └───────────┬───────────┘
                    │                               │
                    ▼                               ▼
        ┌───────────────────────┐     ┌───────────────────────┐
        │ 子进程独立页面         │     │ 父进程独立页面         │
        │ 新 Page: R/W          │     │ 新 Page: R/W          │
        │ ref_count: 1          │     │ ref_count: 1          │
        └───────────────────────┘     └───────────────────────┘
        
        原共享页面: ref_count 减 1
        (当 ref_count=0 时自动释放)
```

## 七、文件修改清单

| 文件 | 修改类型 | 说明 |
|------|----------|------|
| `kern/mm/mmu.h` | 修改 | 添加 `PTE_COW` 宏定义 |
| `kern/mm/pmm.c` | 修改 | `copy_range` 支持 COW 模式 |
| `kern/mm/vmm.c` | 修改 | 添加 `do_pgfault`，修改 `dup_mmap` |
| `kern/mm/vmm.h` | 修改 | 声明 `do_pgfault` 函数 |
| `kern/trap/trap.c` | 修改 | 处理 Store Page Fault |
| `user/cowtest.c` | 新增 | COW 测试程序 |

## 八、测试方法

1. 编译：
```bash
make clean
make qemu
```

2. 运行 COW 测试（需修改 `kern/process/proc.c` 中的 `user_main` 函数）：

**修改 user_main 函数**：
```c
static int
user_main(void *arg)
{
#ifdef TEST
    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);
#else
    KERNEL_EXECVE(cowtest);  // 将 exit 改为 cowtest
#endif
    panic("user_main execve failed.\n");
}
```

3. 预期输出：
```
COW Test Program Start
Initial shared_data = 0xDEADBEEF (expect 0xDEADBEEF)
Test array initialized

[Parent] PID = 2, Child PID = 3

[Child] PID = 3
[Child] Before write: shared_data = 0xDEADBEEF
[Child] Writing to shared_data (COW should trigger)...
Store/AMO page fault at 0x...  <-- COW 触发
[Child] After write: shared_data = 0x12345678
[Child] COW Test in child completed

[Parent] Child (PID 3) exited
[Parent] shared_data = 0xDEADBEEF (should still be 0xDEADBEEF)
[Parent] SUCCESS: Parent data unchanged after child write
[Parent] test_array[0] = 0 (should be 0)
[Parent] test_array[100] = 100 (should be 100)
[Parent] SUCCESS: Array values unchanged

*** COW Test PASSED! ***
```

## 九、实际运行结果

### 9.1 运行默认 exit 程序（验证 COW 基本功能）

```
jay@jay-virtual-machine:~/桌面/labcode/lab5-challenge$ make qemu
...
(THU.CST) os is loading ...
...
kernel_execve: pid = 2, name = "exit".
Breakpoint
I am the parent. Forking the child...
Store/AMO page fault at 0x7fffff5c    <-- COW 触发！
I am parent, fork a child pid 3
I am the parent, waiting now..
I am the child.
waitpid 3 ok.
exit pass.
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:537:
    initproc exit.
```

**分析**：
- `Store/AMO page fault at 0x7fffff5c` 表明 COW 机制已生效
- 地址 `0x7fffff5c` 位于用户栈区域（栈顶 `USTACKTOP = 0x80000000`）
- 这是子进程首次写入栈时触发的 COW 页面复制
- `exit pass` 表明程序正确执行完成

### 9.2 COW 工作流程验证

从运行结果可以确认：
1. ✅ `fork()` 时父子进程共享页面（未立即复制）
2. ✅ 子进程写入时触发 `Store/AMO page fault`
3. ✅ `do_pgfault` 正确处理 COW，分配新页面
4. ✅ 程序正常执行完成，说明 COW 复制后数据正确

## 十、总结

COW 机制的实现涉及以下核心组件的协作：

1. **内存管理 (pmm.c)**：负责页面的共享和复制
2. **虚拟内存 (vmm.c)**：处理页面错误，执行实际的 COW 操作
3. **异常处理 (trap.c)**：捕获 Store Page Fault，调用 COW 处理函数
4. **页表标志 (mmu.h)**：使用保留位标记 COW 页面

通过这种实现，`fork()` 的性能得到显著提升，特别是在 fork-exec 模式下，可以完全避免不必要的内存复制。
