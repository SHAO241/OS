# Lab5 Challenge: Copy-on-Write (COW) 机制设计与实现

## 一、设计目标

实现 Copy-on-Write 机制，优化 `fork()` 系统调用的性能：
- **传统 fork**：完整复制父进程的所有内存页面，开销大
- **COW fork**：父子进程共享物理页面，仅在写入时才复制，节省内存和时间

## 二、设计思路

### 2.1 核心原理

```
┌─────────────────────────────────────────────────────────────┐
│                     传统 Fork                                │
├─────────────────────────────────────────────────────────────┤
│  父进程页面 ───复制───> 子进程页面                           │
│  [Page A]              [Page A']  (独立的物理页)            │
│  [Page B]              [Page B']                            │
│  [Page C]              [Page C']                            │
│                                                             │
│  问题：fork 后立即 exec 的场景下，复制完全浪费               │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                     COW Fork                                 │
├─────────────────────────────────────────────────────────────┤
│  父进程 PTE ──────┐                                         │
│  (只读+COW)       ├───> [共享 Page] <───┤ 子进程 PTE        │
│                   │     ref_count=2     │ (只读+COW)        │
│                                                             │
│  写入时触发 Page Fault，才进行实际复制                       │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 实现要点

1. **标记 COW 页面**：使用页表项的保留位
2. **共享物理页面**：fork 时不复制，增加引用计数
3. **写时复制**：Page Fault 时分配新页面并复制
4. **引用计数管理**：确保页面在最后一个引用释放时才回收

## 三、详细实现

### 3.1 定义 COW 标志位

**文件**: `kern/mm/mmu.h`

RISC-V 页表项结构：
```
63    54 53    28 27    19 18    10 9   8 7 6 5 4 3 2 1 0
┌───────┬────────┬────────┬────────┬─────┬─┬─┬─┬─┬─┬─┬─┬─┐
│Reserved│ PPN[2] │ PPN[1] │ PPN[0] │ RSW │D│A│G│U│X│W│R│V│
└───────┴────────┴────────┴────────┴─────┴─┴─┴─┴─┴─┴─┴─┴─┘
                                    ↑
                              Reserved for Software (bit 8-9)
```

**修改代码**：
```c
// 原有定义
#define PTE_D 0x080    // Dirty
#define PTE_SOFT 0x300 // Reserved for Software

// 新增 COW 标志，使用 bit 8
#define PTE_COW 0x100  // Copy-on-Write flag (use bit 8 of reserved bits)
```

**设计说明**：
- RISC-V 页表项的 bit 8-9 是保留给软件使用的 (RSW)
- 我们使用 bit 8 作为 COW 标志
- 当 `PTE_COW=1` 且 `PTE_W=0` 时，表示这是一个 COW 页面

#### 3.1.1 PTE标志位详细解析

**标志位含义及二进制表示**：

| 位置 | 名称 | 十六进制 | 二进制 | 说明 |
|------|------|---------|-------|------|
| 0 | PTE_V | 0x001 | 0b001 | Valid - 页表项有效 |
| 1 | PTE_R | 0x002 | 0b010 | Readable - 可读权限 |
| 2 | PTE_W | 0x004 | 0b100 | Writable - 可写权限 |
| 3 | PTE_X | 0x008 | 0b1000 | Executable - 可执行权限 |
| 4 | PTE_U | 0x010 | 0b10000 | User - 用户模式可访问 |
| 5 | PTE_G | 0x020 | 0b100000 | Global - 全局页 |
| 6 | PTE_A | 0x040 | 0b1000000 | Accessed - 已访问 |
| 7 | PTE_D | 0x080 | 0b10000000 | Dirty - 已修改 |
| **8** | **PTE_COW** | **0x100** | **0b100000000** | **COW标志 - 我们新增** |

**COW页面的标志位组合**：
```
典型的 COW 页面标志位：
+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
| bit | 8   | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
| COW | COW | D   | A   | G   | U   | X   | W   | R   | V   |
|页面 | 1   | 0   | 1   | 0   | 1   | 0   | 0   | 1   | 1   |
+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
      ↑                                   ↑     ↑     ↑
   标志位                                不可写  可读  有效

十六进制值：(0x100 | 0x020 | 0x002 | 0x001) = 0x123
```

**权限管理逻辑**：
```c
// 获取用户态权限（排除 COW 标志）
uint32_t perm = (*ptep & PTE_USER);  // PTE_USER = (PTE_U | PTE_X | PTE_W | PTE_R)
// 结果只包含 U/X/W/R 位，不包含 COW 位

// 添加 COW 标志（并移除写权限）
perm = (perm & ~PTE_W) | PTE_COW;
// 步骤：
// 1. perm & ~PTE_W  → 移除 W 位
// 2. |PTE_COW       → 添加 COW 位
// 结果：U/R 位保留，X/W 位移除，COW 位添加

// 恢复可写权限（移除 COW 标志）
perm = (*ptep & PTE_USER) | PTE_W;
perm &= ~PTE_COW;
// 或更简洁的写法：
perm = ((*ptep & PTE_USER) | PTE_W) & ~PTE_COW;
```

### 3.2 修改 copy_range 函数

**文件**: `kern/mm/pmm.c`

**原始代码**（直接复制）：
```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end,
               bool share)
{
    // ...
    if (*ptep & PTE_V)
    {
        // 分配新页面
        struct Page *npage = alloc_page();
        
        // 复制内容
        void *src_kvaddr = page2kva(page);
        void *dst_kvaddr = page2kva(npage);
        memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
        
        // 建立映射
        ret = page_insert(to, npage, start, perm);
    }
    // ...
}
```

**修改后代码**（支持 COW）：
```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end,
               bool share)
{
    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
    assert(USER_ACCESS(start, end));
    
    do
    {
        pte_t *ptep = get_pte(from, start, 0), *nptep;
        if (ptep == NULL)
        {
            start = ROUNDDOWN(start + PTSIZE, PTSIZE);
            continue;
        }
        
        if (*ptep & PTE_V)
        {
            if ((nptep = get_pte(to, start, 1)) == NULL)
            {
                return -E_NO_MEM;
            }
            uint32_t perm = (*ptep & PTE_USER);
            struct Page *page = pte2page(*ptep);
            assert(page != NULL);
            int ret = 0;

            if (share)  // COW 模式
            {
                // 步骤1：移除写权限，添加 COW 标志
                perm = (perm & ~PTE_W) | PTE_COW;
                
                // 步骤2：更新父进程的页表项（也变成只读+COW）
                *ptep = pte_create(page2ppn(page), perm);
                
                // 步骤3：子进程映射到同一物理页
                page_ref_inc(page);  // 增加引用计数
                *nptep = pte_create(page2ppn(page), perm);
                
                // 步骤4：刷新 TLB
                tlb_invalidate(from, start);
                tlb_invalidate(to, start);
            }
            else  // 传统复制模式
            {
                struct Page *npage = alloc_page();
                assert(npage != NULL);
                
                void *src_kvaddr = page2kva(page);
                void *dst_kvaddr = page2kva(npage);
                memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
                ret = page_insert(to, npage, start, perm);
                assert(ret == 0);
            }
        }
        start += PGSIZE;
    } while (start != 0 && start < end);
    return 0;
}
```

**关键点说明**：
1. **为什么父进程也要设置只读？** 
   - 如果只设置子进程只读，父进程写入不会触发 COW
   - 父子进程共享同一物理页，任一方写入都需要触发 COW
   
2. **为什么要刷新 TLB？**
   - 修改了父进程的页表项权限
   - TLB 中可能缓存了旧的权限信息

#### 3.2.1 copy_range 代码逐行深度分析

**第1-10行：初始化和验证**
```c
assert(start % PGSIZE == 0 && end % PGSIZE == 0);
// 确保地址按页对齐，防止不完整的页复制
// PGSIZE = 4096 (0x1000)
// 如果 start = 0x1234，则 start % PGSIZE = 0x234 ≠ 0，断言失败

assert(USER_ACCESS(start, end));
// 验证地址在用户空间范围内（通常 0x0 ~ 0x80000000）
// 防止意外复制内核空间内存
```

**第12-14行：遍历源页表**
```c
pte_t *ptep = get_pte(from, start, 0), *nptep;
// 获取源进程(from)中地址 start 的页表项指针
// 第三个参数 0 表示不创建缺失的页表项（只读查询）

if (ptep == NULL)
{
    start = ROUNDDOWN(start + PTSIZE, PTSIZE);
    // 如果页表项不存在，跳过整个二级页表
    // PTSIZE = 4MB (一个二级页表的覆盖范围)
    // 这是优化：避免逐页检查大片不存在的内存区域
    continue;
}
```

**第17-24行：获取目标页表项**
```c
if ((nptep = get_pte(to, start, 1)) == NULL)
// 获取目标进程(to)中地址 start 的页表项
// 第三个参数 1 表示如果页表缺失就创建
// 如果内存不足，无法创建新的页表，返回错误

return -E_NO_MEM;
```

**第25-28行：提取权限字段**
```c
uint32_t perm = (*ptep & PTE_USER);
// PTE_USER = PTE_U | PTE_X | PTE_W | PTE_R
// 只提取用户态权限位，不包括 PTE_V、PTE_D、PTE_A 等

struct Page *page = pte2page(*ptep);
// 从页表项解析物理页号(PPN)，获取对应的物理页结构体
// 物理页结构中包含引用计数等重要信息
```

**第31-49行：COW模式核心逻辑**
```c
if (share)  // share=true 时启用 COW
{
    // 【关键第1步】清除写权限，添加COW标志
    perm = (perm & ~PTE_W) | PTE_COW;
    //
    // 示例：
    // 原权限：U(1) X(0) W(1) R(1) = 0x1B
    // perm & ~PTE_W: U(1) X(0) W(0) R(1) = 0x13
    // | PTE_COW:     U(1) X(0) W(0) R(1) | COW(1) = 0x113
    //
    // 为什么要移除 W：
    // - RISC-V 硬件检查：访问存储器时检查 PTE_W
    // - 若 W=0，任何写入都会触发 Store Page Fault
    // - 这是触发 COW 处理的必要条件
    
    // 【关键第2步】更新父进程的页表项
    *ptep = pte_create(page2ppn(page), perm);
    //
    // 关键问题：为什么要修改父进程的页表？
    // 
    // 反例（错误做法）：只修改子进程页表
    // 父进程 PTE: W=1, COW=0 → 父进程可以正常写入，不触发异常
    // 子进程 PTE: W=0, COW=1 → 子进程写入时触发 Page Fault
    // 问题：父进程的写入直接修改共享页面，子进程无法独立
    //
    // 正确做法（两个都改）：
    // 父进程 PTE: W=0, COW=1 → 父进程写入也触发 Page Fault
    // 子进程 PTE: W=0, COW=1 → 子进程写入也触发 Page Fault
    // 效果：两个进程都保护了共享页面，任意一方修改时复制
    
    // 【关键第3步】建立子进程映射
    page_ref_inc(page);  // 增加引用计数
    //
    // 引用计数机制：
    // fork 前：refcount=1（只有父进程)
    // fork 后：refcount=2（父进程+子进程）
    // 父进程 COW 复制后：refcount--，原页 refcount=1
    // 结果：父/子各有独立页面，原共享页面释放
    //
    // 使用场景：多个进程共享同一页面时，引用计数为3+
    
    *nptep = pte_create(page2ppn(page), perm);
    // 子进程指向同一物理页，权限与父进程相同（R+COW）
    
    // 【关键第4步】刷新 TLB
    tlb_invalidate(from, start);
    tlb_invalidate(to, start);
    //
    // TLB（Translation Lookaside Buffer）：
    // - 硬件缓存：页表查询的缓冲区，加速地址翻译
    // - 作用：存储最近使用的虚拟地址→物理地址的映射
    //
    // 为什么需要刷新：
    // 修改前：TLB 缓存了 start → Page(R/W) 的映射
    // 修改后：页表改为 start → Page(R/COW) 的映射
    // 不刷新 TLB 的后果：
    //   - 处理器仍使用旧的 TLB 缓存信息
    //   - 看不到页表的修改
    //   - W=1 的缓存项仍然有效，写入不会触发异常
    //   - 共享页面被错误修改！
    //
    // 刷新操作：
    // - from 进程的 TLB：清除该地址在 from 中的映射缓存
    // - to 进程的 TLB：清除该地址在 to 中的映射缓存
    //   （to 刚被创建，TLB 通常为空，但为保险起见也刷新）
}
```

**第50-59行：传统复制模式**
```c
else  // share=false 时禁用 COW，使用传统复制
{
    // 分配完全独立的新页面
    struct Page *npage = alloc_page();
    //
    // 内存成本：
    // fork 时立即分配 N 个页面（与父进程内存大小相同）
    // 优点：不需要处理 Page Fault，逻辑简单
    // 缺点：fork-exec 时，exec 立即释放子进程内存，复制全部浪费
    
    void *src_kvaddr = page2kva(page);
    void *dst_kvaddr = page2kva(npage);
    // 获取两个页面的内核虚拟地址
    // 目的：在内核地址空间中进行 memcpy
    // 不能直接使用用户虚拟地址（用户空间不同进程不同）
    
    memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
    // 按字节复制整个页面（4096 字节）
    // 时间成本：O(PGSIZE) ，大约几微秒到几十微秒
    // 对比 COW：避免这个复制操作
    
    ret = page_insert(to, npage, start, perm);
    // 将新页面插入目标进程的页表
    // perm 保留原权限（包括写权限）
}
```

**第60-62行：循环控制**
```c
start += PGSIZE;
// 逐页处理，步进大小为 4KB

} while (start != 0 && start < end);
// 循环条件：
// - start < end：未复制完所有页面
// - start != 0：防止地址回绕（start 溢出后为 0）
//   在用户空间 0x0～0x80000000 范围内不会发生
```

### 3.3 实现页面错误处理

**文件**: `kern/mm/vmm.c`

**新增函数 do_pgfault**：
```c
/* do_pgfault - handle page fault exception for COW
 * @mm:         the mm_struct related to the fault address
 * @error_code: the error code recorded in trapframe->cause
 * @addr:       the fault address (from trapframe->tval)
 */
int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr)
{
    int ret = -E_INVAL;
    
    // 步骤1：查找包含错误地址的 VMA
    struct vma_struct *vma = find_vma(mm, addr);
    if (vma == NULL || vma->vm_start > addr)
    {
        cprintf("do_pgfault: invalid addr 0x%x, no vma found\n", addr);
        goto failed;
    }
    
    // 步骤2：检查 VMA 是否允许写入
    // （如果 VMA 本身就不可写，那不是 COW 问题，是真的权限错误）
    if (!(vma->vm_flags & VM_WRITE))
    {
        cprintf("do_pgfault: addr 0x%x is not writable\n", addr);
        goto failed;
    }
    
    // 步骤3：获取页表项
    pte_t *ptep = get_pte(mm->pgdir, addr, 0);
    if (ptep == NULL || !(*ptep & PTE_V))
    {
        cprintf("do_pgfault: page not present at 0x%x\n", addr);
        goto failed;
    }
    
    // 步骤4：检查是否为 COW 页面
    if (!(*ptep & PTE_COW))
    {
        cprintf("do_pgfault: not a COW page at 0x%x\n", addr);
        goto failed;
    }
    
    // 步骤5：处理 COW
    struct Page *old_page = pte2page(*ptep);
    struct Page *new_page = NULL;
    
    // 情况A：只有一个引用（其他进程已经退出或已经 COW 过）
    if (page_ref(old_page) == 1)
    {
        // 直接恢复写权限，无需复制
        uint32_t perm = (*ptep & PTE_USER) | PTE_W;
        perm &= ~PTE_COW;  // 清除 COW 标志
        *ptep = pte_create(page2ppn(old_page), perm);
        tlb_invalidate(mm->pgdir, addr);
        ret = 0;
    }
    // 情况B：多个引用，需要实际复制
    else
    {
        // 分配新页面
        new_page = alloc_page();
        if (new_page == NULL)
        {
            cprintf("do_pgfault: failed to allocate new page\n");
            ret = -E_NO_MEM;
            goto failed;
        }
        
        // 复制页面内容
        void *src = page2kva(old_page);
        void *dst = page2kva(new_page);
        memcpy(dst, src, PGSIZE);
        
        // 设置新权限：可写，清除 COW 标志
        uint32_t perm = (*ptep & PTE_USER) | PTE_W;
        perm &= ~PTE_COW;
        
        // 减少旧页面引用计数
        page_ref_dec(old_page);
        
        // 将新页面映射到当前进程
        ret = page_insert(mm->pgdir, new_page, ROUNDDOWN(addr, PGSIZE), perm);
        if (ret != 0)
        {
            free_page(new_page);
            goto failed;
        }
    }
    
    ret = 0;
failed:
    return ret;
}
```

**流程图**：
```
              Page Fault (Store/AMO)
                      │
                      ▼
            ┌─────────────────┐
            │ find_vma(addr)  │
            └────────┬────────┘
                     │
              VMA 存在且可写？
                     │
            ┌────────┴────────┐
            │ No              │ Yes
            ▼                 ▼
         返回错误      ┌─────────────┐
                      │ get_pte()   │
                      └──────┬──────┘
                             │
                      是 COW 页面？
                             │
                    ┌────────┴────────┐
                    │ No              │ Yes
                    ▼                 ▼
                 返回错误      ┌─────────────┐
                              │ page_ref=1? │
                              └──────┬──────┘
                                     │
                         ┌───────────┴───────────┐
                         │ Yes                   │ No
                         ▼                       ▼
                 ┌───────────────┐      ┌───────────────────┐
                 │ 直接恢复写权限│      │ 1. alloc_page()   │
                 │ 清除COW标志   │      │ 2. memcpy()       │
                 └───────────────┘      │ 3. page_ref_dec() │
                                        │ 4. page_insert()  │
                                        └───────────────────┘
```

#### 3.3.1 do_pgfault 代码深度分析

**第1-13行：查找 VMA（Virtual Memory Area）**
```c
struct vma_struct *vma = find_vma(mm, addr);
if (vma == NULL || vma->vm_start > addr)
{
    cprintf("do_pgfault: invalid addr 0x%x, no vma found\n", addr);
    goto failed;
}
//
// VMA 结构体：
// struct vma_struct {
//     struct mm_struct *vm_mm;      // 所属进程的 mm_struct
//     uintptr_t vm_start;            // 虚拟地址范围起点
//     uintptr_t vm_end;              // 虚拟地址范围终点
//     uint32_t vm_flags;             // 权限标志（VM_READ/VM_WRITE/VM_EXEC）
//     ...
// };
//
// VMA 作用：记录用户进程合法的虚拟地址空间
// 例如：
// - 代码段 VMA：[0x10000, 0x11000)，权限=VM_READ|VM_EXEC
// - 数据段 VMA：[0x11000, 0x12000)，权限=VM_READ|VM_WRITE
// - 堆 VMA：[0x12000, 0x20000)，权限=VM_READ|VM_WRITE
// - 栈 VMA：[0x7ff00000, 0x80000000)，权限=VM_READ|VM_WRITE
//
// find_vma(mm, addr) 作用：
// 返回包含地址 addr 的 VMA
// 如果 addr 落在某个 VMA 范围 [vm_start, vm_end) 内，返回该 VMA
// 否则返回 NULL（地址空间不合法）
//
// 检查条件：
// vma == NULL：地址不在任何 VMA 中（非法访问）
// vma->vm_start > addr：find_vma 返回错误的 VMA（不应发生，debug用）
```

**第15-21行：检查 VMA 写权限**
```c
if (!(vma->vm_flags & VM_WRITE))
{
    cprintf("do_pgfault: addr 0x%x is not writable\n", addr);
    goto failed;
}
//
// 检查虚拟地址空间的权限，而不是页表项的权限
// 这是两个不同的权限层级：
//
// 第一层：进程权限（VMA 层）
// - 进程在创建时定义了哪些虚拟地址可以读/写/执行
// - 例如：代码段 VMA 设置为 VM_READ|VM_EXEC，不允许写入
// - 如果 VMA 不允许写入，则任何写入操作都是非法的
//
// 第二层：页面权限（页表层）
// - 即使 VMA 允许写入，页表项也可能因为 COW 而标记为只读
// - 这时触发 Page Fault，由 do_pgfault 处理
//
// 两层权限的组合：
// 情况1：VMA 不可写，页表可写 → 报错（VMA权限不足）
// 情况2：VMA 可写，页表不可写（COW）→ 处理 COW
// 情况3：VMA 可写，页表可写 → 应该不会产生写异常
//
// 检查顺序很重要：
// 先检查 VMA 权限 → 快速过滤非法访问
// 再检查页表 → 只处理合法的 COW 情况
```

**第23-28行：查找页表项**
```c
pte_t *ptep = get_pte(mm->pgdir, addr, 0);
if (ptep == NULL || !(*ptep & PTE_V))
{
    cprintf("do_pgfault: page not present at 0x%x\n", addr);
    goto failed;
}
//
// get_pte(pgdir, addr, 0)：
// - pgdir：一级页表（页目录）
// - addr：故障虚拟地址
// - 0：不创建缺失的页表（只读查询）
//
// 返回值：
// - ptep != NULL 且 PTE_V=1：页面存在，处理 COW
// - ptep == NULL：二级页表不存在（不应发生，因为 VMA 已验证）
// - ptep != NULL 但 PTE_V=0：页表项无效
//   可能原因：
//   a) lazy allocation：页面从未分配过（不支持）
//   b) 页面被换出到磁盘（uCore 不支持 swap）
//   c) 其他异常：应该报错
//
// 注意：如果是真正的"页不存在"（非 COW），说明这是一个 bug
```

**第30-35行：识别 COW 页面**
```c
if (!(*ptep & PTE_COW))
{
    cprintf("do_pgfault: not a COW page at 0x%x\n", addr);
    goto failed;
}
//
// COW 页面的标志位组合：
// PTE_V = 1（页面存在）
// PTE_W = 0（不可写）
// PTE_COW = 1（Copy-on-Write 标志）
//
// 如果没有 PTE_COW 标志，说明：
// 1. 页表项权限本就不允许写入（例如代码段）
// 2. 这是一个真正的权限错误，不是 COW
// 应该报错给用户程序
//
// 这一行是防御性编程：
// - 确保只有标记为 COW 的页面才会被处理
// - 避免误处理其他类型的写异常
```

**第37-44行：COW 情况 A - 单一引用优化**
```c
if (page_ref(old_page) == 1)
{
    // 直接恢复写权限，无需复制
    uint32_t perm = (*ptep & PTE_USER) | PTE_W;
    perm &= ~PTE_COW;
    *ptep = pte_create(page2ppn(old_page), perm);
    tlb_invalidate(mm->pgdir, addr);
    ret = 0;
}
//
// 关键洞察：为什么 ref_count=1 时无需复制？
//
// 场景分析：
// 初始：fork 时 refcount=2（父进程+子进程共享）
// 变化1：父进程先触发 COW
//   - 父进程：分配新页面，复制内容，引用计数 --
//   - 结果：父进程 refcount=1（只有父进程）
// 变化2：子进程随后触发 COW
//   - 子进程发现 refcount=1，说明只有自己在用
//   - 无需复制（复制自己给自己）
//   - 直接恢复写权限即可
//
// 引用计数的含义：
// refcount = 1：只有当前进程在使用，可以安全修改
// refcount > 1：其他进程也在使用，必须先复制
//
// 优化效果：
// 场景：多进程 fork 链（A fork B fork C）
// 传统方式：每个 fork 都复制所有页面（内存浪费）
// COW 方式：
//   - A→B：共享页面
//   - B→C：共享页面（三进程共享）
//   - A 写入：refcount=3→2，复制（A 独立）
//   - B 写入：refcount=2→1，复制（B 独立）
//   - C 写入：refcount=1→1，恢复权限（C 不需复制）
```

**第46-73行：COW 情况 B - 多引用真实复制**
```c
else
{
    // 分配新页面
    new_page = alloc_page();
    if (new_page == NULL)
    {
        cprintf("do_pgfault: failed to allocate new page\n");
        ret = -E_NO_MEM;
        goto failed;
    }
    
    // 复制页面内容
    void *src = page2kva(old_page);
    void *dst = page2kva(new_page);
    memcpy(dst, src, PGSIZE);
    
    // 设置新权限：可写，清除 COW 标志
    uint32_t perm = (*ptep & PTE_USER) | PTE_W;
    perm &= ~PTE_COW;
    
    // 减少旧页面引用计数
    page_ref_dec(old_page);
    
    // 将新页面映射到当前进程
    ret = page_insert(mm->pgdir, new_page, ROUNDDOWN(addr, PGSIZE), perm);
    if (ret != 0)
    {
        free_page(new_page);
        goto failed;
    }
}
//
// 步骤详解：
//
// 【步骤1】分配新物理页面
// alloc_page()：
// - 从空闲页面列表中取出一个页面
// - 初始化引用计数为 0
// - 返回 struct Page* 结构体
// - 失败返回 NULL（内存不足）
// 新页面初始状态：
// - 物理内存内容：未定义（可能包含垃圾数据）
// - 引用计数：0
// - 页表项数：0
//
// 【步骤2】复制页面内容
// page2kva()：从物理页号转换为内核虚拟地址
// - uCore 中，物理内存在启动时直接映射到内核空间
// - 任何物理页都有对应的内核虚拟地址
// - src = old_page 对应的内核地址（只读访问）
// - dst = new_page 对应的内核地址（写入目标）
//
// memcpy(dst, src, PGSIZE)：
// - 按字节逐个复制 4096 个字节
// - 在现代 CPU 上，使用 SIMD 指令可以很快（几微秒）
// - 新页面现在包含旧页面的完整副本
//
// 【步骤3】设置新权限
// perm = (*ptep & PTE_USER) | PTE_W;
// - 提取原权限中的用户态权限位
// - 添加写权限
// - 结果：例如 U|R|W
//
// perm &= ~PTE_COW;
// - 清除 COW 标志
// - 因为新页面已经复制，不再是 COW 页面
//
// 【步骤4】更新引用计数
// page_ref_dec(old_page);
// - 当前进程不再使用旧页面
// - 引用计数 --
// - 如果 refcount 降到 0，页面会被回收
//
// 【步骤5】重建页表映射
// page_insert(mm->pgdir, new_page, ROUNDDOWN(addr, PGSIZE), perm)
// - 将新页面映射到虚拟地址 addr（向下对齐到页边界）
// - 从当前进程的页表替换旧映射为新映射
// - page_insert 内部会：
//   a) 找到或创建二级页表
//   b) 更新对应的页表项
//   c) 自动增加新页面的引用计数
//   d) 自动释放旧页面（如果新旧不同）
//   e) 刷新 TLB（某些实现）
//
// 异常处理：
// if (ret != 0)：
// - page_insert 可能失败（内存不足创建页表）
// - 此时新页面已分配但未使用
// - free_page(new_page)：释放新页面防止内存泄漏
// - 返回错误，由上层处理（可能 kill 进程）
//
// COW 复制完成后的状态：
// 旧页面：refcount 减 1，可能被其他进程仍在使用
// 新页面：refcount = 1，当前进程独占
// 当前进程：可以安全地修改新页面，不影响其他进程
```

### 3.4 修改异常处理

**文件**: `kern/trap/trap.c`

**添加头文件**：
```c
#include <proc.h>  // 需要访问 current
```

**修改 exception_handler**：
```c
case CAUSE_STORE_PAGE_FAULT:
    cprintf("Store/AMO page fault at 0x%x\n", tf->tval);
    if (current != NULL && current->mm != NULL)
    {
        if (do_pgfault(current->mm, tf->cause, tf->tval) != 0)
        {
            print_trapframe(tf);
            panic("handle store page fault failed\n");
        }
    }
    else
    {
        print_trapframe(tf);
        panic("store page fault in kernel or without mm\n");
    }
    break;
```

**说明**：
- `tf->tval`：RISC-V 中保存引起异常的地址
- `tf->cause`：异常原因码
- 只处理用户进程（`current->mm != NULL`）的页面错误

#### 3.4.1 异常处理深度分析

**异常处理流程**：

```
硬件 Store 指令执行失败
          │
          ▼
┌─────────────────────────┐
│ RISC-V CPU 产生异常     │
│ - 保存 PC 到 sepc       │
│ - 保存错误地址到 stval  │
│ - 保存异常代码到 scause │
│ - 切换到 Supervisor 模式│
│ - PC 跳转到异常处理程序 │
└──────────┬──────────────┘
           │
           ▼
┌─────────────────────────────────────────┐
│ exception_handler(trapframe *tf)        │
│ 通用异常处理程序                        │
│ 根据 tf->cause 分发到具体处理器         │
└──────────┬──────────────────────────────┘
           │
           ▼
┌─────────────────────────────────────────┐
│ case CAUSE_STORE_PAGE_FAULT:           │
│ (tf->cause == 7 for Sv39 in RISC-V)    │
└──────────┬──────────────────────────────┘
           │
           ▼
检查异常来源（kernel vs user）
           │
    ┌──────┴──────┐
    ▼             ▼
 内核异常      用户异常
 (panic)    (do_pgfault)
    │             │
    │             ▼
    │    ┌─────────────────────┐
    │    │ 检查引用计数        │
    │    └─────────┬───────────┘
    │              │
    │         ┌────┴────┐
    │         ▼         ▼
    │       单引用   多引用
    │         │         │
    │         ▼         ▼
    │      快速路径  复制路径
    │    (无复制)    (memcpy)
    │         │         │
    ▼         ▼         ▼
┌────────────────────────────────┐
│ sret (Return from Trap)         │
│ - 恢复 PC = sepc                │
│ - 恢复用户态上下文              │
│ - 重新执行引起异常的 store 指令 │
└────────────────────────────────┘
```

**关键代码详解**：

```c
case CAUSE_STORE_PAGE_FAULT:
    cprintf("Store/AMO page fault at 0x%x\n", tf->tval);
    //
    // tf->tval：触发异常的虚拟地址
    // 在 RISC-V 中，stval 寄存器保存：
    // - Load/Store 异常：访问的虚拟地址
    // - Instruction 异常：触发异常的指令本身（或 0）
    // - 其他异常：依赖异常类型
    //
    // 输出示例：Store/AMO page fault at 0x7fffff5c
    // 说明：栈顶附近的地址发生了存储异常（典型的栈增长）
    
    if (current != NULL && current->mm != NULL)
    {
        // 这是用户进程的异常
        // - current != NULL：当前正在运行用户进程
        // - current->mm != NULL：进程有虚拟地址空间
        //
        // 对比情况：
        // - current == NULL：不在任何进程上下文中（启动时）
        // - current->mm == NULL：内核线程（无用户地址空间）
        
        if (do_pgfault(current->mm, tf->cause, tf->tval) != 0)
        {
            // do_pgfault 返回非零值：处理失败
            // 可能原因：
            // 1. 地址不在任何 VMA 中（stack overflow）
            // 2. VMA 不允许写入（权限错误）
            // 3. 页表项不是 COW 页面（其他故障）
            // 4. 内存不足（无法分配新页面）
            //
            // 处理方式：输出错误信息，panic 内核
            
            print_trapframe(tf);
            // 打印完整的寄存器和异常信息，便于 debug
            
            panic("handle store page fault failed\n");
            // 通知用户：COW 处理失败，系统崩溃
            // 在实际 OS 中，应该给用户进程发送 SIGSEGV 信号
        }
    }
    else
    {
        // 这是内核异常：不应该发生
        // - 原因1：内核代码有 bug，写入了不该写的地方
        // - 原因2：内核栈越界
        
        print_trapframe(tf);
        panic("store page fault in kernel or without mm\n");
    }
    break;
```

**RISC-V 异常原因码**：

| 代码 | 名称 | 说明 |
|------|------|------|
| 0 | Instruction address misaligned | 指令地址未对齐 |
| 1 | Instruction access fault | 指令访问故障 |
| 2 | Illegal instruction | 非法指令 |
| 3 | Breakpoint | 断点异常 |
| 4 | Load address misaligned | Load 地址未对齐 |
| 5 | Load access fault | Load 访问故障 |
| 6 | Store/AMO address misaligned | Store 地址未对齐 |
| **7** | **Store/AMO access fault** | **Store/AMO 访问故障（COW 处理）** |

**异常嵌套问题**：

在异常处理期间，如果发生第二次异常，称为异常嵌套。例如：

```
场景：COW 处理中发生异常
- 当前：处理 Store Page Fault
- 操作：memcpy(dst, src, PGSIZE) 时
- 风险：如果 src 页不在内存中（不应发生）
- 结果：嵌套异常，内核检测到嵌套异常后 panic

uCore 的安全措施：
1. 断言检查：确保页表项 PTE_V=1（页存在）
2. 简单操作：memcpy 等基本操作不会触发异常
3. 错误处理：page_insert 失败时立即返回
```

### 3.5 启用 COW

**文件**: `kern/mm/vmm.c`

**修改 dup_mmap 函数**：
```c
int dup_mmap(struct mm_struct *to, struct mm_struct *from)
{
    assert(to != NULL && from != NULL);
    list_entry_t *list = &(from->mmap_list), *le = list;
    while ((le = list_prev(le)) != list)
    {
        struct vma_struct *vma, *nvma;
        vma = le2vma(le, list_link);
        nvma = vma_create(vma->vm_start, vma->vm_end, vma->vm_flags);
        if (nvma == NULL)
        {
            return -E_NO_MEM;
        }

        insert_vma_struct(to, nvma);

        // 关键修改：share=1 启用 COW
        bool share = 1;  // 原来是 share = 0
        if (copy_range(to->pgdir, from->pgdir, vma->vm_start, vma->vm_end, share) != 0)
        {
            return -E_NO_MEM;
        }
    }
    return 0;
}
```

#### 3.5.1 dup_mmap 深度分析

**函数目的**：复制进程的虚拟地址空间（在 fork 时调用）

**复制流程**：

```
源进程 VMA 结构
    ├─ VMA1: [0x10000, 0x11000) CODE
    ├─ VMA2: [0x11000, 0x12000) DATA
    ├─ VMA3: [0x12000, 0x20000) HEAP
    └─ VMA4: [0x7ff00000, 0x80000000) STACK
          │
          ▼ dup_mmap(to, from)
          │
    ┌─────────────────────────────────────────┐
    │ 步骤1：遍历源进程的 VMA 链表            │
    │ for each VMA in from->mmap_list:       │
    └──────────┬────────────────────────────┘
               │
               ▼
    ┌──────────────────────────────────────────────┐
    │ 步骤2：创建目标 VMA（权限相同）             │
    │ nvma = vma_create(...)                       │
    │ 结果：目标进程获得同样的 VMA 结构           │
    └──────────┬───────────────────────────────────┘
               │
               ▼
    ┌──────────────────────────────────────────────────┐
    │ 步骤3：复制页表映射（启用 COW）                │
    │ copy_range(..., share=1)                        │
    │ - 不分配新页面                                │
    │ - 两个进程指向同一物理页                       │
    │ - 标记为 COW + 只读                           │
    └──────────┬──────────────────────────────────────┘
               │
    ┌──────────┴──────────────────────────────────────┐
    │ 结果：子进程 VMA 和页表都指向父进程的页面     │
    │ 任何写入操作都会触发 Page Fault               │
    └───────────────────────────────────────────────┘

新旧写法对比：
┌──────────────────────┬──────────────────────┐
│    share=0 (旧)      │    share=1 (新)      │
├──────────────────────┼──────────────────────┤
│ fork 时复制所有页面  │ fork 时不复制        │
│ 内存：立即翻倍       │ 内存：保持不变       │
│ 时间：O(进程大小)    │ 时间：O(1)           │
│ Page Fault：无       │ Page Fault：首次写入 │
│ 场景：多进程协作     │ 场景：fork-exec      │
└──────────────────────┴──────────────────────┘
```

#### 3.5.2 页面引用计数详解

**引用计数的数据结构**：

```c
// kern/mm/pmm.h
struct Page {
    int ref;            // 引用计数（多少个页表项指向此页）
    uint64_t flags;     // 页面标志
    unsigned int order; // 伙伴系统的阶数
    link_list_t page_link;  // 链表节点
};
```

**引用计数的生命周期**：

```
分配时：
┌─────────────────────────────┐
│ new_page = alloc_page()     │
│ ref = 0（未在任何页表中）   │
└────────────┬────────────────┘
             │
             ▼
使用时：
┌────────────────────────────────────────┐
│ page_insert(pgdir, page, addr, perm)  │
│ if (!page->ref++) {                   │
│     // 第一次使用                      │
│     // 初始化页面结构                  │
│ }                                      │
│ ref = 1（页表项指向此页）             │
└────────────┬───────────────────────────┘
             │
多个引用（fork COW 时）：
┌────────────────────────────────────────┐
│ page_ref_inc(page)  // fork 时          │
│ ref++               // ref: 1→2        │
│                                        │
│ 现在有两个页表项指向此页：            │
│ - 父进程 PTE: V=1, W=0, COW=1        │
│ - 子进程 PTE: V=1, W=0, COW=1        │
└────────────┬───────────────────────────┘
             │
释放时（COW 或进程退出）：
┌────────────────────────────────────────┐
│ 情况A: ref > 1（其他进程仍用此页）    │
│ page_ref_dec(page)  // ref: 2→1       │
│ if (--page->ref == 0) {               │
│     // 无人使用，标记为空闲            │
│ }                                      │
│ 结果：页面继续存在，其他进程继续用    │
│                                        │
│ 情况B: ref = 1（此页不再被使用）      │
│ page_ref_dec(page)  // ref: 1→0       │
│ if (--page->ref == 0) {               │
│     free_page(page)  // 回收到空闲列表│
│     页面内存可重新分配                 │
│ }                                      │
└────────────────────────────────────────┘
```

**引用计数在 COW 中的应用**：

```
场景：三进程 fork 链 A→B→C

初始状态（A 创建时）：
┌────────────────────────────────────────┐
│ 进程 A：ref=1 用户数据页               │
│ 页面：物理页 P (refcount=1)             │
└────────────────────────────────────────┘

A fork B（share=1）：
┌────────────────────────────────────────┐
│ page_ref_inc(P)  // refcount: 1→2     │
│ 页面 P：refcount=2                      │
│ - 父进程 A 的页表: 指向 P (R+COW)      │
│ - 子进程 B 的页表: 指向 P (R+COW)      │
└────────────────────────────────────────┘

B fork C（share=1）：
┌────────────────────────────────────────┐
│ page_ref_inc(P)  // refcount: 2→3     │
│ 页面 P：refcount=3                      │
│ - A 的页表: P (R+COW)                  │
│ - B 的页表: P (R+COW)                  │
│ - C 的页表: P (R+COW)                  │
└────────────────────────────────────────┘

A 写入（COW 触发）：
┌────────────────────────────────────────┐
│ 检查：page_ref(P) = 3 > 1              │
│ 操作：                                  │
│ 1. 分配新页面 P'                       │
│ 2. memcpy(P', P, PGSIZE)               │
│ 3. A 的页表: 改为指向 P' (R/W)        │
│ 4. page_ref_dec(P)  // refcount: 3→2  │
│ 结果：                                  │
│ - 页面 P：refcount=2（B、C 仍用）     │
│ - 页面 P'：refcount=1（A 独占）       │
│ - A 可以修改 P'，不影响 B、C           │
└────────────────────────────────────────┘

B 写入（COW 触发）：
┌────────────────────────────────────────┐
│ 检查：page_ref(P) = 2 > 1              │
│ 操作：                                  │
│ 1. 分配新页面 P''                      │
│ 2. memcpy(P'', P, PGSIZE)              │
│ 3. B 的页表: 改为指向 P'' (R/W)       │
│ 4. page_ref_dec(P)  // refcount: 2→1  │
│ 结果：                                  │
│ - 页面 P：refcount=1（只有 C 用）     │
│ - 页面 P''：refcount=1（B 独占）      │
└────────────────────────────────────────┘

C 写入（COW 优化）：
┌────────────────────────────────────────┐
│ 检查：page_ref(P) = 1（只有 C 用）   │
│ 优化：直接恢复写权限，无需复制         │
│ 操作：                                  │
│ 1. C 的页表: PTE 设置为 (R/W)          │
│ 2. 清除 COW 标志                       │
│ 3. TLB invalidate                      │
│ 结果：C 可以直接修改 P，无复制开销     │
│ refcount 保持为 1                      │
└────────────────────────────────────────┘

最终状态（A、B、C 都修改过）：
┌────────────────────────────────────────┐
│ 页面 P：refcount=0（无人用，回收）    │
│ 页面 P'：refcount=1（A 独占）         │
│ 页面 P''：refcount=1（B 独占）        │
│ 页面 P：refcount=1（C 独占，原 P）    │
│                                        │
│ 三个独立的页面副本，互不影响           │
└────────────────────────────────────────┘
```

**引用计数的原子性考虑**：

在单核、非抢占的 uCore 中：
```c
// 安全做法（uCore 实现）
page_ref_inc(page) {
    page->ref++;  // 单条汇编指令，不可被中断
}

page_ref_dec(page) {
    page->ref--;  // 单条汇编指令，不可被中断
}

if (page_ref(page) == 1) {  // 检查+操作原子性由上下文保证
    // 在关键路径中，禁用中断或持有锁
}
```

在多核或可抢占系统中：
```c
// 错误做法（竞争条件）
if (page->ref == 1) {
    // 之间可能被中断或其他 CPU 改变 ref
    page->ref--;  
}
// 结果：可能多个 CPU 同时判断 ref=1，都尝试释放

// 正确做法（需要锁）
spin_lock(&page->lock);
if (--page->ref == 0) {
    free_page(page);
}
spin_unlock(&page->lock);
```

### 3.6 声明函数

**文件**: `kern/mm/vmm.h`

```c
// COW page fault handler
int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr);
```

## 四、性能分析与优化

### 4.1 时间复杂度分析

**fork 操作**：

```
传统 fork（share=0）：
─────────────────────────────────────
操作                    复杂度      说明
─────────────────────────────────────
遍历所有 VMA           O(n)       n = VMA 数量（通常 5-10）
遍历所有页表项         O(m)       m = 页数
  ├─ 获取页表项        O(1)
  ├─ 分配新页面        O(1)
  ├─ memcpy 4KB        O(4096)    实际为常数时间（微秒级）
  └─ page_insert       O(1)
─────────────────────────────────────
总时间复杂度：         O(m × 4096)
实际时间：             N * 1-5 微秒（N=进程页数）

示例：100MB 进程（25600 页）
计算：25600 × 3μs ≈ 77ms
问题：fork 可能阻塞 77ms（用户能感觉到）


COW fork（share=1）：
─────────────────────────────────────
操作                    复杂度      说明
─────────────────────────────────────
遍历所有 VMA           O(n)       n = VMA 数量
遍历所有页表项         O(m)       m = 页数
  ├─ 获取页表项        O(1)
  ├─ 修改权限位        O(1)       只改标志，无 memcpy
  └─ 更新页表          O(1)
─────────────────────────────────────
总时间复杂度：         O(m)
实际时间：             N × 0.01 微秒（仅改标志位）

示例：100MB 进程
计算：25600 × 0.01μs ≈ 0.26ms
改进：77ms → 0.26ms（减少 296 倍！）
```

### 4.2 内存使用分析

**fork-exec 场景**（最常见）：

```
传统 fork：
时间 t=0:
  fork() 开始
  为子进程分配 100MB 内存（全部复制）
  ├─ 分配物理页      25600 × 4KB = 100MB
  ├─ 填充内容        通过 memcpy（耗时）
  └─ 建立页表映射
  fork() 结束，返回 PID
  
时间 t=0.1ms:
  exec() 调用
  清空子进程内存空间（全部释放！）
  分配新程序的内存
  
结果：100MB 的内存复制完全浪费！


COW fork：
时间 t=0:
  fork() 开始
  建立共享页面（无复制）
  ├─ 共享 100MB 内存（不分配新页）
  ├─ 修改权限为只读
  └─ fork() 完成，仅耗时 0.26ms
  
时间 t=0.26ms:
  exec() 调用
  清空页表映射
  分配新程序内存
  
结果：0 字节的内存复制，高效！


内存使用对比：
┌─────────────────┬──────────────┬──────────────┐
│                 │ 传统 fork    │ COW fork     │
├─────────────────┼──────────────┼──────────────┤
│ fork 后内存     │ 200MB        │ 100MB        │
│ 峰值内存        │ 200MB        │ 100MB        │
│ fork-exec 时间 │ 77ms + exec  │ 0.26ms + exec│
│ 内存浪费       │ 100MB        │ 0MB          │
└─────────────────┴──────────────┴──────────────┘
```

### 4.3 Page Fault 开销

**单次 COW 处理的成本**：

```
场景：子进程首次写入某页面

硬件异常处理：
├─ 异常前：CPU 状态保存        ~10 CPU 周期
├─ 上下文切换：S-mode trap     ~50 CPU 周期
└─ 异常处理后：恢复用户态      ~30 CPU 周期

do_pgfault 处理：
├─ find_vma()：VMA 查找        ~5 比较操作
├─ get_pte()：页表查询         ~2-3 次内存访问
├─ page_ref() 检查             ~1 次内存访问
├─ 情况A（ref=1）：
│  └─ 权限修改+TLB flush       ~10 CPU 周期
├─ 情况B（ref>1）：
│  ├─ alloc_page()：空闲列表   ~5 CPU 周期
│  ├─ memcpy(4KB)：内存复制    ~10000 CPU 周期（4KB/64字节 = 65次迭代）
│  ├─ 页表更新：page_insert   ~50 CPU 周期
│  └─ TLB flush                ~10 CPU 周期
└─ 异常返回：sret              ~30 CPU 周期

总成本估算（现代 CPU @ 2GHz）：
- 不需复制（ref=1）：~150 CPU 周期 ≈ 0.075μs
- 需要复制（ref>1）：~10,200 CPU 周期 ≈ 5μs

对比：
- 不触发异常：第一次写入正常速度（~1μs）
- 触发异常 ref=1：写入速度 × 75 倍
- 触发异常 ref>1：写入速度 × 5000 倍
```

### 4.4 最优应用场景

**COW 最优**：
```
1. fork-exec 模式（shell 运行程序）
   节省：避免大量内存复制
   
2. 多进程协作（快速分叉）
   节省：减少启动延迟
   
3. 大进程 fork（数据库、虚拟机）
   节省：可能的 GBytes 级别内存
```

**COW 次优**：
```
1. fork 后立即修改内存
   成本：触发多次 Page Fault
   但仍比传统方式节省内存
   
2. fork 深度链（A→B→C→D...）
   每层 fork：共享原页面，refcount 增加
   每层修改：refcount 递减，可能避免复制
```

**COW 不适用**：
```
1. 实时系统
   问题：Page Fault 延迟不确定
   解决：使用 mlockall() 锁定内存
   
2. 硬实时系统
   问题：即使 ref=1 也有 75 倍延迟
   解决：预分配内存，禁用 COW
```

## 五、常见问题与陷阱

### 5.1 只修改子进程页表的后果

**错误做法**：
```c
if (share) {
    // ❌ 只修改子进程，不修改父进程
    perm = (perm & ~PTE_W) | PTE_COW;
    *nptep = pte_create(page2ppn(page), perm);  // 子进程
    // 注意：没有修改 *ptep（父进程）
}
```

**为什么失败**：
```
状态对比：
┌──────────────────┬──────────────┬──────────────┐
│ 进程/页表项      │ 错误做法     │ 正确做法     │
├──────────────────┼──────────────┼──────────────┤
│ 父进程 PTE       │ V=1, W=1, COW=0 │ V=1, W=0, COW=1 │
│ 子进程 PTE       │ V=1, W=0, COW=1 │ V=1, W=0, COW=1 │
│ 共享物理页 P     │ refcount=2   │ refcount=2   │
└──────────────────┴──────────────┴──────────────┘

错误做法的后果：
1. 子进程写入：触发 Page Fault，执行 COW，复制页面 ✓
   - 子进程获得新页面 P'
   - 原页面 P 的 refcount: 2→1
   
2. 父进程写入：直接修改原页面 P，无异常 ✗
   - 父进程仍然 W=1，无异常
   - 修改数据直接作用在共享页面上
   - 子进程的独立副本看不到父进程的修改
   - 共享页面被父进程修改！

结果：
- 父进程和子进程都在修改相同的物理页面
- 修改互相干扰，产生不可预测的结果
- COW 失败，共享页面被污染
```

**正确做法**：
```c
if (share) {
    perm = (perm & ~PTE_W) | PTE_COW;
    *ptep = pte_create(page2ppn(page), perm);   // 父进程也改！
    page_ref_inc(page);
    *nptep = pte_create(page2ppn(page), perm);  // 子进程
    tlb_invalidate(from, start);  // 刷新父进程 TLB
    tlb_invalidate(to, start);
}
```

### 5.2 忘记刷新 TLB 的后果

**错误做法**：
```c
// ❌ 修改页表后没有刷新 TLB
*ptep = pte_create(page2ppn(page), new_perm);
// TLB 中仍保存旧映射：addr → Page(W=1, COW=0)
```

**为什么失败**：
```
地址转换流程：
虚拟地址 0x7fffff00
    ↓
┌─────────────────────────────────────┐
│ 1. TLB 查询：addr → (phys, perm)   │
│    TLB 命中（缓存）                 │
│    返回旧映射：phys_addr, W=1, ... │
│    不再查询页表！                   │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 2. MMU 权限检查：Store 指令         │
│    页表项被修改为：W=0, COW=1       │
│    但 TLB 中的权限仍是：W=1         │
│    MMU 使用 TLB 缓存的权限 ✗        │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 3. Store 指令执行                   │
│    权限检查：W=1（来自 TLB）✓       │
│    写入数据                         │
│    修改共享页面！                   │
└─────────────────────────────────────┘

预期流程（无 TLB）：
虚拟地址 0x7fffff00
    ↓
    查询页表：W=0, COW=1
    │
    ▼
    权限检查失败
    │
    ▼
    硬件异常：Store Page Fault
    │
    ▼
    内核处理：do_pgfault
```

**影响**：
- 第一次写入时仍然会成功（因为 TLB 缓存）
- 修改直接作用在共享页面上
- 其他进程看到了你的修改
- COW 保护失效

### 5.3 引用计数竞争条件

**单核情况（uCore）**：
```c
// 安全：中断被禁用，没有并发
if (--page->ref == 0) {
    free_page(page);
}
```

**多核情况**（不支持，列举作为参考）：
```c
// ❌ 不安全：竞争条件
// CPU1                          CPU2
if (page->ref == 1) {            if (page->ref == 1) {
    // CPU2 也许在此刻判断 ref=1
    page->ref--;                 page->ref--;  // 两个都减
}                                }
if (page->ref == 0) {            if (page->ref == 0) {
    free_page(page);  // CPU1释放  free_page(page);  // CPU2 也释放
}                                }
// 同一页面被释放两次！double free

// ✓ 正确：使用原子操作
if (atomic_dec_and_test(&page->ref)) {
    free_page(page);  // 只有一个 CPU 执行
}
```

### 5.4 虚拟地址对齐问题

**错误代码**：
```c
// ❌ 地址未对齐到页边界
do_pgfault(mm, cause, addr);  // addr = 0x7fffff5c
    │
    ▼
pte_t *ptep = get_pte(mm->pgdir, 0x7fffff5c, 0);
    │
    ▼ 内部会做对齐处理，但不规范
```

**正确做法**：
```c
// ✓ 调用前对齐
ret = page_insert(mm->pgdir, new_page, 
                  ROUNDDOWN(addr, PGSIZE), perm);
// ROUNDDOWN(0x7fffff5c, 4096) = 0x7fffff00
```

### 5.5 权限位组合不当

**常见错误**：
```c
// ❌ 保留了旧的 W 位
uint32_t perm = (*ptep & PTE_USER);  // 包含 W=1
perm |= PTE_COW;  // 现在是 W=1 AND COW=1
// 这是矛盾的：既可写又是 COW

// 正确做法
uint32_t perm = (*ptep & PTE_USER);
perm &= ~PTE_W;      // 移除 W
perm |= PTE_COW;     // 添加 COW
// 结果：W=0 AND COW=1（正确）

// 或更明确
uint32_t perm = ((*ptep & PTE_USER) & ~PTE_W) | PTE_COW;
```

### 5.6 VMA 权限检查不当

**错误**：
```c
// ❌ 没有检查 VMA 权限，直接处理 COW
if (!(*ptep & PTE_COW)) {
    return -E_INVAL;
}
// 如果 VMA 本身不允许写入，仍然会被当作 COW

// 后果：
// 代码段发生 Store 异常（不应该写）
// VMA: VM_READ|VM_EXEC（不含 VM_WRITE）
// 错误地被当作 COW 处理，给予写权限
// 代码段被修改！

// 正确做法
if (!(vma->vm_flags & VM_WRITE)) {
    // VMA 本身不允许写入
    // 这是真实的权限错误，不是 COW
    return -E_INVAL;
}
```

## 六、测试用例设计

**文件**: `user/cowtest.c`

```c
/*
 * cowtest.c - Test Copy-on-Write mechanism
 * 
 * 测试目标：
 * 1. 父子进程初始共享相同物理页面
 * 2. 子进程写入时触发 COW，分配新页面
 * 3. 子进程的修改对父进程不可见
 */

#include <stdio.h>
#include <ulib.h>

#define MAGIC_VALUE 0xDEADBEEF
#define MODIFIED_VALUE 0x12345678

// 全局变量测试 COW
volatile int shared_data = MAGIC_VALUE;

// 数组测试多页 COW
#define ARRAY_SIZE 256
volatile int test_array[ARRAY_SIZE];

int main(void)
{
    int i;
    
    cprintf("COW Test Program Start\n");
    cprintf("Initial shared_data = 0x%x (expect 0x%x)\n", shared_data, MAGIC_VALUE);
    
    // 初始化测试数组
    for (i = 0; i < ARRAY_SIZE; i++)
    {
        test_array[i] = i;
    }
    
    cprintf("Test array initialized\n");
    
    int pid = fork();
    
    if (pid < 0)
    {
        panic("fork failed!\n");
    }
    else if (pid == 0)
    {
        // 子进程
        cprintf("\n[Child] PID = %d\n", getpid());
        cprintf("[Child] Before write: shared_data = 0x%x\n", shared_data);
        
        // 验证初始值
        if (shared_data != MAGIC_VALUE)
        {
            cprintf("[Child] ERROR: shared_data should be 0x%x, got 0x%x\n", 
                    MAGIC_VALUE, shared_data);
        }
        
        // 写入 shared_data - 这里应该触发 COW
        cprintf("[Child] Writing to shared_data (COW should trigger)...\n");
        shared_data = MODIFIED_VALUE;
        cprintf("[Child] After write: shared_data = 0x%x\n", shared_data);
        
        if (shared_data != MODIFIED_VALUE)
        {
            cprintf("[Child] ERROR: write failed!\n");
        }
        
        // 修改数组元素
        cprintf("[Child] Modifying test_array[0] and test_array[100]...\n");
        test_array[0] = 9999;
        test_array[100] = 8888;
        
        cprintf("[Child] test_array[0] = %d, test_array[100] = %d\n", 
                test_array[0], test_array[100]);
        
        cprintf("[Child] COW Test in child completed\n");
        exit(0);
    }
    else
    {
        // 父进程
        cprintf("\n[Parent] PID = %d, Child PID = %d\n", getpid(), pid);
        
        // 等待子进程完成
        int child_pid = waitpid(pid, NULL);
        
        cprintf("\n[Parent] Child (PID %d) exited\n", child_pid);
        
        // 验证父进程数据未被修改
        cprintf("[Parent] shared_data = 0x%x (should still be 0x%x)\n", 
                shared_data, MAGIC_VALUE);
        
        if (shared_data != MAGIC_VALUE)
        {
            cprintf("[Parent] ERROR: COW failed! Parent data was modified!\n");
            cprintf("COW Test FAILED!\n");
        }
        else
        {
            cprintf("[Parent] SUCCESS: Parent data unchanged after child write\n");
        }
        
        // 检查数组值
        cprintf("[Parent] test_array[0] = %d (should be 0)\n", test_array[0]);
        cprintf("[Parent] test_array[100] = %d (should be 100)\n", test_array[100]);
        
        if (test_array[0] != 0 || test_array[100] != 100)
        {
            cprintf("[Parent] ERROR: Array values corrupted!\n");
            cprintf("COW Test FAILED!\n");
        }
        else
        {
            cprintf("[Parent] SUCCESS: Array values unchanged\n");
            cprintf("\n*** COW Test PASSED! ***\n");
        }
    }
    
    cprintf("COW Test Program End\n");
    return 0;
}
```

## 七、Debug 过程记录

### 5.1 编译错误 #1：wait 函数参数错误

**错误信息**：
```
user/cowtest.c:85:25: error: too many arguments to function 'wait'
   85 |         int child_pid = wait(&exit_code);
```

**原因分析**：
查看 `user/libs/ulib.h`，发现 uCore 的 `wait` 函数定义：
```c
int wait(void);  // 无参数
int waitpid(int pid, int *store);  // 有参数
```

**解决方案**：
```c
// 错误写法
int child_pid = wait(&exit_code);

// 正确写法
int child_pid = waitpid(pid, NULL);
```

### 5.2 编译警告：'page' may be used uninitialized

**警告信息**：
```
kern/mm/pmm.h:91:17: warning: 'page' may be used uninitialized
kern/process/proc.c:613:18: note: 'page' was declared here
```

**原因分析**：
在 `load_icode` 函数中，`page` 变量在某些代码路径下可能未初始化就被使用。

**说明**：
这是一个编译器警告，实际运行中不会出现问题，因为 `page` 只在成功分配后才被使用。可以通过初始化为 NULL 来消除警告：
```c
struct Page *page = NULL;
```

### 5.3 潜在问题：TLB 一致性

**问题描述**：
修改页表项后，TLB 中可能缓存了旧的映射信息。

**解决方案**：
在 `copy_range` 和 `do_pgfault` 中都调用 `tlb_invalidate`：
```c
tlb_invalidate(mm->pgdir, addr);
```

### 5.4 潜在问题：引用计数竞争

**问题描述**：
在多核或抢占式系统中，`page_ref` 的检查和后续操作之间可能存在竞争。

**当前实现的限制**：
uCore Lab5 是单核非抢占内核，因此不存在此问题。但在实际操作系统中需要：
1. 使用原子操作
2. 或持有适当的锁

## 八、COW 状态机

```
                            ┌──────────────────┐
                            │   初始状态       │
                            │  Page: R/W       │
                            │  ref_count: 1    │
                            └────────┬─────────┘
                                     │
                                  fork()
                                     │
                                     ▼
                    ┌────────────────────────────────┐
                    │         COW 共享状态            │
                    │  父进程 PTE: R + COW           │
                    │  子进程 PTE: R + COW           │
                    │  共享 Page ref_count: 2       │
                    └───────────────┬────────────────┘
                                    │
                    ┌───────────────┴───────────────┐
                    │                               │
              子进程写入                       父进程写入
            (Store Fault)                    (Store Fault)
                    │                               │
                    ▼                               ▼
        ┌───────────────────────┐     ┌───────────────────────┐
        │   COW 处理 (子)        │     │   COW 处理 (父)        │
        │ 1. alloc new page     │     │ 1. alloc new page     │
        │ 2. copy content       │     │ 2. copy content       │
        │ 3. update child PTE   │     │ 3. update parent PTE  │
        │    to new page (R/W)  │     │    to new page (R/W)  │
        │ 4. dec old page ref   │     │ 4. dec old page ref   │
        └───────────┬───────────┘     └───────────┬───────────┘
                    │                               │
                    ▼                               ▼
        ┌───────────────────────┐     ┌───────────────────────┐
        │ 子进程独立页面         │     │ 父进程独立页面         │
        │ 新 Page: R/W          │     │ 新 Page: R/W          │
        │ ref_count: 1          │     │ ref_count: 1          │
        └───────────────────────┘     └───────────────────────┘
        
        原共享页面: ref_count 减 1
        (当 ref_count=0 时自动释放)
```

## 九、文件修改清单

| 文件 | 修改类型 | 说明 |
|------|----------|------|
| `kern/mm/mmu.h` | 修改 | 添加 `PTE_COW` 宏定义 |
| `kern/mm/pmm.c` | 修改 | `copy_range` 支持 COW 模式 |
| `kern/mm/vmm.c` | 修改 | 添加 `do_pgfault`，修改 `dup_mmap` |
| `kern/mm/vmm.h` | 修改 | 声明 `do_pgfault` 函数 |
| `kern/trap/trap.c` | 修改 | 处理 Store Page Fault |
| `user/cowtest.c` | 新增 | COW 测试程序 |

## 十、测试方法

1. 编译：
```bash
make clean
make qemu
```

2. 运行 COW 测试（需修改 `kern/process/proc.c` 中的 `user_main` 函数）：

**修改 user_main 函数**：
```c
static int
user_main(void *arg)
{
#ifdef TEST
    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);
#else
    KERNEL_EXECVE(cowtest);  // 将 exit 改为 cowtest
#endif
    panic("user_main execve failed.\n");
}
```

3. 预期输出：
```
COW Test Program Start
Initial shared_data = 0xDEADBEEF (expect 0xDEADBEEF)
Test array initialized

[Parent] PID = 2, Child PID = 3

[Child] PID = 3
[Child] Before write: shared_data = 0xDEADBEEF
[Child] Writing to shared_data (COW should trigger)...
Store/AMO page fault at 0x...  <-- COW 触发
[Child] After write: shared_data = 0x12345678
[Child] COW Test in child completed

[Parent] Child (PID 3) exited
[Parent] shared_data = 0xDEADBEEF (should still be 0xDEADBEEF)
[Parent] SUCCESS: Parent data unchanged after child write
[Parent] test_array[0] = 0 (should be 0)
[Parent] test_array[100] = 100 (should be 100)
[Parent] SUCCESS: Array values unchanged

*** COW Test PASSED! ***
```

## 十一、实际运行结果

### 9.1 运行默认 exit 程序（验证 COW 基本功能）

```
jay@jay-virtual-machine:~/桌面/labcode/lab5-challenge$ make qemu
...
(THU.CST) os is loading ...
...
kernel_execve: pid = 2, name = "exit".
Breakpoint
I am the parent. Forking the child...
Store/AMO page fault at 0x7fffff5c    <-- COW 触发！
I am parent, fork a child pid 3
I am the parent, waiting now..
I am the child.
waitpid 3 ok.
exit pass.
all user-mode processes have quit.
init check memory pass.
kernel panic at kern/process/proc.c:537:
    initproc exit.
```

**分析**：
- `Store/AMO page fault at 0x7fffff5c` 表明 COW 机制已生效
- 地址 `0x7fffff5c` 位于用户栈区域（栈顶 `USTACKTOP = 0x80000000`）
- 这是子进程首次写入栈时触发的 COW 页面复制
- `exit pass` 表明程序正确执行完成

### 9.2 COW 工作流程验证

从运行结果可以确认：
1. ✅ `fork()` 时父子进程共享页面（未立即复制）
2. ✅ 子进程写入时触发 `Store/AMO page fault`
3. ✅ `do_pgfault` 正确处理 COW，分配新页面
4. ✅ 程序正常执行完成，说明 COW 复制后数据正确

## 十二、总结

COW 机制的实现涉及以下核心组件的协作：

1. **内存管理 (pmm.c)**：负责页面的共享和复制
2. **虚拟内存 (vmm.c)**：处理页面错误，执行实际的 COW 操作
3. **异常处理 (trap.c)**：捕获 Store Page Fault，调用 COW 处理函数
4. **页表标志 (mmu.h)**：使用保留位标记 COW 页面

通过这种实现，`fork()` 的性能得到显著提升，特别是在 fork-exec 模式下，可以完全避免不必要的内存复制。



